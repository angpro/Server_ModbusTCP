diff --git a/.idea/vcs.xml b/.idea/vcs.xml
index 94a25f7..87b8c85 100644
--- a/.idea/vcs.xml
+++ b/.idea/vcs.xml
@@ -2,5 +2,6 @@
 <project version="4">
   <component name="VcsDirectoryMappings">
     <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/pymodbus" vcs="Git" />
   </component>
 </project>
\ No newline at end of file
diff --git a/pymodbus b/pymodbus
--- a/pymodbus
+++ b/pymodbus
@@ -1 +1 @@
-Subproject commit 31c165026f94dccb851a05f0fb32adcbf39003eb
+Subproject commit 31c165026f94dccb851a05f0fb32adcbf39003eb-dirty
diff --git a/venv/bin/pymodbus.console b/venv/bin/pymodbus.console
index 31f9b13..6304ae2 100755
--- a/venv/bin/pymodbus.console
+++ b/venv/bin/pymodbus.console
@@ -1,11 +1,12 @@
 #!/Users/Makbukuska/Desktop/Task_ModbusTCP/venv/bin/python
-
-# -*- coding: utf-8 -*-
+# EASY-INSTALL-ENTRY-SCRIPT: 'pymodbus','console_scripts','pymodbus.console'
+__requires__ = 'pymodbus'
 import re
 import sys
-
-from pymodbus.repl.main import main
+from pkg_resources import load_entry_point
 
 if __name__ == '__main__':
     sys.argv[0] = re.sub(r'(-script\.pyw?|\.exe)?$', '', sys.argv[0])
-    sys.exit(main())
+    sys.exit(
+        load_entry_point('pymodbus', 'console_scripts', 'pymodbus.console')()
+    )
diff --git a/venv/lib/python3.7/site-packages/easy-install.pth b/venv/lib/python3.7/site-packages/easy-install.pth
index 7cfbf40..6857012 100644
--- a/venv/lib/python3.7/site-packages/easy-install.pth
+++ b/venv/lib/python3.7/site-packages/easy-install.pth
@@ -1,2 +1,3 @@
 ./setuptools-39.1.0-py3.7.egg
 ./pip-10.0.1-py3.7.egg
+/Users/Makbukuska/Desktop/Task_ModbusTCP/pymodbus
diff --git a/venv/lib/python3.7/site-packages/ez_setup.py b/venv/lib/python3.7/site-packages/ez_setup.py
deleted file mode 100644
index 0f92ac8..0000000
--- a/venv/lib/python3.7/site-packages/ez_setup.py
+++ /dev/null
@@ -1,289 +0,0 @@
-#!python
-from __future__ import print_function
-"""Bootstrap setuptools installation
-
-If you want to use setuptools in your package's setup.py, just include this
-file in the same directory with it, and add this to the top of your setup.py::
-
-    from ez_setup import use_setuptools
-    use_setuptools()
-
-If you want to require a specific version of setuptools, set a download
-mirror, or use an alternate download directory, you can do so by supplying
-the appropriate options to ``use_setuptools()``.
-
-This file can also be run as a script to install or upgrade setuptools.
-"""
-import sys
-
-DEFAULT_VERSION = "0.6c11"
-DEFAULT_URL     = "http://pypi.python.org/packages/%s/s/setuptools/" % sys.version[:3]
-IS_PYTHON3 = sys.version_info[0] == 3
-
-md5_data = {
-    'setuptools-0.6b1-py2.3.egg': '8822caf901250d848b996b7f25c6e6ca',
-    'setuptools-0.6b1-py2.4.egg': 'b79a8a403e4502fbb85ee3f1941735cb',
-    'setuptools-0.6b2-py2.3.egg': '5657759d8a6d8fc44070a9d07272d99b',
-    'setuptools-0.6b2-py2.4.egg': '4996a8d169d2be661fa32a6e52e4f82a',
-    'setuptools-0.6b3-py2.3.egg': 'bb31c0fc7399a63579975cad9f5a0618',
-    'setuptools-0.6b3-py2.4.egg': '38a8c6b3d6ecd22247f179f7da669fac',
-    'setuptools-0.6b4-py2.3.egg': '62045a24ed4e1ebc77fe039aa4e6f7e5',
-    'setuptools-0.6b4-py2.4.egg': '4cb2a185d228dacffb2d17f103b3b1c4',
-    'setuptools-0.6c1-py2.3.egg': 'b3f2b5539d65cb7f74ad79127f1a908c',
-    'setuptools-0.6c1-py2.4.egg': 'b45adeda0667d2d2ffe14009364f2a4b',
-    'setuptools-0.6c10-py2.3.egg': 'ce1e2ab5d3a0256456d9fc13800a7090',
-    'setuptools-0.6c10-py2.4.egg': '57d6d9d6e9b80772c59a53a8433a5dd4',
-    'setuptools-0.6c10-py2.5.egg': 'de46ac8b1c97c895572e5e8596aeb8c7',
-    'setuptools-0.6c10-py2.6.egg': '58ea40aef06da02ce641495523a0b7f5',
-    'setuptools-0.6c11-py2.3.egg': '2baeac6e13d414a9d28e7ba5b5a596de',
-    'setuptools-0.6c11-py2.4.egg': 'bd639f9b0eac4c42497034dec2ec0c2b',
-    'setuptools-0.6c11-py2.5.egg': '64c94f3bf7a72a13ec83e0b24f2749b2',
-    'setuptools-0.6c11-py2.6.egg': 'bfa92100bd772d5a213eedd356d64086',
-    'setuptools-0.6c2-py2.3.egg': 'f0064bf6aa2b7d0f3ba0b43f20817c27',
-    'setuptools-0.6c2-py2.4.egg': '616192eec35f47e8ea16cd6a122b7277',
-    'setuptools-0.6c3-py2.3.egg': 'f181fa125dfe85a259c9cd6f1d7b78fa',
-    'setuptools-0.6c3-py2.4.egg': 'e0ed74682c998bfb73bf803a50e7b71e',
-    'setuptools-0.6c3-py2.5.egg': 'abef16fdd61955514841c7c6bd98965e',
-    'setuptools-0.6c4-py2.3.egg': 'b0b9131acab32022bfac7f44c5d7971f',
-    'setuptools-0.6c4-py2.4.egg': '2a1f9656d4fbf3c97bf946c0a124e6e2',
-    'setuptools-0.6c4-py2.5.egg': '8f5a052e32cdb9c72bcf4b5526f28afc',
-    'setuptools-0.6c5-py2.3.egg': 'ee9fd80965da04f2f3e6b3576e9d8167',
-    'setuptools-0.6c5-py2.4.egg': 'afe2adf1c01701ee841761f5bcd8aa64',
-    'setuptools-0.6c5-py2.5.egg': 'a8d3f61494ccaa8714dfed37bccd3d5d',
-    'setuptools-0.6c6-py2.3.egg': '35686b78116a668847237b69d549ec20',
-    'setuptools-0.6c6-py2.4.egg': '3c56af57be3225019260a644430065ab',
-    'setuptools-0.6c6-py2.5.egg': 'b2f8a7520709a5b34f80946de5f02f53',
-    'setuptools-0.6c7-py2.3.egg': '209fdf9adc3a615e5115b725658e13e2',
-    'setuptools-0.6c7-py2.4.egg': '5a8f954807d46a0fb67cf1f26c55a82e',
-    'setuptools-0.6c7-py2.5.egg': '45d2ad28f9750e7434111fde831e8372',
-    'setuptools-0.6c8-py2.3.egg': '50759d29b349db8cfd807ba8303f1902',
-    'setuptools-0.6c8-py2.4.egg': 'cba38d74f7d483c06e9daa6070cce6de',
-    'setuptools-0.6c8-py2.5.egg': '1721747ee329dc150590a58b3e1ac95b',
-    'setuptools-0.6c9-py2.3.egg': 'a83c4020414807b496e4cfbe08507c03',
-    'setuptools-0.6c9-py2.4.egg': '260a2be2e5388d66bdaee06abec6342a',
-    'setuptools-0.6c9-py2.5.egg': 'fe67c3e5a17b12c0e7c541b7ea43a8e6',
-    'setuptools-0.6c9-py2.6.egg': 'ca37b1ff16fa2ede6e19383e7b59245a',
-}
-
-import sys, os
-try: from hashlib import md5
-except ImportError: from md5 import md5
-
-
-def print_error(msg, **kwargs):
-    print(msg, file=sys.stderr, **kwargs)
-
-
-def _validate_md5(egg_name, data):
-    if egg_name in md5_data:
-        digest = md5(data).hexdigest()
-        if digest != md5_data[egg_name]:
-            print_error("md5 validation of %s failed!  (Possible download problem?)" % egg_name)
-            sys.exit(2)
-    return data
-
-def use_setuptools(
-    version=DEFAULT_VERSION, download_base=DEFAULT_URL, to_dir=os.curdir,
-    download_delay=15
-):
-    """Automatically find/download setuptools and make it available on sys.path
-
-    `version` should be a valid setuptools version number that is available
-    as an egg for download under the `download_base` URL (which should end with
-    a '/').  `to_dir` is the directory where setuptools will be downloaded, if
-    it is not already available.  If `download_delay` is specified, it should
-    be the number of seconds that will be paused before initiating a download,
-    should one be required.  If an older version of setuptools is installed,
-    this routine will print a message to ``sys.stderr`` and raise SystemExit in
-    an attempt to abort the calling script.
-    """
-    was_imported = 'pkg_resources' in sys.modules or 'setuptools' in sys.modules
-    def do_download():
-        egg = download_setuptools(version, download_base, to_dir, download_delay)
-        sys.path.insert(0, egg)
-        import setuptools; setuptools.bootstrap_install_from = egg
-    try:
-        import pkg_resources
-    except ImportError:
-        return do_download()       
-    try:
-        pkg_resources.require("setuptools>="+version); return
-    except pkg_resources.VersionConflict as e:
-        if was_imported:
-            print_error((
-            "The required version of setuptools (>=%s) is not available, and\n"
-            "can't be installed while this script is running. Please install\n"
-            " a more recent version first, using 'easy_install -U setuptools'."
-            "\n\n(Currently using %r)"
-            ) % (version, e.args[0]))
-            sys.exit(2)
-    except pkg_resources.DistributionNotFound:
-        pass
-
-    del pkg_resources, sys.modules['pkg_resources']    # reload ok
-    return do_download()
-
-def download_setuptools(
-    version=DEFAULT_VERSION, download_base=DEFAULT_URL, to_dir=os.curdir,
-    delay = 15
-):
-    """Download setuptools from a specified location and return its filename
-
-    `version` should be a valid setuptools version number that is available
-    as an egg for download under the `download_base` URL (which should end
-    with a '/'). `to_dir` is the directory where the egg will be downloaded.
-    `delay` is the number of seconds to pause before an actual download attempt.
-    """
-    import urllib.request, urllib.error, urllib.parse, shutil
-    egg_name = "setuptools-%s-py%s.egg" % (version,sys.version[:3])
-    url = download_base + egg_name
-    saveto = os.path.join(to_dir, egg_name)
-    src = dst = None
-    if not os.path.exists(saveto):  # Avoid repeated downloads
-        try:
-            from distutils import log
-            if delay:
-                log.warn("""
----------------------------------------------------------------------------
-This script requires setuptools version %s to run (even to display
-help).  I will attempt to download it for you (from
-%s), but
-you may need to enable firewall access for this script first.
-I will start the download in %d seconds.
-
-(Note: if this machine does not have network access, please obtain the file
-
-   %s
-
-and place it in this directory before rerunning this script.)
----------------------------------------------------------------------------""",
-                    version, download_base, delay, url
-                ); from time import sleep; sleep(delay)
-            log.warn("Downloading %s", url)
-            src = urllib.request.urlopen(url)
-            # Read/write all in one block, so we don't create a corrupt file
-            # if the download is interrupted.
-            data = _validate_md5(egg_name, src.read())
-            dst = open(saveto,"wb"); dst.write(data)
-        finally:
-            if src: src.close()
-            if dst: dst.close()
-    return os.path.realpath(saveto)
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-def main(argv, version=DEFAULT_VERSION):
-    """Install or upgrade setuptools and EasyInstall"""
-    try:
-        import setuptools
-    except ImportError:
-        egg = None
-        try:
-            egg = download_setuptools(version, delay=0)
-            sys.path.insert(0,egg)
-            from setuptools.command.easy_install import main
-            return main(list(argv)+[egg])   # we're done here
-        finally:
-            if egg and os.path.exists(egg):
-                os.unlink(egg)
-    else:
-        if setuptools.__version__ == '0.0.1':
-            print((
-            "You have an obsolete version of setuptools installed.  Please\n"
-            "remove it from your system entirely before rerunning this script."
-            ), file=sys.stderr)
-            sys.exit(2)
-
-    req = "setuptools>="+version
-    import pkg_resources
-    try:
-        pkg_resources.require(req)
-    except pkg_resources.VersionConflict:
-        try:
-            from setuptools.command.easy_install import main
-        except ImportError:
-            from easy_install import main
-        main(list(argv)+[download_setuptools(delay=0)])
-        sys.exit(0) # try to force an exit
-    else:
-        if argv:
-            from setuptools.command.easy_install import main
-            main(argv)
-        else:
-            print("Setuptools version",version,"or greater has been installed.")
-            print('(Run "ez_setup.py -U setuptools" to reinstall or upgrade.)')
-
-def update_md5(filenames):
-    """Update our built-in md5 registry"""
-
-    import re
-
-    for name in filenames:
-        base = os.path.basename(name)
-        f = open(name,'rb')
-        md5_data[base] = md5(f.read()).hexdigest()
-        f.close()
-
-    data = ["    %r: %r,\n" % it for it in list(md5_data.items())]
-    data.sort()
-    repl = "".join(data)
-
-    import inspect
-    srcfile = inspect.getsourcefile(sys.modules[__name__])
-    f = open(srcfile, 'rb'); src = f.read(); f.close()
-
-    match = re.search("\nmd5_data = {\n([^}]+)}", src)
-    if not match:
-        print("Internal error!", file=sys.stderr)
-        sys.exit(2)
-
-    src = src[:match.start(1)] + repl + src[match.end(1):]
-    f = open(srcfile,'w')
-    f.write(src)
-    f.close()
-
-
-if __name__=='__main__':
-    if len(sys.argv)>2 and sys.argv[1]=='--md5update':
-        update_md5(sys.argv[2:])
-    else:
-        main(sys.argv[1:])
-
-
-
-
-
-
diff --git a/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/INSTALLER b/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/INSTALLER
deleted file mode 100644
index a1b589e..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/INSTALLER
+++ /dev/null
@@ -1 +0,0 @@
-pip
diff --git a/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/METADATA b/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/METADATA
deleted file mode 100644
index 9d94279..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/METADATA
+++ /dev/null
@@ -1,54 +0,0 @@
-Metadata-Version: 2.1
-Name: pymodbus
-Version: 2.2.0
-Summary: A fully featured modbus protocol stack in python
-Home-page: https://github.com/riptideio/pymodbus/
-Author: Galen Collins
-Author-email: bashwork@gmail.com
-Maintainer: dhoomakethu
-Maintainer-email: otlasanju@gmail.com
-License: BSD
-Keywords: modbus,twisted,scada
-Platform: Linux
-Platform: Mac OS X
-Platform: Win
-Classifier: Development Status :: 4 - Beta
-Classifier: Environment :: Console
-Classifier: Environment :: X11 Applications :: GTK
-Classifier: Framework :: Twisted
-Classifier: Intended Audience :: Developers
-Classifier: License :: OSI Approved :: BSD License
-Classifier: Operating System :: POSIX :: Linux
-Classifier: Operating System :: Unix
-Classifier: Programming Language :: Python
-Classifier: Topic :: System :: Networking
-Classifier: Topic :: Utilities
-Requires-Dist: six (==1.11.0)
-Requires-Dist: pyserial (>=3.4)
-Provides-Extra: documents
-Requires-Dist: sphinx (>=1.1.3) ; extra == 'documents'
-Requires-Dist: sphinx-rtd-theme ; extra == 'documents'
-Requires-Dist: humanfriendly ; extra == 'documents'
-Provides-Extra: quality
-Requires-Dist: coverage (>=3.5.3) ; extra == 'quality'
-Requires-Dist: nose (>=1.2.1) ; extra == 'quality'
-Requires-Dist: mock (>=1.0.0) ; extra == 'quality'
-Requires-Dist: pep8 (>=1.3.3) ; extra == 'quality'
-Provides-Extra: repl
-Requires-Dist: click (>=6.7) ; extra == 'repl'
-Requires-Dist: prompt-toolkit (==2.0.4) ; extra == 'repl'
-Requires-Dist: pygments (==2.2.0) ; extra == 'repl'
-Provides-Extra: tornado
-Requires-Dist: tornado (>=4.5.3) ; extra == 'tornado'
-Provides-Extra: twisted
-Requires-Dist: twisted (>=12.2.0) ; extra == 'twisted'
-Requires-Dist: pyasn1 (>=0.1.4) ; extra == 'twisted'
-Requires-Dist: pycrypto (>=2.6) ; extra == 'twisted'
-
-
-Pymodbus aims to be a fully implemented modbus protocol stack 
-implemented using twisted/asyncio/tornado.  
-Its orignal goal was to allow simulation of thousands of modbus devices
-on a single machine for monitoring software testing.
-
-
diff --git a/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/RECORD b/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/RECORD
deleted file mode 100644
index bdf1e35..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/RECORD
+++ /dev/null
@@ -1,134 +0,0 @@
-ez_setup.py,sha256=RVk3x4HMErzM2zwvT9bF-CrqXdycPOgfmo8qXCiqs0s,10392
-pymodbus/__init__.py,sha256=5q9dU5FuWdbgP99Xhk5bGKW4fUcqdF1QhZryB8vRVX0,899
-pymodbus/bit_read_message.py,sha256=_ODzGFLWv9rxm4oGfz6vVcg0av79DQ_Gtu4IN7Hcnuk,8582
-pymodbus/bit_write_message.py,sha256=vNgGWzFbMFBY1kyTt-qQK2Cr7HZsx6USnpmn2D45C6Q,9205
-pymodbus/compat.py,sha256=gNPoW92jhC8Nyn8QM3cm4Wty_2XwsdP1FYyIjl7SYes,3285
-pymodbus/constants.py,sha256=4Edp9QLQmiOFq9-MkQGsG5_6zF7moRYtduXbuLtJrjA,7064
-pymodbus/device.py,sha256=5CCn7lZAzZd_6DydMxnVlsLYznYcfJwApMfQ7RJ5SEE,23243
-pymodbus/diag_message.py,sha256=fU7Qzkbeid2bbD0-JIqsiTrJc8k3dC0fsMPvKtL8A5I,29229
-pymodbus/events.py,sha256=G4zFdgl-QCTO-Aaiyu_sqJil0qy4ghTG2aZO9YGS01w,6382
-pymodbus/exceptions.py,sha256=8Ye0YahM3891HStRlL9D5qrmLzz2GGBX8XBacg8chfE,3337
-pymodbus/factory.py,sha256=wQNqOCggXBv215O2iurNLToZnXIjrH0ASwc7287YDvc,12413
-pymodbus/file_message.py,sha256=S6RwzAQEZmLyEADNnCSs6VKYD7c0XdsCok3G83rqS00,14237
-pymodbus/interfaces.py,sha256=-zPsYRHeeASXZ9jDuPFylnPmU60B01JG5t9m-9F2P1k,8365
-pymodbus/mei_message.py,sha256=zm1Zphxd6DSwb3ZGwHmzKgpV-3w5tXCRjUgJA6cCgWE,7939
-pymodbus/other_message.py,sha256=Tmf8eln6kG6AKv9XL7ksSwjuBegH89NHfc37bu5AD7E,14753
-pymodbus/payload.py,sha256=aJWnp_mtrJ9iNK6_RmYMzaNEn3pAnNtZlC-71JRYUuQ,16068
-pymodbus/pdu.py,sha256=1uwNz7uo3ryYu0kvJbzhXdPyp1t3bJhCnH3EZlqNKeI,7965
-pymodbus/register_read_message.py,sha256=24YbOKYZ5IC7-KFKVCodqsY0hH5bYWB7uiu9BmlAzhs,12949
-pymodbus/register_write_message.py,sha256=1iA_v8y_9_1yKRpKocj0QbIYtJKg-Tfr8v_OhHpdsj4,12058
-pymodbus/transaction.py,sha256=8OCcGpZNp0fTQzGl8V_io6rq1T06y3MsWOdGfKSIJH8,19176
-pymodbus/utilities.py,sha256=6zW2Rm61POFGsoFggjHSqw7qMneg7abYRnxnQvElCpM,7371
-pymodbus/version.py,sha256=UXGVFFrUycZo5P6zqc5ypGLZ4rMqD0rWyaZY4bJ1uwY,1551
-pymodbus/client/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-pymodbus/client/common.py,sha256=Veallpl4lDVg80uc1orxuMa2b2uWMoFyaYxDoWBr3p8,5668
-pymodbus/client/sync.py,sha256=mYLxcmTHttIqhECVnCqSqN8fVuMm4noN-DTKgnqbwsc,20935
-pymodbus/client/asynchronous/__init__.py,sha256=B6SngzocplSmY02mcn5YSYL6rWRVrOz4UwXCZheEIQo,1630
-pymodbus/client/asynchronous/mixins.py,sha256=vC3KnmGzQq-Xn5y8jYEleB7sdag4UD6UJnv6uJObBd0,2145
-pymodbus/client/asynchronous/serial.py,sha256=fuAF0d5sfTlEvqovklu4o3K-nEizt2Wu8-6OP10l48M,2625
-pymodbus/client/asynchronous/tcp.py,sha256=bCMQBqGv9jceDgXsJS5f34B-I5RDa91-mKdtrblrEIc,1679
-pymodbus/client/asynchronous/thread.py,sha256=CXeIFnnSC3v-NLIYlFq2xL20BGdqMXwlpB-Z2OhiXPg,1464
-pymodbus/client/asynchronous/udp.py,sha256=22WMN2rngiAhIutKkdSupQrgzLxSg_Y7tCoI9RQ__20,1676
-pymodbus/client/asynchronous/asyncio/__init__.py,sha256=GqLvK2dnaQ0PfiB8B9YLrA5odF0vOW3ztcRFXsmxgCk,24915
-pymodbus/client/asynchronous/deprecated/__init__.py,sha256=HG1K4M3Hoaqnnz9qwY6mopYVZgot30PFLmbHGt92Pk4,1741
-pymodbus/client/asynchronous/deprecated/asynchronous.py,sha256=ilw9R3YPAMcOEf4OS1Sv5kcoUSBZxAM1BG0prpAs9W0,8494
-pymodbus/client/asynchronous/factory/__init__.py,sha256=87aNeSxunYdTfIfTBbJ-ojkm5OgInEV3hZMd22-CJQI,56
-pymodbus/client/asynchronous/factory/serial.py,sha256=SowENm7nep4SgnbsnAcdVd-b0qGkcjlZPvJthjZuYxg,4275
-pymodbus/client/asynchronous/factory/tcp.py,sha256=VW4_C_3VWSkkTXb3tEyVePi2T56TIqYnMopQcjsSePE,4039
-pymodbus/client/asynchronous/factory/udp.py,sha256=aNJUeezi62qrVYvp99EeJC-fzUKAOJsfcayeBMKRQuA,3108
-pymodbus/client/asynchronous/schedulers/__init__.py,sha256=eJfP7w20glwILsQulZuOk3ng21ff8Z_xMcWYIxn76UI,165
-pymodbus/client/asynchronous/tornado/__init__.py,sha256=9VBXlqAoqyHb5vkSVNDR5WjskWewfadMyW6G9ypDONU,9327
-pymodbus/client/asynchronous/twisted/__init__.py,sha256=LhTAYiI1fsK5CEEKhqP1h4UTCq4fIxp8KmoG2x8pcKw,8539
-pymodbus/datastore/__init__.py,sha256=tZ7B-qlo2vbuHnT_zjUWDo4fXQAQ3kOJP2vwP24JYB8,536
-pymodbus/datastore/context.py,sha256=AD_3t_Y37a-xfY3R1SdihiBif_XfgjdqGaCLvrnY9Mg,6895
-pymodbus/datastore/remote.py,sha256=Bvvn0F_LrVSadYuI_S4O1LJZGc9A1rTl3GOCfHv57_k,4084
-pymodbus/datastore/store.py,sha256=uYkbTz0igJT5gBNAKLHuJiU2ujEnyrPw6RIj2Xu6v7Q,8820
-pymodbus/datastore/database/__init__.py,sha256=853BBXXadx8uJ_1xrQg7qKE7Y-lBH40qzIPZe462FEw,371
-pymodbus/datastore/database/redis_datastore.py,sha256=O3chX5mHnSOM18ElIfOCRXpLd19l3zsbuXtc3HTsI7U,9173
-pymodbus/datastore/database/sql_datastore.py,sha256=39eH_yn9KR1yksalHv-wwprwkMBofjxudEWO0czBoGY,7200
-pymodbus/framer/__init__.py,sha256=3XPIPY38_L08DQNnhb9khlTzcRWY7hIfcMLG9V4PYi4,1354
-pymodbus/framer/ascii_framer.py,sha256=S7ffc8mLAAe9rModMlel23baMIWI_tBTsMCaysJTPhs,7603
-pymodbus/framer/binary_framer.py,sha256=sXNXQ9NLVqEVLCCxqdaXGNv8IqUcUFcAlb_tfQC-MIM,8286
-pymodbus/framer/rtu_framer.py,sha256=dbVplIJ6KgexPFGOlEnXzW3d3QPztYOUQ1Y4YyXVLvc,12342
-pymodbus/framer/socket_framer.py,sha256=Jigb79kVkTBNCJdE5KziyWk4sRAFV-pd9JvMDSL2ZDU,8349
-pymodbus/internal/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-pymodbus/internal/ptwisted.py,sha256=TkpSbE_7EF0kD_qxoLSozfuOCCMNRVtdTrstZFD2KRo,1488
-pymodbus/repl/__init__.py,sha256=XLM5_8CL0e_37bb71YPvFbUT4DgbAsgASxhIPbJDI14,145
-pymodbus/repl/client.py,sha256=NbateHfHS_mRfWZOKtfJbA6N7nUjgtJddAtUSeh4cMU,24782
-pymodbus/repl/completer.py,sha256=04MSNxGYdzSaROv-nZ84didRmJMpCV6BOBXq3F4mXkE,5424
-pymodbus/repl/helper.py,sha256=0xorxyHvrIMGhhY7QahrhGKtuKs-M4LCAnXoTyiH4ro,10544
-pymodbus/repl/main.py,sha256=RM5wOMpS6ac40lENivEU_MPOl5CaLr4y-u7W9J6QKOQ,11604
-pymodbus/server/__init__.py,sha256=FsZYAJXPwAo8w7rw9BY95Y5IDedJ_bJ0gKzdD2M4ZQA,8
-pymodbus/server/asynchronous.py,sha256=j5P-MHdlVRpuyHOsuduJmVwsJbrIjVC4h0Bqor8F1x0,14624
-pymodbus/server/sync.py,sha256=1v8FgBSqXOg2tvKUb5DYvsnnTbESJRAkOIAo2bBPjkY,24989
-pymodbus-2.2.0.dist-info/METADATA,sha256=x5c1XFL6JsyCAZCQSAD_NdxYTm_1fURmxDo9oCLtd0E,1987
-pymodbus-2.2.0.dist-info/WHEEL,sha256=HX-v9-noUkyUoxyZ1PMSuS7auUxDAR4VBdoYLqD0xws,110
-pymodbus-2.2.0.dist-info/entry_points.txt,sha256=UAccHc2U_NCqC2B2nU6os2c-0NSPdZsy3Z40set9hu4,62
-pymodbus-2.2.0.dist-info/top_level.txt,sha256=ARvf0RMVfKAZAmUTplKDYJQmokQ0DDg90T-B5xVugP4,18
-pymodbus-2.2.0.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
-pymodbus-2.2.0.dist-info/RECORD,,
-../../../bin/pymodbus.console,sha256=vB5iNacM5c0igyRIyEXclmQhRMLhDRcVFUt8ZS6F7WY,261
-pymodbus-2.2.0.dist-info/INSTALLER,sha256=zuuue4knoyJ-UwPPXg8fezS7VCrXJQrAP7zeNuwvFQg,4
-pymodbus/repl/__pycache__/client.cpython-37.pyc,,
-pymodbus/repl/__pycache__/helper.cpython-37.pyc,,
-pymodbus/repl/__pycache__/main.cpython-37.pyc,,
-pymodbus/repl/__pycache__/completer.cpython-37.pyc,,
-pymodbus/repl/__pycache__/__init__.cpython-37.pyc,,
-pymodbus/internal/__pycache__/ptwisted.cpython-37.pyc,,
-pymodbus/internal/__pycache__/__init__.cpython-37.pyc,,
-pymodbus/server/__pycache__/asynchronous.cpython-37.pyc,,
-pymodbus/server/__pycache__/sync.cpython-37.pyc,,
-pymodbus/server/__pycache__/__init__.cpython-37.pyc,,
-pymodbus/__pycache__/pdu.cpython-37.pyc,,
-pymodbus/__pycache__/payload.cpython-37.pyc,,
-pymodbus/__pycache__/other_message.cpython-37.pyc,,
-pymodbus/__pycache__/constants.cpython-37.pyc,,
-pymodbus/__pycache__/version.cpython-37.pyc,,
-pymodbus/__pycache__/interfaces.cpython-37.pyc,,
-pymodbus/__pycache__/device.cpython-37.pyc,,
-pymodbus/__pycache__/exceptions.cpython-37.pyc,,
-pymodbus/__pycache__/mei_message.cpython-37.pyc,,
-pymodbus/__pycache__/utilities.cpython-37.pyc,,
-pymodbus/__pycache__/bit_read_message.cpython-37.pyc,,
-pymodbus/__pycache__/factory.cpython-37.pyc,,
-pymodbus/__pycache__/compat.cpython-37.pyc,,
-pymodbus/__pycache__/diag_message.cpython-37.pyc,,
-pymodbus/__pycache__/register_write_message.cpython-37.pyc,,
-pymodbus/__pycache__/transaction.cpython-37.pyc,,
-pymodbus/__pycache__/register_read_message.cpython-37.pyc,,
-pymodbus/__pycache__/bit_write_message.cpython-37.pyc,,
-pymodbus/__pycache__/file_message.cpython-37.pyc,,
-pymodbus/__pycache__/events.cpython-37.pyc,,
-pymodbus/__pycache__/__init__.cpython-37.pyc,,
-pymodbus/framer/__pycache__/rtu_framer.cpython-37.pyc,,
-pymodbus/framer/__pycache__/ascii_framer.cpython-37.pyc,,
-pymodbus/framer/__pycache__/socket_framer.cpython-37.pyc,,
-pymodbus/framer/__pycache__/binary_framer.cpython-37.pyc,,
-pymodbus/framer/__pycache__/__init__.cpython-37.pyc,,
-pymodbus/datastore/database/__pycache__/sql_datastore.cpython-37.pyc,,
-pymodbus/datastore/database/__pycache__/redis_datastore.cpython-37.pyc,,
-pymodbus/datastore/database/__pycache__/__init__.cpython-37.pyc,,
-pymodbus/datastore/__pycache__/remote.cpython-37.pyc,,
-pymodbus/datastore/__pycache__/store.cpython-37.pyc,,
-pymodbus/datastore/__pycache__/context.cpython-37.pyc,,
-pymodbus/datastore/__pycache__/__init__.cpython-37.pyc,,
-pymodbus/client/asynchronous/twisted/__pycache__/__init__.cpython-37.pyc,,
-pymodbus/client/asynchronous/__pycache__/thread.cpython-37.pyc,,
-pymodbus/client/asynchronous/__pycache__/udp.cpython-37.pyc,,
-pymodbus/client/asynchronous/__pycache__/tcp.cpython-37.pyc,,
-pymodbus/client/asynchronous/__pycache__/mixins.cpython-37.pyc,,
-pymodbus/client/asynchronous/__pycache__/serial.cpython-37.pyc,,
-pymodbus/client/asynchronous/__pycache__/__init__.cpython-37.pyc,,
-pymodbus/client/asynchronous/tornado/__pycache__/__init__.cpython-37.pyc,,
-pymodbus/client/asynchronous/asyncio/__pycache__/__init__.cpython-37.pyc,,
-pymodbus/client/asynchronous/factory/__pycache__/udp.cpython-37.pyc,,
-pymodbus/client/asynchronous/factory/__pycache__/tcp.cpython-37.pyc,,
-pymodbus/client/asynchronous/factory/__pycache__/serial.cpython-37.pyc,,
-pymodbus/client/asynchronous/factory/__pycache__/__init__.cpython-37.pyc,,
-pymodbus/client/asynchronous/schedulers/__pycache__/__init__.cpython-37.pyc,,
-pymodbus/client/asynchronous/deprecated/__pycache__/asynchronous.cpython-37.pyc,,
-pymodbus/client/asynchronous/deprecated/__pycache__/__init__.cpython-37.pyc,,
-pymodbus/client/__pycache__/common.cpython-37.pyc,,
-pymodbus/client/__pycache__/sync.cpython-37.pyc,,
-pymodbus/client/__pycache__/__init__.cpython-37.pyc,,
-__pycache__/ez_setup.cpython-37.pyc,,
diff --git a/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/WHEEL b/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/WHEEL
deleted file mode 100644
index c8240f0..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/WHEEL
+++ /dev/null
@@ -1,6 +0,0 @@
-Wheel-Version: 1.0
-Generator: bdist_wheel (0.33.1)
-Root-Is-Purelib: true
-Tag: py2-none-any
-Tag: py3-none-any
-
diff --git a/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/entry_points.txt b/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/entry_points.txt
deleted file mode 100644
index d9db888..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/entry_points.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-[console_scripts]
-pymodbus.console = pymodbus.repl.main:main
-
diff --git a/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/top_level.txt b/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/top_level.txt
deleted file mode 100644
index 8112ea7..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/top_level.txt
+++ /dev/null
@@ -1,2 +0,0 @@
-ez_setup
-pymodbus
diff --git a/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/zip-safe b/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/zip-safe
deleted file mode 100644
index 8b13789..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus-2.2.0.dist-info/zip-safe
+++ /dev/null
@@ -1 +0,0 @@
-
diff --git a/venv/lib/python3.7/site-packages/pymodbus/__init__.py b/venv/lib/python3.7/site-packages/pymodbus/__init__.py
deleted file mode 100644
index 8319957..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/__init__.py
+++ /dev/null
@@ -1,31 +0,0 @@
-'''
-Pymodbus: Modbus Protocol Implementation
------------------------------------------
-
-TwistedModbus is built on top of the code developed by:
-
-    Copyright (c) 2001-2005 S.W.A.C. GmbH, Germany.
-    Copyright (c) 2001-2005 S.W.A.C. Bohemia s.r.o., Czech Republic.
-    Hynek Petrak <hynek@swac.cz>
-
-Released under the the BSD license
-'''
-
-import pymodbus.version as __version
-__version__ = __version.version.short()
-__author__  = 'Galen Collins'
-__maintainer__ = 'dhoomakethu'
-
-#---------------------------------------------------------------------------#
-# Block unhandled logging
-#---------------------------------------------------------------------------#
-import logging as __logging
-try:
-    from logging import NullHandler as __null
-except ImportError:
-    class __null(__logging.Handler):
-        def emit(self, record):
-            pass
-
-__logging.getLogger(__name__).addHandler(__null())
-
diff --git a/venv/lib/python3.7/site-packages/pymodbus/bit_read_message.py b/venv/lib/python3.7/site-packages/pymodbus/bit_read_message.py
deleted file mode 100644
index d8624fa..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/bit_read_message.py
+++ /dev/null
@@ -1,247 +0,0 @@
-"""
-Bit Reading Request/Response messages
---------------------------------------
-
-"""
-import struct
-from pymodbus.pdu import ModbusRequest
-from pymodbus.pdu import ModbusResponse
-from pymodbus.pdu import ModbusExceptions as merror
-from pymodbus.utilities import pack_bitstring, unpack_bitstring
-from pymodbus.compat import byte2int
-
-
-class ReadBitsRequestBase(ModbusRequest):
-    ''' Base class for Messages Requesting bit values '''
-
-    _rtu_frame_size = 8
-
-    def __init__(self, address, count, **kwargs):
-        ''' Initializes the read request data
-
-        :param address: The start address to read from
-        :param count: The number of bits after 'address' to read
-        '''
-        ModbusRequest.__init__(self, **kwargs)
-        self.address = address
-        self.count = count
-
-    def encode(self):
-        ''' Encodes a request pdu
-
-        :returns: The encoded pdu
-        '''
-        return struct.pack('>HH', self.address, self.count)
-
-    def decode(self, data):
-        ''' Decodes a request pdu
-
-        :param data: The packet data to decode
-        '''
-        self.address, self.count = struct.unpack('>HH', data)
-    
-    def get_response_pdu_size(self):
-        """
-        Func_code (1 byte) + Byte Count(1 byte) + Quantity of Coils (n Bytes)/8,
-        if the remainder is different of 0 then N = N+1
-        :return: 
-        """
-        count = self.count//8
-        if self.count % 8:
-            count += 1
-
-        return 1 + 1 + count
-    
-    def __str__(self):
-        ''' Returns a string representation of the instance
-
-        :returns: A string representation of the instance
-        '''
-        return "ReadBitRequest(%d,%d)" % (self.address, self.count)
-
-
-class ReadBitsResponseBase(ModbusResponse):
-    ''' Base class for Messages responding to bit-reading values '''
-
-    _rtu_byte_count_pos = 2
-
-    def __init__(self, values, **kwargs):
-        ''' Initializes a new instance
-
-        :param values: The requested values to be returned
-        '''
-        ModbusResponse.__init__(self, **kwargs)
-        self.bits = values or []
-
-    def encode(self):
-        ''' Encodes response pdu
-
-        :returns: The encoded packet message
-        '''
-        result = pack_bitstring(self.bits)
-        packet = struct.pack(">B", len(result)) + result
-        return packet
-
-    def decode(self, data):
-        ''' Decodes response pdu
-
-        :param data: The packet data to decode
-        '''
-        self.byte_count = byte2int(data[0])
-        self.bits = unpack_bitstring(data[1:])
-
-    def setBit(self, address, value=1):
-        ''' Helper function to set the specified bit
-
-        :param address: The bit to set
-        :param value: The value to set the bit to
-        '''
-        self.bits[address] = (value != 0)
-
-    def resetBit(self, address):
-        ''' Helper function to set the specified bit to 0
-
-        :param address: The bit to reset
-        '''
-        self.setBit(address, 0)
-
-    def getBit(self, address):
-        ''' Helper function to get the specified bit's value
-
-        :param address: The bit to query
-        :returns: The value of the requested bit
-        '''
-        return self.bits[address]
-
-    def __str__(self):
-        ''' Returns a string representation of the instance
-
-        :returns: A string representation of the instance
-        '''
-        return "ReadBitResponse(%d)" % len(self.bits)
-
-
-class ReadCoilsRequest(ReadBitsRequestBase):
-    '''
-    This function code is used to read from 1 to 2000(0x7d0) contiguous status
-    of coils in a remote device. The Request PDU specifies the starting
-    address, ie the address of the first coil specified, and the number of
-    coils. In the PDU Coils are addressed starting at zero. Therefore coils
-    numbered 1-16 are addressed as 0-15.
-    '''
-    function_code = 1
-
-    def __init__(self, address=None, count=None, **kwargs):
-        ''' Initializes a new instance
-
-        :param address: The address to start reading from
-        :param count: The number of bits to read
-        '''
-        ReadBitsRequestBase.__init__(self, address, count, **kwargs)
-
-    def execute(self, context):
-        ''' Run a read coils request against a datastore
-
-        Before running the request, we make sure that the request is in
-        the max valid range (0x001-0x7d0). Next we make sure that the
-        request is valid against the current datastore.
-
-        :param context: The datastore to request from
-        :returns: The initializes response message, exception message otherwise
-        '''
-        if not (1 <= self.count <= 0x7d0):
-            return self.doException(merror.IllegalValue)
-        if not context.validate(self.function_code, self.address, self.count):
-            return self.doException(merror.IllegalAddress)
-        values = context.getValues(self.function_code, self.address, self.count)
-        return ReadCoilsResponse(values)
-
-
-class ReadCoilsResponse(ReadBitsResponseBase):
-    '''
-    The coils in the response message are packed as one coil per bit of
-    the data field. Status is indicated as 1= ON and 0= OFF. The LSB of the
-    first data byte contains the output addressed in the query. The other
-    coils follow toward the high order end of this byte, and from low order
-    to high order in subsequent bytes.
-
-    If the returned output quantity is not a multiple of eight, the
-    remaining bits in the final data byte will be padded with zeros
-    (toward the high order end of the byte). The Byte Count field specifies
-    the quantity of complete bytes of data.
-    '''
-    function_code = 1
-
-    def __init__(self, values=None, **kwargs):
-        ''' Intializes a new instance
-
-        :param values: The request values to respond with
-        '''
-        ReadBitsResponseBase.__init__(self, values, **kwargs)
-
-
-class ReadDiscreteInputsRequest(ReadBitsRequestBase):
-    '''
-    This function code is used to read from 1 to 2000(0x7d0) contiguous status
-    of discrete inputs in a remote device. The Request PDU specifies the
-    starting address, ie the address of the first input specified, and the
-    number of inputs. In the PDU Discrete Inputs are addressed starting at
-    zero. Therefore Discrete inputs numbered 1-16 are addressed as 0-15.
-    '''
-    function_code = 2
-
-    def __init__(self, address=None, count=None, **kwargs):
-        ''' Intializes a new instance
-
-        :param address: The address to start reading from
-        :param count: The number of bits to read
-        '''
-        ReadBitsRequestBase.__init__(self, address, count, **kwargs)
-
-    def execute(self, context):
-        ''' Run a read discrete input request against a datastore
-
-        Before running the request, we make sure that the request is in
-        the max valid range (0x001-0x7d0). Next we make sure that the
-        request is valid against the current datastore.
-
-        :param context: The datastore to request from
-        :returns: The initializes response message, exception message otherwise
-        '''
-        if not (1 <= self.count <= 0x7d0):
-            return self.doException(merror.IllegalValue)
-        if not context.validate(self.function_code, self.address, self.count):
-            return self.doException(merror.IllegalAddress)
-        values = context.getValues(self.function_code, self.address, self.count)
-        return ReadDiscreteInputsResponse(values)
-
-
-class ReadDiscreteInputsResponse(ReadBitsResponseBase):
-    '''
-    The discrete inputs in the response message are packed as one input per
-    bit of the data field. Status is indicated as 1= ON; 0= OFF. The LSB of
-    the first data byte contains the input addressed in the query. The other
-    inputs follow toward the high order end of this byte, and from low order
-    to high order in subsequent bytes.
-
-    If the returned input quantity is not a multiple of eight, the
-    remaining bits in the final data byte will be padded with zeros
-    (toward the high order end of the byte). The Byte Count field specifies
-    the quantity of complete bytes of data.
-    '''
-    function_code = 2
-
-    def __init__(self, values=None, **kwargs):
-        ''' Intializes a new instance
-
-        :param values: The request values to respond with
-        '''
-        ReadBitsResponseBase.__init__(self, values, **kwargs)
-
-#---------------------------------------------------------------------------#
-# Exported symbols
-#---------------------------------------------------------------------------#
-__all__ = [
-    "ReadCoilsRequest", "ReadCoilsResponse",
-    "ReadDiscreteInputsRequest", "ReadDiscreteInputsResponse",
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/bit_write_message.py b/venv/lib/python3.7/site-packages/pymodbus/bit_write_message.py
deleted file mode 100644
index 2dfb618..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/bit_write_message.py
+++ /dev/null
@@ -1,270 +0,0 @@
-"""
-Bit Writing Request/Response
-------------------------------
-
-TODO write mask request/response
-"""
-import struct
-from pymodbus.constants import ModbusStatus
-from pymodbus.pdu import ModbusRequest
-from pymodbus.pdu import ModbusResponse
-from pymodbus.pdu import ModbusExceptions as merror
-from pymodbus.utilities import pack_bitstring, unpack_bitstring
-
-#---------------------------------------------------------------------------#
-# Local Constants
-#---------------------------------------------------------------------------#
-# These are defined in the spec to turn a coil on/off
-#---------------------------------------------------------------------------#
-_turn_coil_on  = struct.pack(">H", ModbusStatus.On)
-_turn_coil_off = struct.pack(">H", ModbusStatus.Off)
-
-
-class WriteSingleCoilRequest(ModbusRequest):
-    '''
-    This function code is used to write a single output to either ON or OFF
-    in a remote device.
-
-    The requested ON/OFF state is specified by a constant in the request
-    data field. A value of FF 00 hex requests the output to be ON. A value
-    of 00 00 requests it to be OFF. All other values are illegal and will
-    not affect the output.
-
-    The Request PDU specifies the address of the coil to be forced. Coils
-    are addressed starting at zero. Therefore coil numbered 1 is addressed
-    as 0. The requested ON/OFF state is specified by a constant in the Coil
-    Value field. A value of 0XFF00 requests the coil to be ON. A value of
-    0X0000 requests the coil to be off. All other values are illegal and
-    will not affect the coil.
-    '''
-    function_code = 5
-    _rtu_frame_size = 8
-
-    def __init__(self, address=None, value=None, **kwargs):
-        ''' Initializes a new instance
-
-        :param address: The variable address to write
-        :param value: The value to write at address
-        '''
-        ModbusRequest.__init__(self, **kwargs)
-        self.address = address
-        self.value = bool(value)
-
-    def encode(self):
-        ''' Encodes write coil request
-
-        :returns: The byte encoded message
-        '''
-        result  = struct.pack('>H', self.address)
-        if self.value: result += _turn_coil_on
-        else: result += _turn_coil_off
-        return result
-
-    def decode(self, data):
-        ''' Decodes a write coil request
-
-        :param data: The packet data to decode
-        '''
-        self.address, value = struct.unpack('>HH', data)
-        self.value = (value == ModbusStatus.On)
-
-    def execute(self, context):
-        ''' Run a write coil request against a datastore
-
-        :param context: The datastore to request from
-        :returns: The populated response or exception message
-        '''
-        #if self.value not in [ModbusStatus.Off, ModbusStatus.On]:
-        #    return self.doException(merror.IllegalValue)
-        if not context.validate(self.function_code, self.address, 1):
-            return self.doException(merror.IllegalAddress)
-
-        context.setValues(self.function_code, self.address, [self.value])
-        values = context.getValues(self.function_code, self.address, 1)
-        return WriteSingleCoilResponse(self.address, values[0])
-
-    def get_response_pdu_size(self):
-        """
-        Func_code (1 byte) + Output Address (2 byte) + Output Value  (2 Bytes)
-        :return: 
-        """
-        return 1 + 2 + 2
-
-    def __str__(self):
-        ''' Returns a string representation of the instance
-
-        :return: A string representation of the instance
-        '''
-        return "WriteCoilRequest(%d, %s) => " % (self.address, self.value)
-
-
-class WriteSingleCoilResponse(ModbusResponse):
-    '''
-    The normal response is an echo of the request, returned after the coil
-    state has been written.
-    '''
-    function_code = 5
-    _rtu_frame_size = 8
-
-    def __init__(self, address=None, value=None, **kwargs):
-        ''' Initializes a new instance
-
-        :param address: The variable address written to
-        :param value: The value written at address
-        '''
-        ModbusResponse.__init__(self, **kwargs)
-        self.address = address
-        self.value = value
-
-    def encode(self):
-        ''' Encodes write coil response
-
-        :return: The byte encoded message
-        '''
-        result  = struct.pack('>H', self.address)
-        if self.value: result += _turn_coil_on
-        else: result += _turn_coil_off
-        return result
-
-    def decode(self, data):
-        ''' Decodes a write coil response
-
-        :param data: The packet data to decode
-        '''
-        self.address, value = struct.unpack('>HH', data)
-        self.value = (value == ModbusStatus.On)
-
-    def __str__(self):
-        ''' Returns a string representation of the instance
-
-        :returns: A string representation of the instance
-        '''
-        return "WriteCoilResponse(%d) => %d" % (self.address, self.value)
-
-
-class WriteMultipleCoilsRequest(ModbusRequest):
-    '''
-    "This function code is used to force each coil in a sequence of coils to
-    either ON or OFF in a remote device. The Request PDU specifies the coil
-    references to be forced. Coils are addressed starting at zero. Therefore
-    coil numbered 1 is addressed as 0.
-
-    The requested ON/OFF states are specified by contents of the request
-    data field. A logical '1' in a bit position of the field requests the
-    corresponding output to be ON. A logical '0' requests it to be OFF."
-    '''
-    function_code = 15
-    _rtu_byte_count_pos = 6
-    
-    def __init__(self, address=None, values=None, **kwargs):
-        ''' Initializes a new instance
-
-        :param address: The starting request address
-        :param values: The values to write
-        '''
-        ModbusRequest.__init__(self, **kwargs)
-        self.address = address
-        if not values: values = []
-        elif not hasattr(values, '__iter__'): values = [values]
-        self.values  = values
-        self.byte_count = (len(self.values) + 7) // 8
-
-    def encode(self):
-        ''' Encodes write coils request
-
-        :returns: The byte encoded message
-        '''
-        count   = len(self.values)
-        self.byte_count = (count + 7) // 8
-        packet  = struct.pack('>HHB', self.address, count, self.byte_count)
-        packet += pack_bitstring(self.values)
-        return packet
-
-    def decode(self, data):
-        ''' Decodes a write coils request
-
-        :param data: The packet data to decode
-        '''
-        self.address, count, self.byte_count = struct.unpack('>HHB', data[0:5])
-        values = unpack_bitstring(data[5:])
-        self.values = values[:count]
-
-    def execute(self, context):
-        ''' Run a write coils request against a datastore
-
-        :param context: The datastore to request from
-        :returns: The populated response or exception message
-        '''
-        count = len(self.values)
-        if not (1 <= count <= 0x07b0):
-            return self.doException(merror.IllegalValue)
-        if (self.byte_count != (count + 7) // 8):
-            return self.doException(merror.IllegalValue)
-        if not context.validate(self.function_code, self.address, count):
-            return self.doException(merror.IllegalAddress)
-
-        context.setValues(self.function_code, self.address, self.values)
-        return WriteMultipleCoilsResponse(self.address, count)
-
-    def __str__(self):
-        ''' Returns a string representation of the instance
-
-        :returns: A string representation of the instance
-        '''
-        params = (self.address, len(self.values))
-        return "WriteNCoilRequest (%d) => %d " % params
-
-    def get_response_pdu_size(self):
-        """
-        Func_code (1 byte) + Output Address (2 byte) + Quantity of Outputs  (2 Bytes)
-        :return:
-        """
-        return 1 + 2 + 2
-
-
-class WriteMultipleCoilsResponse(ModbusResponse):
-    '''
-    The normal response returns the function code, starting address, and
-    quantity of coils forced.
-    '''
-    function_code = 15
-    _rtu_frame_size = 8
-
-    def __init__(self, address=None, count=None, **kwargs):
-        ''' Initializes a new instance
-
-        :param address: The starting variable address written to
-        :param count: The number of values written
-        '''
-        ModbusResponse.__init__(self, **kwargs)
-        self.address = address
-        self.count = count
-
-    def encode(self):
-        ''' Encodes write coils response
-
-        :returns: The byte encoded message
-        '''
-        return struct.pack('>HH', self.address, self.count)
-
-    def decode(self, data):
-        ''' Decodes a write coils response
-
-        :param data: The packet data to decode
-        '''
-        self.address, self.count = struct.unpack('>HH', data)
-
-    def __str__(self):
-        ''' Returns a string representation of the instance
-
-        :returns: A string representation of the instance
-        '''
-        return "WriteNCoilResponse(%d, %d)" % (self.address, self.count)
-
-#---------------------------------------------------------------------------#
-# Exported symbols
-#---------------------------------------------------------------------------#
-__all__ = [
-    "WriteSingleCoilRequest", "WriteSingleCoilResponse",
-    "WriteMultipleCoilsRequest", "WriteMultipleCoilsResponse",
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/__init__.py b/venv/lib/python3.7/site-packages/pymodbus/client/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/__init__.py b/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/__init__.py
deleted file mode 100644
index c339353..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/__init__.py
+++ /dev/null
@@ -1,44 +0,0 @@
-"""
-Async Modbus Client implementation based on Twisted, tornado and asyncio
-------------------------------------------------------------------------
-
-Example run::
-
-    from pymodbus.client.asynchronous import schedulers
-
-    # Import The clients
-
-    from pymodbus.client.asynchronous.tcp import AsyncModbusTCPClient as Client
-    from pymodbus.client.asynchronous.serial import AsyncModbusSerialClient as Client
-    from pymodbus.client.asynchronous.udp import AsyncModbusUDPClient as Client
-
-    # For tornado based asynchronous client use
-    event_loop, future = Client(schedulers.IO_LOOP, port=5020)
-
-    # For twisted based asynchronous client use
-    event_loop, future = Client(schedulers.REACTOR, port=5020)
-
-    # For asyncio based asynchronous client use
-    event_loop, client = Client(schedulers.ASYNC_IO, port=5020)
-
-    # Here event_loop is a thread which would control the backend and future is
-    # a Future/deffered object which would be used to
-    # add call backs to run asynchronously.
-
-    # The Actual client could be accessed with future.result() with Tornado
-    # and future.result when using twisted
-
-    # For asyncio the actual client is returned and event loop is asyncio loop
-
-"""
-from pymodbus.compat import is_installed
-
-installed = is_installed('twisted')
-if installed:
-    # Import deprecated async client only if twisted is installed #338
-    from pymodbus.client.asynchronous.deprecated.asynchronous import *
-else:
-    import logging
-    logger = logging.getLogger(__name__)
-    logger.warning("Not Importing deprecated clients. "
-                   "Dependency Twisted is not Installed")
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/asyncio/__init__.py b/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/asyncio/__init__.py
deleted file mode 100644
index baa9f71..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/asyncio/__init__.py
+++ /dev/null
@@ -1,785 +0,0 @@
-"""
-Asynchronous framework adapter for asyncio.
-"""
-import socket
-import asyncio
-import functools
-from pymodbus.exceptions import ConnectionException
-from pymodbus.client.asynchronous.mixins import AsyncModbusClientMixin
-from pymodbus.compat import byte2int
-import logging
-
-_logger = logging.getLogger(__name__)
-
-DGRAM_TYPE = socket.SocketKind.SOCK_DGRAM
-
-
-class BaseModbusAsyncClientProtocol(AsyncModbusClientMixin):
-    """
-    Asyncio specific implementation of asynchronous modbus client protocol.
-    """
-
-    #: Factory that created this instance.
-    factory = None
-    transport = None
-
-    def connection_made(self, transport):
-        """
-        Called when a connection is made.
-
-        The transport argument is the transport representing the connection.
-        :param transport:
-        :return:
-        """
-        self.transport = transport
-        self._connectionMade()
-
-        if self.factory:
-            self.factory.protocol_made_connection(self)
-
-    def connection_lost(self, reason):
-        """
-        Called when the connection is lost or closed.
-
-        The argument is either an exception object or None
-        :param reason:
-        :return:
-        """
-        self.transport = None
-        self._connectionLost(reason)
-
-        if self.factory:
-            self.factory.protocol_lost_connection(self)
-
-    def data_received(self, data):
-        """
-        Called when some data is received.
-        data is a non-empty bytes object containing the incoming data.
-        :param data:
-        :return:
-        """
-        self._dataReceived(data)
-
-    def create_future(self):
-        """
-        Helper function to create asyncio Future object
-        :return:
-        """
-        return asyncio.Future()
-
-    def resolve_future(self, f, result):
-        """
-        Resolves the completed future and sets the result
-        :param f:
-        :param result:
-        :return:
-        """
-        if not f.done():
-            f.set_result(result)
-
-    def raise_future(self, f, exc):
-        """
-        Sets exception of a future if not done
-        :param f:
-        :param exc:
-        :return:
-        """
-        if not f.done():
-            f.set_exception(exc)
-
-    def _connectionMade(self):
-        """
-        Called upon a successful client connection.
-        """
-        _logger.debug("Client connected to modbus server")
-        self._connected = True
-
-    def _connectionLost(self, reason):
-        """
-        Called upon a client disconnect
-
-        :param reason: The reason for the disconnect
-        """
-        _logger.debug(
-            "Client disconnected from modbus server: %s" % reason)
-        self._connected = False
-        for tid in list(self.transaction):
-            self.raise_future(self.transaction.getTransaction(tid),
-                              ConnectionException(
-                                  'Connection lost during request'))
-
-    @property
-    def connected(self):
-        """
-        Return connection status.
-        """
-        return self._connected
-
-    def execute(self, request, **kwargs):
-        """
-        Starts the producer to send the next request to
-        consumer.write(Frame(request))
-        """
-        request.transaction_id = self.transaction.getNextTID()
-        packet = self.framer.buildPacket(request)
-        _logger.debug("send: " + " ".join([hex(byte2int(x)) for x in packet]))
-        self.transport.write(packet)
-        return self._buildResponse(request.transaction_id)
-
-    def _dataReceived(self, data):
-        ''' Get response, check for valid message, decode result
-
-        :param data: The data returned from the server
-        '''
-        _logger.debug("recv: " + " ".join([hex(byte2int(x)) for x in data]))
-        unit = self.framer.decode_data(data).get("uid", 0)
-        self.framer.processIncomingPacket(data, self._handleResponse, unit=unit)
-
-    def _handleResponse(self, reply, **kwargs):
-        """
-        Handle the processed response and link to correct deferred
-
-        :param reply: The reply to process
-        """
-        if reply is not None:
-            tid = reply.transaction_id
-            handler = self.transaction.getTransaction(tid)
-            if handler:
-                self.resolve_future(handler, reply)
-            else:
-                _logger.debug("Unrequested message: " + str(reply))
-
-    def _buildResponse(self, tid):
-        """
-        Helper method to return a deferred response
-        for the current request.
-
-        :param tid: The transaction identifier for this response
-        :returns: A defer linked to the latest request
-        """
-        f = self.create_future()
-        if not self._connected:
-            self.raise_future(f, ConnectionException(
-                'Client is not connected'))
-        else:
-            self.transaction.addTransaction(f, tid)
-        return f
-
-    def close(self):
-        self.transport.close()
-        self._connected = False
-
-
-class ModbusClientProtocol(BaseModbusAsyncClientProtocol, asyncio.Protocol):
-    """
-    Asyncio specific implementation of asynchronous modbus client protocol.
-    """
-
-    #: Factory that created this instance.
-    factory = None
-    transport = None
-
-    def data_received(self, data):
-        """
-        Called when some data is received.
-        data is a non-empty bytes object containing the incoming data.
-        :param data:
-        :return:
-        """
-        self._dataReceived(data)
-
-
-class ModbusUdpClientProtocol(BaseModbusAsyncClientProtocol,
-                              asyncio.DatagramProtocol):
-    """
-    Asyncio specific implementation of asynchronous modbus udp client protocol.
-    """
-
-    #: Factory that created this instance.
-    factory = None
-
-    def __init__(self, host=None, port=0, **kwargs):
-        self.host = host
-        self.port = port
-        super(self.__class__, self).__init__(**kwargs)
-
-    def datagram_received(self, data, addr):
-        self._dataReceived(data)
-
-
-class ReconnectingAsyncioModbusTcpClient(object):
-    """
-    Client to connect to modbus device repeatedly over TCP/IP."
-    """
-    #: Minimum delay in milli seconds before reconnect is attempted.
-    DELAY_MIN_MS = 100
-    #: Maximum delay in milli seconds before reconnect is attempted.
-    DELAY_MAX_MS = 1000 * 60 * 5
-
-    def __init__(self, protocol_class=None, loop=None):
-        """
-        Initialize ReconnectingAsyncioModbusTcpClient
-        :param protocol_class: Protocol used to talk to modbus device.
-        :param loop: Event loop to use
-        """
-        #: Protocol used to talk to modbus device.
-        self.protocol_class = protocol_class or ModbusClientProtocol
-        #: Current protocol instance.
-        self.protocol = None
-        #: Event loop to use.
-        self.loop = loop or asyncio.get_event_loop()
-        self.host = None
-        self.port = 0
-        self.connected = False
-        #: Reconnect delay in milli seconds.
-        self.delay_ms = self.DELAY_MIN_MS
-
-    def reset_delay(self):
-        """
-        Resets wait before next reconnect to minimal period.
-        """
-        self.delay_ms = self.DELAY_MIN_MS
-
-    @asyncio.coroutine
-    def start(self, host, port=502):
-        """
-        Initiates connection to start client
-        :param host:
-        :param port:
-        :return:
-        """
-        # force reconnect if required:
-        self.stop()
-
-        _logger.debug('Connecting to %s:%s.' % (host, port))
-        self.host = host
-        self.port = port
-        yield from self._connect()
-
-    def stop(self):
-        """
-        Stops client
-        :return:
-        """
-        # prevent reconnect:
-        self.host = None
-
-        if self.connected:
-            if self.protocol:
-                if self.protocol.transport:
-                    self.protocol.transport.close()
-
-    def _create_protocol(self):
-        """
-        Factory function to create initialized protocol instance.
-        """
-        protocol = self.protocol_class()
-        protocol.factory = self
-        return protocol
-
-    @asyncio.coroutine
-    def _connect(self):
-        _logger.debug('Connecting.')
-        try:
-            yield from self.loop.create_connection(self._create_protocol,
-                                                   self.host,
-                                                   self.port)
-        except Exception as ex:
-            _logger.warning('Failed to connect: %s' % ex)
-            asyncio.ensure_future(self._reconnect(), loop=self.loop)
-        else:
-            _logger.info('Connected to %s:%s.' % (self.host, self.port))
-            self.reset_delay()
-
-    def protocol_made_connection(self, protocol):
-        """
-        Protocol notification of successful connection.
-        """
-        _logger.info('Protocol made connection.')
-        if not self.connected:
-            self.connected = True
-            self.protocol = protocol
-        else:
-            _logger.error('Factory protocol connect '
-                          'callback called while connected.')
-
-    def protocol_lost_connection(self, protocol):
-        """
-        Protocol notification of lost connection.
-        """
-        if self.connected:
-            _logger.info('Protocol lost connection.')
-            if protocol is not self.protocol:
-                _logger.error('Factory protocol callback called '
-                              'from unexpected protocol instance.')
-
-            self.connected = False
-            self.protocol = None
-            if self.host:
-                asyncio.ensure_future(self._reconnect(), loop=self.loop)
-        else:
-            _logger.error('Factory protocol disconnect callback called while not connected.')
-
-    @asyncio.coroutine
-    def _reconnect(self):
-        _logger.debug('Waiting %d ms before next '
-                      'connection attempt.' % self.delay_ms)
-        yield from asyncio.sleep(self.delay_ms / 1000)
-        self.delay_ms = min(2 * self.delay_ms, self.DELAY_MAX_MS)
-        yield from self._connect()
-
-
-class AsyncioModbusTcpClient(object):
-    """Client to connect to modbus device over TCP/IP."""
-
-    def __init__(self, host=None, port=502, protocol_class=None, loop=None):
-        """
-        Initializes Asyncio Modbus Tcp Client
-        :param host: Host IP address
-        :param port: Port to connect
-        :param protocol_class: Protocol used to talk to modbus device.
-        :param loop: Asyncio Event loop
-        """
-        #: Protocol used to talk to modbus device.
-        self.protocol_class = protocol_class or ModbusClientProtocol
-        #: Current protocol instance.
-        self.protocol = None
-        #: Event loop to use.
-        self.loop = loop or asyncio.get_event_loop()
-
-        self.host = host
-        self.port = port
-
-        self.connected = False
-
-    def stop(self):
-        """
-        Stops the client
-        :return:
-        """
-        if self.connected:
-            if self.protocol:
-                if self.protocol.transport:
-                    self.protocol.transport.close()
-
-    def _create_protocol(self):
-        """
-        Factory function to create initialized protocol instance.
-        """
-        protocol = self.protocol_class()
-        protocol.factory = self
-        return protocol
-
-    @asyncio.coroutine
-    def connect(self):
-        """
-        Connect and start Async client
-        :return:
-        """
-        _logger.debug('Connecting.')
-        try:
-            yield from self.loop.create_connection(self._create_protocol,
-                                                   self.host,
-                                                   self.port)
-            _logger.info('Connected to %s:%s.' % (self.host, self.port))
-        except Exception as ex:
-            _logger.warning('Failed to connect: %s' % ex)
-            # asyncio.asynchronous(self._reconnect(), loop=self.loop)
-
-    def protocol_made_connection(self, protocol):
-        """
-        Protocol notification of successful connection.
-        """
-        _logger.info('Protocol made connection.')
-        if not self.connected:
-            self.connected = True
-            self.protocol = protocol
-        else:
-            _logger.error('Factory protocol connect '
-                          'callback called while connected.')
-
-    def protocol_lost_connection(self, protocol):
-        """
-        Protocol notification of lost connection.
-        """
-        if self.connected:
-            _logger.info('Protocol lost connection.')
-            if protocol is not self.protocol:
-                _logger.error('Factory protocol callback called'
-                              ' from unexpected protocol instance.')
-
-            self.connected = False
-            self.protocol = None
-            # if self.host:
-            #     asyncio.asynchronous(self._reconnect(), loop=self.loop)
-        else:
-            _logger.error('Factory protocol disconnect'
-                          ' callback called while not connected.')
-
-
-class ReconnectingAsyncioModbusUdpClient(object):
-    """
-    Client to connect to modbus device repeatedly over UDP.
-    """
-
-    #: Reconnect delay in milli seconds.
-    delay_ms = 0
-
-    #: Maximum delay in milli seconds before reconnect is attempted.
-    DELAY_MAX_MS = 1000 * 60 * 5
-
-    def __init__(self, protocol_class=None, loop=None):
-        """
-        Initializes ReconnectingAsyncioModbusUdpClient
-        :param protocol_class: Protocol used to talk to modbus device.
-        :param loop: Asyncio Event loop
-        """
-        #: Protocol used to talk to modbus device.
-        self.protocol_class = protocol_class or ModbusUdpClientProtocol
-        #: Current protocol instance.
-        self.protocol = None
-        #: Event loop to use.
-        self.loop = loop or asyncio.get_event_loop()
-
-        self.host = None
-        self.port = 0
-
-        self.connected = False
-        self.reset_delay()
-
-    def reset_delay(self):
-        """
-        Resets wait before next reconnect to minimal period.
-        """
-        self.delay_ms = 100
-
-    @asyncio.coroutine
-    def start(self, host, port=502):
-        """
-        Start reconnecting asynchronous udp client
-        :param host: Host IP to connect
-        :param port: Host port to connect
-        :return:
-        """
-        # force reconnect if required:
-        self.stop()
-
-        _logger.debug('Connecting to %s:%s.' % (host, port))
-
-        # getaddrinfo returns a list of tuples
-        # - [(family, type, proto, canonname, sockaddr),]
-        # We want sockaddr which is a (ip, port) tuple
-        # udp needs ip addresses, not hostnames
-        addrinfo = yield from self.loop.getaddrinfo(host,
-                                                    port,
-                                                    type=DGRAM_TYPE)
-        self.host, self.port = addrinfo[0][-1]
-
-        yield from self._connect()
-
-    def stop(self):
-        """
-        Stops connection and prevents reconnect
-        :return:
-        """
-        # prevent reconnect:
-        self.host = None
-
-        if self.connected:
-            if self.protocol:
-                if self.protocol.transport:
-                    self.protocol.transport.close()
-
-    def _create_protocol(self, host=None, port=0):
-        """
-        Factory function to create initialized protocol instance.
-        """
-        protocol = self.protocol_class()
-        protocol.host = host
-        protocol.port = port
-        protocol.factory = self
-        return protocol
-
-    @asyncio.coroutine
-    def _connect(self):
-        _logger.debug('Connecting.')
-        try:
-            yield from self.loop.create_datagram_endpoint(
-                functools.partial(self._create_protocol,
-                                  host=self.host,
-                                  port=self.port),
-                remote_addr=(self.host, self.port)
-            )
-            _logger.info('Connected to %s:%s.' % (self.host, self.port))
-        except Exception as ex:
-            _logger.warning('Failed to connect: %s' % ex)
-            asyncio.ensure_future(self._reconnect(), loop=self.loop)
-
-    def protocol_made_connection(self, protocol):
-        """
-        Protocol notification of successful connection.
-        """
-        _logger.info('Protocol made connection.')
-        if not self.connected:
-            self.connected = True
-            self.protocol = protocol
-        else:
-            _logger.error('Factory protocol connect callback '
-                          'called while connected.')
-
-    def protocol_lost_connection(self, protocol):
-        """
-        Protocol notification of lost connection.
-        """
-        if self.connected:
-            _logger.info('Protocol lost connection.')
-            if protocol is not self.protocol:
-                _logger.error('Factory protocol callback called '
-                              'from unexpected protocol instance.')
-
-            self.connected = False
-            self.protocol = None
-            if self.host:
-                asyncio.ensure_future(self._reconnect(), loop=self.loop)
-        else:
-            _logger.error('Factory protocol disconnect '
-                          'callback called while not connected.')
-
-    @asyncio.coroutine
-    def _reconnect(self):
-        _logger.debug('Waiting %d ms before next '
-                      'connection attempt.' % self.delay_ms)
-        yield from asyncio.sleep(self.delay_ms / 1000)
-        self.delay_ms = min(2 * self.delay_ms, self.DELAY_MAX_MS)
-        yield from self._connect()
-
-
-class AsyncioModbusUdpClient(object):
-    """
-    Client to connect to modbus device over UDP.
-    """
-
-    def __init__(self, host=None, port=502, protocol_class=None, loop=None):
-        """
-        Initializes Asyncio Modbus UDP Client
-        :param host: Host IP address
-        :param port: Port to connect
-        :param protocol_class: Protocol used to talk to modbus device.
-        :param loop: Asyncio Event loop
-        """
-        #: Protocol used to talk to modbus device.
-        self.protocol_class = protocol_class or ModbusUdpClientProtocol
-        #: Current protocol instance.
-        self.protocol = None
-        #: Event loop to use.
-        self.loop = loop or asyncio.get_event_loop()
-
-        self.host = host
-        self.port = port
-
-        self.connected = False
-
-    def stop(self):
-        """
-        Stops connection
-        :return:
-        """
-        # prevent reconnect:
-        # self.host = None
-
-        if self.connected:
-            if self.protocol:
-                if self.protocol.transport:
-                    self.protocol.transport.close()
-
-    def _create_protocol(self, host=None, port=0):
-        """
-        Factory function to create initialized protocol instance.
-        """
-        protocol = self.protocol_class()
-        protocol.host = host
-        protocol.port = port
-        protocol.factory = self
-        return protocol
-
-    @asyncio.coroutine
-    def connect(self):
-        _logger.debug('Connecting.')
-        try:
-            addrinfo = yield from self.loop.getaddrinfo(
-                self.host,
-                self.port,
-                type=DGRAM_TYPE)
-            _host, _port = addrinfo[0][-1]
-            yield from self.loop.create_datagram_endpoint(
-                functools.partial(self._create_protocol,
-                                  host=_host, port=_port),
-                remote_addr=(self.host, self.port)
-            )
-            _logger.info('Connected to %s:%s.' % (self.host, self.port))
-        except Exception as ex:
-            _logger.warning('Failed to connect: %s' % ex)
-            # asyncio.asynchronous(self._reconnect(), loop=self.loop)
-
-    def protocol_made_connection(self, protocol):
-        """
-        Protocol notification of successful connection.
-        """
-        _logger.info('Protocol made connection.')
-        if not self.connected:
-            self.connected = True
-            self.protocol = protocol
-        else:
-            _logger.error('Factory protocol connect '
-                          'callback called while connected.')
-
-    def protocol_lost_connection(self, protocol):
-        """
-        Protocol notification of lost connection.
-        """
-        if self.connected:
-            _logger.info('Protocol lost connection.')
-            if protocol is not self.protocol:
-                _logger.error('Factory protocol callback '
-                              'called from unexpected protocol instance.')
-
-            self.connected = False
-            self.protocol = None
-            # if self.host:
-            #    asyncio.asynchronous(self._reconnect(), loop=self.loop)
-        else:
-            _logger.error('Factory protocol disconnect '
-                          'callback called while not connected.')
-
-
-class AsyncioModbusSerialClient(object):
-    """
-    Client to connect to modbus device over serial.
-    """
-    transport = None
-    framer = None
-
-    def __init__(self, port, protocol_class=None, framer=None,  loop=None,
-                 baudrate=9600, bytesize=8, parity='N', stopbits=1):
-        """
-        Initializes Asyncio Modbus Serial Client
-        :param port: Port to connect
-        :param protocol_class: Protocol used to talk to modbus device.
-        :param framer: Framer to use
-        :param loop: Asyncio Event loop
-        """
-        #: Protocol used to talk to modbus device.
-        self.protocol_class = protocol_class or ModbusClientProtocol
-        #: Current protocol instance.
-        self.protocol = None
-        #: Event loop to use.
-        self.loop = loop or asyncio.get_event_loop()
-        self.port = port
-        self.baudrate = baudrate
-        self.bytesize = bytesize
-        self.parity = parity
-        self.stopbits = stopbits
-        self.framer = framer
-        self._connected_event = asyncio.Event()
-
-    def stop(self):
-        """
-        Stops connection
-        :return:
-        """
-        if self._connected:
-            if self.protocol:
-                if self.protocol.transport:
-                    self.protocol.transport.close()
-
-    def _create_protocol(self):
-        protocol = self.protocol_class(framer=self.framer)
-        protocol.factory = self
-        return protocol
-
-    @property
-    def _connected(self):
-        return self._connected_event.is_set()
-
-    @asyncio.coroutine
-    def connect(self):
-        """
-        Connect Async client
-        :return:
-        """
-        _logger.debug('Connecting.')
-        try:
-            from serial_asyncio import create_serial_connection
-
-            yield from create_serial_connection(
-                self.loop, self._create_protocol, self.port, baudrate=self.baudrate,
-                bytesize=self.bytesize, stopbits=self.stopbits
-            )
-            yield from self._connected_event.wait()
-            _logger.info('Connected to %s', self.port)
-        except Exception as ex:
-            _logger.warning('Failed to connect: %s', ex)
-
-    def protocol_made_connection(self, protocol):
-        """
-        Protocol notification of successful connection.
-        """
-        _logger.info('Protocol made connection.')
-        if not self._connected:
-            self._connected_event.set()
-            self.protocol = protocol
-        else:
-            _logger.error('Factory protocol connect '
-                          'callback called while connected.')
-
-    def protocol_lost_connection(self, protocol):
-        """
-        Protocol notification of lost connection.
-        """
-        if self._connected:
-            _logger.info('Protocol lost connection.')
-            if protocol is not self.protocol:
-                _logger.error('Factory protocol callback called'
-                              ' from unexpected protocol instance.')
-
-            self._connected_event.clear()
-            self.protocol = None
-            # if self.host:
-            #     asyncio.asynchronous(self._reconnect(), loop=self.loop)
-        else:
-            _logger.error('Factory protocol disconnect callback '
-                          'called while not connected.')
-
-
-@asyncio.coroutine
-def init_tcp_client(proto_cls, loop, host, port, **kwargs):
-    """
-    Helper function to initialize tcp client
-    :param proto_cls:
-    :param loop:
-    :param host:
-    :param port:
-    :param kwargs:
-    :return:
-    """
-    client = ReconnectingAsyncioModbusTcpClient(protocol_class=proto_cls,
-                                                loop=loop)
-    yield from client.start(host, port)
-    return client
-
-
-@asyncio.coroutine
-def init_udp_client(proto_cls, loop, host, port, **kwargs):
-    """
-    Helper function to initialize UDP client
-    :param proto_cls:
-    :param loop:
-    :param host:
-    :param port:
-    :param kwargs:
-    :return:
-    """
-    client = ReconnectingAsyncioModbusUdpClient(protocol_class=proto_cls,
-                                                loop=loop)
-    yield from client.start(host, port)
-    return client
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/deprecated/__init__.py b/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/deprecated/__init__.py
deleted file mode 100644
index d891071..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/deprecated/__init__.py
+++ /dev/null
@@ -1,47 +0,0 @@
-import warnings
-warnings.simplefilter('always', DeprecationWarning)
-
-WARNING = """
-Usage of '{}' is deprecated from 2.0.0 and will be removed in future releases.
-Use the new Async Modbus Client implementation based on Twisted, tornado 
-and asyncio
-------------------------------------------------------------------------
-
-Example run::
-
-    from pymodbus.client.asynchronous import schedulers
-
-    # Import The clients
-
-    from pymodbus.client.asynchronous.tcp import AsyncModbusTCPClient as Client
-    from pymodbus.client.asynchronous.serial import AsyncModbusSerialClient as Client
-    from pymodbus.client.asynchronous.udp import AsyncModbusUDPClient as Client
-
-    # For tornado based asynchronous client use
-    event_loop, future = Client(schedulers.IO_LOOP, port=5020)
-
-    # For twisted based asynchronous client use
-    event_loop, deferred = Client(schedulers.REACTOR, port=5020)
-
-    # For asyncio based asynchronous client use
-    event_loop, client = Client(schedulers.ASYNC_IO, port=5020)
-
-    # Here event_loop is a thread which would control the backend and future is
-    # a Future/deffered object which would be used to
-    # add call backs to run asynchronously.
-
-    # The Actual client could be accessed with future.result() with Tornado
-    # and future.result when using twisted
-
-    # For asyncio the actual client is returned and event loop is asyncio loop
-
-Refer:
-https://pymodbus.readthedocs.io/en/dev/source/example/async_twisted_client.html
-https://pymodbus.readthedocs.io/en/dev/source/example/async_tornado_client.html
-https://pymodbus.readthedocs.io/en/dev/source/example/async_asyncio_client.html
-
-"""
-
-
-def deprecated(name):  # pragma: no cover
-    warnings.warn(WARNING.format(name), DeprecationWarning)
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/deprecated/asynchronous.py b/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/deprecated/asynchronous.py
deleted file mode 100644
index bd948ae..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/deprecated/asynchronous.py
+++ /dev/null
@@ -1,231 +0,0 @@
-"""
-Implementation of a Modbus Client Using Twisted
---------------------------------------------------
-
-Example run::
-
-    from twisted.internet import reactor, protocol
-    from pymodbus.client.asynchronous import ModbusClientProtocol
-
-    def printResult(result):
-        print "Result: %d" % result.bits[0]
-
-    def process(client):
-        result = client.write_coil(1, True)
-        result.addCallback(printResult)
-        reactor.callLater(1, reactor.stop)
-
-    defer = protocol.ClientCreator(reactor, ModbusClientProtocol
-            ).connectTCP("localhost", 502)
-    defer.addCallback(process)
-
-Another example::
-
-    from twisted.internet import reactor
-    from pymodbus.client.asynchronous import ModbusClientFactory
-
-    def process():
-        factory = reactor.connectTCP("localhost", 502, ModbusClientFactory())
-        reactor.stop()
-
-    if __name__ == "__main__":
-       reactor.callLater(1, process)
-       reactor.run()
-"""
-import logging
-from pymodbus.factory import ClientDecoder
-from pymodbus.exceptions import ConnectionException
-from pymodbus.transaction import ModbusSocketFramer
-from pymodbus.transaction import FifoTransactionManager
-from pymodbus.transaction import DictTransactionManager
-from pymodbus.client.common import ModbusClientMixin
-from pymodbus.client.asynchronous.deprecated import deprecated
-from twisted.internet import defer, protocol
-from twisted.python.failure import Failure
-
-
-# --------------------------------------------------------------------------- #
-# Logging
-# --------------------------------------------------------------------------- #
-_logger = logging.getLogger(__name__)
-
-
-# --------------------------------------------------------------------------- #
-# Connected Client Protocols
-# --------------------------------------------------------------------------- #
-class ModbusClientProtocol(protocol.Protocol, ModbusClientMixin): # pragma: no cover
-    """
-    This represents the base modbus client protocol.  All the application
-    layer code is deferred to a higher level wrapper.
-    """
-
-    def __init__(self, framer=None, **kwargs):
-        """ Initializes the framer module
-
-        :param framer: The framer to use for the protocol
-        """
-        deprecated(self.__class__.__name__)
-        self._connected = False
-        self.framer = framer or ModbusSocketFramer(ClientDecoder())
-        if isinstance(self.framer, type):
-            # Framer class not instance
-            self.framer = self.framer(ClientDecoder(), client=None)
-        if isinstance(self.framer, ModbusSocketFramer):
-            self.transaction = DictTransactionManager(self, **kwargs)
-        else:
-            self.transaction = FifoTransactionManager(self, **kwargs)
-
-    def connectionMade(self):
-        """ Called upon a successful client connection.
-        """
-        _logger.debug("Client connected to modbus server")
-        self._connected = True
-
-    def connectionLost(self, reason):
-        """ Called upon a client disconnect
-
-        :param reason: The reason for the disconnect
-        """
-        _logger.debug("Client disconnected from modbus server: %s" % reason)
-        self._connected = False
-        for tid in list(self.transaction):
-            self.transaction.getTransaction(tid).errback(Failure(
-                ConnectionException('Connection lost during request')))
-
-    def dataReceived(self, data):
-        """ Get response, check for valid message, decode result
-
-        :param data: The data returned from the server
-        """
-        unit = self.framer.decode_data(data).get("uid", 0)
-        self.framer.processIncomingPacket(data, self._handleResponse, unit=unit)
-
-    def execute(self, request):
-        """ Starts the producer to send the next request to
-        consumer.write(Frame(request))
-        """
-        request.transaction_id = self.transaction.getNextTID()
-        packet = self.framer.buildPacket(request)
-        self.transport.write(packet)
-        return self._buildResponse(request.transaction_id)
-
-    def _handleResponse(self, reply):
-        """ Handle the processed response and link to correct deferred
-
-        :param reply: The reply to process
-        """
-        if reply is not None:
-            tid = reply.transaction_id
-            handler = self.transaction.getTransaction(tid)
-            if handler:
-                handler.callback(reply)
-            else:
-                _logger.debug("Unrequested message: " + str(reply))
-
-    def _buildResponse(self, tid):
-        """ Helper method to return a deferred response
-        for the current request.
-
-        :param tid: The transaction identifier for this response
-        :returns: A defer linked to the latest request
-        """
-        if not self._connected:
-            return defer.fail(Failure(
-                ConnectionException('Client is not connected')))
-
-        d = defer.Deferred()
-        self.transaction.addTransaction(d, tid)
-        return d
-
-    # ---------------------------------------------------------------------- #
-    # Extra Functions
-    # ---------------------------------------------------------------------- #
-    # if send_failed:
-    #       if self.retry > 0:
-    #               deferLater(clock, self.delay, send, message)
-    #               self.retry -= 1
-
-
-# --------------------------------------------------------------------------- #
-# Not Connected Client Protocol
-# --------------------------------------------------------------------------- #
-class ModbusUdpClientProtocol(protocol.DatagramProtocol, ModbusClientMixin): # pragma: no cover
-    """
-    This represents the base modbus client protocol.  All the application
-    layer code is deferred to a higher level wrapper.
-    """
-
-    def __init__(self, framer=None, **kwargs):
-        """ Initializes the framer module
-
-        :param framer: The framer to use for the protocol
-        """
-        deprecated(self.__class__.__name__)
-        self.framer = framer or ModbusSocketFramer(ClientDecoder())
-        if isinstance(self.framer, ModbusSocketFramer):
-            self.transaction = DictTransactionManager(self, **kwargs)
-        else: self.transaction = FifoTransactionManager(self, **kwargs)
-
-    def datagramReceived(self, data, params):
-        """ Get response, check for valid message, decode result
-
-        :param data: The data returned from the server
-        :param params: The host parameters sending the datagram
-        """
-        _logger.debug("Datagram from: %s:%d" % params)
-        unit = self.framer.decode_data(data).get("uid", 0)
-        self.framer.processIncomingPacket(data, self._handleResponse, unit=unit)
-
-    def execute(self, request):
-        """ Starts the producer to send the next request to
-        consumer.write(Frame(request))
-        """
-        request.transaction_id = self.transaction.getNextTID()
-        packet = self.framer.buildPacket(request)
-        self.transport.write(packet)
-        return self._buildResponse(request.transaction_id)
-
-    def _handleResponse(self, reply):
-        """ Handle the processed response and link to correct deferred
-
-        :param reply: The reply to process
-        """
-        if reply is not None:
-            tid = reply.transaction_id
-            handler = self.transaction.getTransaction(tid)
-            if handler:
-                handler.callback(reply)
-            else: _logger.debug("Unrequested message: " + str(reply))
-
-    def _buildResponse(self, tid):
-        """ Helper method to return a deferred response
-        for the current request.
-
-        :param tid: The transaction identifier for this response
-        :returns: A defer linked to the latest request
-        """
-        d = defer.Deferred()
-        self.transaction.addTransaction(d, tid)
-        return d
-
-
-# --------------------------------------------------------------------------- #
-# Client Factories
-# --------------------------------------------------------------------------- #
-class ModbusClientFactory(protocol.ReconnectingClientFactory): # pragma: no cover
-    """ Simple client protocol factory """
-
-    protocol = ModbusClientProtocol
-
-    def __init__(self):
-        deprecated(self.__class__.__name__)
-        protocol.ReconnectingClientFactory.__init__(self)
-
-# --------------------------------------------------------------------------- #
-# Exported symbols
-# --------------------------------------------------------------------------- #
-
-
-__all__ = [
-    "ModbusClientProtocol", "ModbusUdpClientProtocol", "ModbusClientFactory"
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/factory/__init__.py b/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/factory/__init__.py
deleted file mode 100644
index 5a456ce..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/factory/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-from __future__ import absolute_import, unicode_literals
\ No newline at end of file
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/factory/serial.py b/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/factory/serial.py
deleted file mode 100644
index 592de8e..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/factory/serial.py
+++ /dev/null
@@ -1,126 +0,0 @@
-"""
-Factory to create asynchronous serial clients based on twisted/tornado/asyncio
-"""
-from __future__ import unicode_literals
-from __future__ import absolute_import
-
-import logging
-
-from pymodbus.client.asynchronous import schedulers
-from pymodbus.client.asynchronous.thread import EventLoopThread
-
-LOGGER = logging.getLogger(__name__)
-
-
-def reactor_factory(port, framer, **kwargs):
-    """
-    Factory to create twisted serial asynchronous client
-    :param port: Serial port
-    :param framer: Modbus Framer
-    :param kwargs:
-    :return: event_loop_thread and twisted serial client
-    """
-    from twisted.internet import reactor
-    from twisted.internet.serialport import SerialPort
-    from twisted.internet.protocol import ClientFactory
-    from pymodbus.factory import ClientDecoder
-
-    class SerialClientFactory(ClientFactory):
-        def __init__(self, framer, proto_cls):
-            ''' Remember things necessary for building a protocols '''
-            self.proto_cls = proto_cls
-            self.framer = framer
-
-        def buildProtocol(self):
-            ''' Create a protocol and start the reading cycle '''
-            proto = self.proto_cls(self.framer)
-            proto.factory = self
-            return proto
-
-    class SerialModbusClient(SerialPort):
-
-        def __init__(self, framer, *args, **kwargs):
-            ''' Setup the client and start listening on the serial port
-
-            :param factory: The factory to build clients with
-            '''
-            self.decoder = ClientDecoder()
-            proto_cls = kwargs.pop("proto_cls", None)
-            proto = SerialClientFactory(framer, proto_cls).buildProtocol()
-            SerialPort.__init__(self, proto, *args, **kwargs)
-
-    proto = EventLoopThread("reactor", reactor.run, reactor.stop,
-                            installSignalHandlers=0)
-    ser_client = SerialModbusClient(framer, port, reactor, **kwargs)
-
-    return proto, ser_client
-
-
-def io_loop_factory(port=None, framer=None, **kwargs):
-    """
-    Factory to create Tornado based asynchronous serial clients
-    :param port:  Serial port
-    :param framer: Modbus Framer
-    :param kwargs:
-    :return: event_loop_thread and tornado future
-    """
-
-    from tornado.ioloop import IOLoop
-    from pymodbus.client.asynchronous.tornado import (AsyncModbusSerialClient as
-                                               Client)
-
-    ioloop = IOLoop()
-    protocol = EventLoopThread("ioloop", ioloop.start, ioloop.stop)
-    protocol.start()
-    client = Client(port=port, framer=framer, ioloop=ioloop, **kwargs)
-
-    future = client.connect()
-
-    return protocol, future
-
-
-def async_io_factory(port=None, framer=None, **kwargs):
-    """
-    Factory to create asyncio based asynchronous serial clients
-    :param port:  Serial port
-    :param framer: Modbus Framer
-    :param kwargs: Serial port options
-    :return: asyncio event loop and serial client
-    """
-    import asyncio
-    from pymodbus.client.asynchronous.asyncio import (ModbusClientProtocol,
-                                                      AsyncioModbusSerialClient)
-    loop = kwargs.pop("loop", None) or asyncio.get_event_loop()
-    proto_cls = kwargs.pop("proto_cls", None) or ModbusClientProtocol
-
-    try:
-        from serial_asyncio import create_serial_connection
-    except ImportError:
-        LOGGER.critical("pyserial-asyncio is not installed, "
-                        "install with 'pip install pyserial-asyncio")
-        import sys
-        sys.exit(1)
-
-    client = AsyncioModbusSerialClient(port, proto_cls, framer, loop, **kwargs)
-    coro = client.connect()
-    loop.run_until_complete(coro)
-    return loop, client
-
-
-def get_factory(scheduler):
-    """
-    Gets protocol factory based on the backend scheduler being used
-    :param scheduler: REACTOR/IO_LOOP/ASYNC_IO
-    :return:
-    """
-    if scheduler == schedulers.REACTOR:
-        return reactor_factory
-    elif scheduler == schedulers.IO_LOOP:
-        return io_loop_factory
-    elif scheduler == schedulers.ASYNC_IO:
-        return async_io_factory
-    else:
-        LOGGER.warning("Allowed Schedulers: {}, {}, {}".format(
-            schedulers.REACTOR, schedulers.IO_LOOP, schedulers.ASYNC_IO
-        ))
-        raise Exception("Invalid Scheduler '{}'".format(scheduler))
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/factory/tcp.py b/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/factory/tcp.py
deleted file mode 100644
index fb61378..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/factory/tcp.py
+++ /dev/null
@@ -1,124 +0,0 @@
-"""
-Factory to create asynchronous tcp clients based on twisted/tornado/asyncio
-"""
-from __future__ import unicode_literals
-from __future__ import absolute_import
-
-import logging
-
-from pymodbus.client.asynchronous import schedulers
-from pymodbus.client.asynchronous.thread import EventLoopThread
-from pymodbus.constants import Defaults
-
-LOGGER = logging.getLogger(__name__)
-
-
-def reactor_factory(host="127.0.0.1", port=Defaults.Port, framer=None,
-                    source_address=None, timeout=None, **kwargs):
-    """
-    Factory to create twisted tcp asynchronous client
-    :param host: Host IP address
-    :param port: Port
-    :param framer: Modbus Framer
-    :param source_address: Bind address
-    :param timeout: Timeout in seconds
-    :param kwargs:
-    :return: event_loop_thread and twisted_deferred
-    """
-    from twisted.internet import reactor, protocol
-    from pymodbus.client.asynchronous.twisted import ModbusTcpClientProtocol
-
-    deferred = protocol.ClientCreator(
-        reactor, ModbusTcpClientProtocol
-    ).connectTCP(host, port, timeout=timeout, bindAddress=source_address)
-
-    callback = kwargs.get("callback")
-    errback = kwargs.get("errback")
-
-    if callback:
-        deferred.addCallback(callback)
-
-    if errback:
-        deferred.addErrback(errback)
-
-    protocol = EventLoopThread("reactor", reactor.run, reactor.stop,
-                               installSignalHandlers=0)
-    protocol.start()
-
-    return protocol, deferred
-
-
-def io_loop_factory(host="127.0.0.1", port=Defaults.Port, framer=None,
-                    source_address=None, timeout=None, **kwargs):
-    """
-    Factory to create Tornado based asynchronous tcp clients
-    :param host: Host IP address
-    :param port: Port
-    :param framer: Modbus Framer
-    :param source_address: Bind address
-    :param timeout: Timeout in seconds
-    :param kwargs:
-    :return: event_loop_thread and tornado future
-    """
-    from tornado.ioloop import IOLoop
-    from pymodbus.client.asynchronous.tornado import AsyncModbusTCPClient as \
-        Client
-
-    ioloop = IOLoop()
-    protocol = EventLoopThread("ioloop", ioloop.start, ioloop.stop)
-    protocol.start()
-
-    client = Client(host=host, port=port, framer=framer,
-                    source_address=source_address,
-                    timeout=timeout, ioloop=ioloop, **kwargs)
-
-    future = client.connect()
-
-    return protocol, future
-
-
-def async_io_factory(host="127.0.0.1", port=Defaults.Port, framer=None,
-                     source_address=None, timeout=None, **kwargs):
-    """
-    Factory to create asyncio based asynchronous tcp clients
-    :param host: Host IP address
-    :param port: Port
-    :param framer: Modbus Framer
-    :param source_address: Bind address
-    :param timeout: Timeout in seconds
-    :param kwargs:
-    :return: asyncio event loop and tcp client
-    """
-    import asyncio
-    from pymodbus.client.asynchronous.asyncio import init_tcp_client
-    loop = kwargs.get("loop") or asyncio.new_event_loop()
-    proto_cls = kwargs.get("proto_cls", None)
-    if not loop.is_running():
-        asyncio.set_event_loop(loop)
-        cor = init_tcp_client(proto_cls, loop, host, port)
-        client = loop.run_until_complete(asyncio.gather(cor))[0]
-    else:
-        cor = init_tcp_client(proto_cls, loop, host, port)
-        future = asyncio.run_coroutine_threadsafe(cor, loop=loop)
-        client = future.result()
-
-    return loop, client
-
-
-def get_factory(scheduler):
-    """
-    Gets protocol factory based on the backend scheduler being used
-    :param scheduler: REACTOR/IO_LOOP/ASYNC_IO
-    :return
-    """
-    if scheduler == schedulers.REACTOR:
-        return reactor_factory
-    elif scheduler == schedulers.IO_LOOP:
-        return io_loop_factory
-    elif scheduler == schedulers.ASYNC_IO:
-        return async_io_factory
-    else:
-        LOGGER.warning("Allowed Schedulers: {}, {}, {}".format(
-            schedulers.REACTOR, schedulers.IO_LOOP, schedulers.ASYNC_IO
-        ))
-        raise Exception("Invalid Scheduler '{}'".format(scheduler))
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/factory/udp.py b/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/factory/udp.py
deleted file mode 100644
index d6dc75e..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/factory/udp.py
+++ /dev/null
@@ -1,93 +0,0 @@
-from __future__ import unicode_literals
-from __future__ import absolute_import
-
-import logging
-
-from pymodbus.client.asynchronous import schedulers
-from pymodbus.client.asynchronous.thread import EventLoopThread
-from pymodbus.constants import Defaults
-
-LOGGER = logging.getLogger(__name__)
-
-
-def reactor_factory(host="127.0.0.1", port=Defaults.Port, framer=None,
-                    source_address=None, timeout=None, **kwargs):
-    """
-    Factory to create twisted udp asynchronous client
-    :param host: Host IP address
-    :param port: Port
-    :param framer: Modbus Framer
-    :param source_address: Bind address
-    :param timeout: Timeout in seconds
-    :param kwargs:
-    :return: event_loop_thread and twisted_deferred
-    """
-    raise NotImplementedError()
-
-
-def io_loop_factory(host="127.0.0.1", port=Defaults.Port, framer=None,
-                   source_address=None, timeout=None, **kwargs):
-    """
-    Factory to create Tornado based asynchronous udp clients
-    :param host: Host IP address
-    :param port: Port
-    :param framer: Modbus Framer
-    :param source_address: Bind address
-    :param timeout: Timeout in seconds
-    :param kwargs:
-    :return: event_loop_thread and tornado future
-    """
-    from tornado.ioloop import IOLoop
-    from pymodbus.client.asynchronous.tornado import AsyncModbusUDPClient as \
-        Client
-
-    client = Client(host=host, port=port, framer=framer,
-                    source_address=source_address,
-                    timeout=timeout, **kwargs)
-    protocol = EventLoopThread("ioloop", IOLoop.current().start,
-                               IOLoop.current().stop)
-    protocol.start()
-    future = client.connect()
-
-    return protocol, future
-
-
-def async_io_factory(host="127.0.0.1", port=Defaults.Port, framer=None,
-                     source_address=None, timeout=None, **kwargs):
-    """
-    Factory to create asyncio based asynchronous udp clients
-    :param host: Host IP address
-    :param port: Port
-    :param framer: Modbus Framer
-    :param source_address: Bind address
-    :param timeout: Timeout in seconds
-    :param kwargs:
-    :return: asyncio event loop and udp client
-    """
-    import asyncio
-    from pymodbus.client.asynchronous.asyncio import init_udp_client
-    loop = kwargs.get("loop") or asyncio.get_event_loop()
-    proto_cls = kwargs.get("proto_cls", None)
-    cor = init_udp_client(proto_cls, loop, host, port)
-    client = loop.run_until_complete(asyncio.gather(cor))[0]
-    return loop, client
-
-
-def get_factory(scheduler):
-    """
-    Gets protocol factory based on the backend scheduler being used
-    :param scheduler: REACTOR/IO_LOOP/ASYNC_IO
-    :return
-    """
-    if scheduler == schedulers.REACTOR:
-        return reactor_factory
-    elif scheduler == schedulers.IO_LOOP:
-        return io_loop_factory
-    elif scheduler == schedulers.ASYNC_IO:
-        return async_io_factory
-    else:
-        LOGGER.warning("Allowed Schedulers: {}, {}, {}".format(
-            schedulers.REACTOR, schedulers.IO_LOOP, schedulers.ASYNC_IO
-        ))
-        raise Exception("Invalid Scheduler '{}'".format(scheduler))
-
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/mixins.py b/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/mixins.py
deleted file mode 100644
index f4cae32..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/mixins.py
+++ /dev/null
@@ -1,69 +0,0 @@
-import logging
-
-from pymodbus.client.sync import BaseModbusClient
-
-from pymodbus.constants import Defaults
-
-from pymodbus.factory import ClientDecoder
-from pymodbus.transaction import ModbusSocketFramer
-
-
-LOGGER = logging.getLogger(__name__)
-
-
-class BaseAsyncModbusClient(BaseModbusClient):
-    """
-    This represents the base ModbusAsyncClient.
-    """
-
-    def __init__(self, framer=None, **kwargs):
-        """ Initializes the framer module
-
-        :param framer: The framer to use for the protocol. Default:
-        ModbusSocketFramer
-        :type framer: pymodbus.transaction.ModbusSocketFramer
-        """
-        self._connected = False
-
-        super(BaseAsyncModbusClient, self).__init__(
-            framer or ModbusSocketFramer(ClientDecoder()), **kwargs
-        )
-
-
-class AsyncModbusClientMixin(BaseAsyncModbusClient):
-    """
-    Async Modbus client mixing for UDP and TCP clients
-    """
-    def __init__(self, host="127.0.0.1", port=Defaults.Port, framer=None,
-                 source_address=None, timeout=None, **kwargs):
-        """
-        Initializes a Modbus TCP/UDP asynchronous client
-        :param host: Host IP address
-        :param port: Port
-        :param framer: Framer to use
-        :param source_address: Specific to underlying client being used
-        :param timeout: Timeout in seconds
-        :param kwargs: Extra arguments
-        """
-        super(AsyncModbusClientMixin, self).__init__(framer=framer, **kwargs)
-        self.host = host
-        self.port = port
-        self.source_address = source_address or ("", 0)
-        self.timeout = timeout if timeout is not None else Defaults.Timeout
-
-
-class AsyncModbusSerialClientMixin(BaseAsyncModbusClient):
-    """
-    Async Modbus Serial Client Mixing
-    """
-    def __init__(self, framer=None, port=None, **kwargs):
-        """
-        Initializes a Async Modbus Serial Client
-        :param framer:  Modbus Framer
-        :param port: Serial port to use
-        :param kwargs: Extra arguments if any
-        """
-        super(AsyncModbusSerialClientMixin, self).__init__(framer=framer)
-        self.port = port
-        self.serial_settings = kwargs
-
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/schedulers/__init__.py b/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/schedulers/__init__.py
deleted file mode 100644
index 5917375..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/schedulers/__init__.py
+++ /dev/null
@@ -1,9 +0,0 @@
-"""
-Backend schedulers to use with generic Async clients
-"""
-from __future__ import unicode_literals
-
-
-REACTOR = "reactor"
-IO_LOOP = "io_loop"
-ASYNC_IO = "async_io"
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/serial.py b/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/serial.py
deleted file mode 100644
index 5d2e2e8..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/serial.py
+++ /dev/null
@@ -1,76 +0,0 @@
-from __future__ import unicode_literals
-from __future__ import absolute_import
-
-import logging
-from pymodbus.client.asynchronous.factory.serial import get_factory
-from pymodbus.transaction import ModbusRtuFramer, ModbusAsciiFramer, ModbusBinaryFramer, ModbusSocketFramer
-from pymodbus.factory import ClientDecoder
-from pymodbus.exceptions import ParameterException
-from pymodbus.compat import IS_PYTHON3, PYTHON_VERSION
-from pymodbus.client.asynchronous.schedulers import ASYNC_IO
-
-logger = logging.getLogger(__name__)
-
-
-class AsyncModbusSerialClient(object):
-    """
-    Actual Async Serial Client to be used.
-
-    To use do::
-
-        from pymodbus.client.asynchronous.serial import AsyncModbusSerialClient
-    """
-    @classmethod
-    def _framer(cls, method):
-        """
-        Returns the requested framer
-
-        :method: The serial framer to instantiate
-        :returns: The requested serial framer
-        """
-        method = method.lower()
-        if method == 'ascii':
-            return ModbusAsciiFramer(ClientDecoder())
-        elif method == 'rtu':
-            return ModbusRtuFramer(ClientDecoder())
-        elif method == 'binary':
-            return ModbusBinaryFramer(ClientDecoder())
-        elif method == 'socket':
-            return ModbusSocketFramer(ClientDecoder())
-
-        raise ParameterException("Invalid framer method requested")
-
-    def __new__(cls, scheduler, method, port,  **kwargs):
-        """
-        Scheduler to use:
-            - reactor (Twisted)
-            - io_loop (Tornado)
-            - async_io (asyncio)
-        The methods to connect are::
-
-          - ascii
-          - rtu
-          - binary
-        : param scheduler: Backend to use
-        :param method: The method to use for connection
-        :param port: The serial port to attach to
-        :param stopbits: The number of stop bits to use
-        :param bytesize: The bytesize of the serial messages
-        :param parity: Which kind of parity to use
-        :param baudrate: The baud rate to use for the serial device
-        :param timeout: The timeout between serial requests (default 3s)
-        :param scheduler:
-        :param method:
-        :param port:
-        :param kwargs:
-        :return:
-        """
-        if (not (IS_PYTHON3 and PYTHON_VERSION >= (3, 4))
-                and scheduler == ASYNC_IO):
-            logger.critical("ASYNCIO is supported only on python3")
-            import sys
-            sys.exit(1)
-        factory_class = get_factory(scheduler)
-        framer = cls._framer(method)
-        yieldable = factory_class(framer=framer, port=port, **kwargs)
-        return yieldable
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/tcp.py b/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/tcp.py
deleted file mode 100644
index 45b7cfd..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/tcp.py
+++ /dev/null
@@ -1,47 +0,0 @@
-from __future__ import unicode_literals
-from __future__ import absolute_import
-
-import logging
-from pymodbus.client.asynchronous.factory.tcp import get_factory
-from pymodbus.constants import Defaults
-from pymodbus.compat import IS_PYTHON3, PYTHON_VERSION
-from pymodbus.client.asynchronous.schedulers import ASYNC_IO
-
-logger = logging.getLogger(__name__)
-
-
-class AsyncModbusTCPClient(object):
-    """
-    Actual Async Serial Client to be used.
-
-    To use do::
-
-        from pymodbus.client.asynchronous.tcp import AsyncModbusTCPClient
-    """
-    def __new__(cls, scheduler, host="127.0.0.1", port=Defaults.Port,
-                framer=None, source_address=None, timeout=None, **kwargs):
-        """
-        Scheduler to use:
-            - reactor (Twisted)
-            - io_loop (Tornado)
-            - async_io (asyncio)
-        :param scheduler: Backend to use
-        :param host: Host IP address
-        :param port: Port
-        :param framer: Modbus Framer to use
-        :param source_address: source address specific to underlying backend
-        :param timeout: Time out in seconds
-        :param kwargs: Other extra args specific to Backend being used
-        :return:
-        """
-        if (not (IS_PYTHON3 and PYTHON_VERSION >= (3, 4))
-                and scheduler == ASYNC_IO):
-            logger.critical("ASYNCIO is supported only on python3")
-            import sys
-            sys.exit(1)
-        factory_class = get_factory(scheduler)
-        yieldable = factory_class(host=host, port=port, framer=framer,
-                                  source_address=source_address,
-                                  timeout=timeout, **kwargs)
-        return yieldable
-
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/thread.py b/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/thread.py
deleted file mode 100644
index d911e49..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/thread.py
+++ /dev/null
@@ -1,53 +0,0 @@
-from __future__ import unicode_literals
-from __future__ import absolute_import
-
-from threading import Thread
-
-import logging
-
-LOGGER = logging.getLogger(__name__)
-
-
-class EventLoopThread(object):
-    """
-    Event loop controlling the backend event loops (io_loop for tornado,
-    reactor for twisted and event_loop for Asyncio)
-    """
-    def __init__(self, name, start, stop, *args, **kwargs):
-        """
-        Initialize Event loop thread
-        :param name: Name of the event loop
-        :param start: Start method  to start the backend event loop
-        :param stop: Stop method to stop the backend event loop
-        :param args:
-        :param kwargs:
-        """
-        self._name = name
-        self._start_loop = start
-        self._stop_loop = stop
-        self._args = args
-        self._kwargs = kwargs
-        self._event_loop = Thread(name=self._name, target=self._start)
-
-    def _start(self):
-        """
-        Starts the backend event loop
-        :return:
-        """
-        self._start_loop(*self._args, **self._kwargs)
-
-    def start(self):
-        """
-        Starts the backend event loop
-        :return:
-        """
-        LOGGER.info("Starting Event Loop: 'PyModbus_{}'".format(self._name))
-        self._event_loop.start()
-
-    def stop(self):
-        """
-        Stops the backend event loop
-        :return:
-        """
-        LOGGER.info("Stopping Event Loop: 'PyModbus_{}'".format(self._name))
-        self._stop_loop()
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/tornado/__init__.py b/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/tornado/__init__.py
deleted file mode 100644
index e0af49e..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/tornado/__init__.py
+++ /dev/null
@@ -1,343 +0,0 @@
-"""
-Asynchronous framework adapter for tornado.
-"""
-from __future__ import unicode_literals
-
-import abc
-
-import logging
-
-import socket
-from serial import Serial
-from tornado import gen
-from tornado.concurrent import Future
-from tornado.ioloop import IOLoop
-from tornado.iostream import IOStream
-from tornado.iostream import BaseIOStream
-
-from pymodbus.client.asynchronous.mixins import (AsyncModbusClientMixin,
-                                                 AsyncModbusSerialClientMixin)
-from pymodbus.exceptions import ConnectionException
-from pymodbus.compat import byte2int
-
-LOGGER = logging.getLogger(__name__)
-
-
-class BaseTornadoClient(AsyncModbusClientMixin):
-    """
-    Base Tornado client
-    """
-    stream = None
-    io_loop = None
-
-    def __init__(self, *args, **kwargs):
-        """
-        Initializes BaseTornadoClient.
-        ioloop to be passed as part of kwargs ('ioloop')
-        :param args:
-        :param kwargs:
-        """
-        self.io_loop = kwargs.pop("ioloop", None)
-        super(BaseTornadoClient, self).__init__(*args, **kwargs)
-
-    @abc.abstractmethod
-    def get_socket(self):
-        """
-        return instance of the socket to connect to
-        """
-
-    @gen.coroutine
-    def connect(self):
-        """
-        Connect to the socket identified by host and port
-
-        :returns: Future
-        :rtype: tornado.concurrent.Future
-        """
-        conn = self.get_socket()
-        self.stream = IOStream(conn, io_loop=self.io_loop or IOLoop.current())
-        self.stream.connect((self.host, self.port))
-        self.stream.read_until_close(None,
-                                     streaming_callback=self.on_receive)
-        self._connected = True
-        LOGGER.debug("Client connected")
-
-        raise gen.Return(self)
-
-    def on_receive(self, *args):
-        """
-        On data recieve call back
-        :param args: data received
-        :return:
-        """
-        data = args[0] if len(args) > 0 else None
-
-        if not data:
-            return
-        LOGGER.debug("recv: " + " ".join([hex(byte2int(x)) for x in data]))
-        unit = self.framer.decode_data(data).get("uid", 0)
-        self.framer.processIncomingPacket(data, self._handle_response, unit=unit)
-
-    def execute(self, request=None):
-        """
-        Executes a transaction
-        :param request:
-        :return:
-        """
-        request.transaction_id = self.transaction.getNextTID()
-        packet = self.framer.buildPacket(request)
-        LOGGER.debug("send: " + " ".join([hex(byte2int(x)) for x in packet]))
-        self.stream.write(packet)
-        return self._build_response(request.transaction_id)
-
-    def _handle_response(self, reply, **kwargs):
-        """
-        Handle response received
-        :param reply:
-        :param kwargs:
-        :return:
-        """
-        if reply is not None:
-            tid = reply.transaction_id
-            future = self.transaction.getTransaction(tid)
-            if future:
-                future.set_result(reply)
-            else:
-                LOGGER.debug("Unrequested message: {}".format(reply))
-
-    def _build_response(self, tid):
-        """
-        Builds a future response
-        :param tid:
-        :return:
-        """
-        f = Future()
-
-        if not self._connected:
-            f.set_exception(ConnectionException("Client is not connected"))
-            return f
-
-        self.transaction.addTransaction(f, tid)
-        return f
-
-    def close(self):
-        """
-        Closes the underlying IOStream
-        """
-        LOGGER.debug("Client disconnected")
-        if self.stream:
-            self.stream.close_fd()
-
-        self.stream = None
-        self._connected = False
-
-
-class BaseTornadoSerialClient(AsyncModbusSerialClientMixin):
-    """
-    Base Tonado serial client
-    """
-    stream = None
-    io_loop = None
-
-    def __init__(self, *args, **kwargs):
-        """
-        Initializes BaseTornadoSerialClient.
-        ioloop to be passed as part of kwargs ('ioloop')
-        :param args:
-        :param kwargs:
-        """
-        self.io_loop = kwargs.pop("ioloop", None)
-        super(BaseTornadoSerialClient, self).__init__(*args, **kwargs)
-
-    @abc.abstractmethod
-    def get_socket(self):
-        """
-        return instance of the socket to connect to
-        """
-
-    def on_receive(self, *args):
-        # Will be handled ine execute method
-        pass
-
-    def execute(self, request=None):
-        """
-        Executes a transaction
-        :param request: Request to be written on to the bus
-        :return:
-        """
-        request.transaction_id = self.transaction.getNextTID()
-
-        def callback(*args):
-            LOGGER.debug("in callback - {}".format(request.transaction_id))
-            while True:
-                waiting = self.stream.connection.in_waiting
-                if waiting:
-                    data = self.stream.connection.read(waiting)
-                    LOGGER.debug(
-                        "recv: " + " ".join([hex(byte2int(x)) for x in data]))
-                    unit = self.framer.decode_data(data).get("uid", 0)
-                    self.framer.processIncomingPacket(
-                        data,
-                        self._handle_response,
-                        unit,
-                        tid=request.transaction_id
-                    )
-                    break
-
-        packet = self.framer.buildPacket(request)
-        LOGGER.debug("send: " + " ".join([hex(byte2int(x)) for x in packet]))
-        self.stream.write(packet, callback=callback)
-        f = self._build_response(request.transaction_id)
-        return f
-
-    def _handle_response(self, reply, **kwargs):
-        """
-        Handles a received response and updates a future
-        :param reply: Reply received
-        :param kwargs:
-        :return:
-        """
-        if reply is not None:
-            tid = reply.transaction_id
-            future = self.transaction.getTransaction(tid)
-            if future:
-                future.set_result(reply)
-            else:
-                LOGGER.debug("Unrequested message: {}".format(reply))
-
-    def _build_response(self, tid):
-        """
-        Prepare for a response, returns a future
-        :param tid:
-        :return: Future
-        """
-        f = Future()
-
-        if not self._connected:
-            f.set_exception(ConnectionException("Client is not connected"))
-            return f
-
-        self.transaction.addTransaction(f, tid)
-        return f
-
-    def close(self):
-        """
-        Closes the underlying IOStream
-        """
-        LOGGER.debug("Client disconnected")
-        if self.stream:
-            self.stream.close_fd()
-
-        self.stream = None
-        self._connected = False
-
-
-class SerialIOStream(BaseIOStream):
-    """
-    Serial IO Stream class to control and handle serial connections
-     over tornado
-    """
-    def __init__(self, connection, *args, **kwargs):
-        """
-        Initializes Serial IO Stream
-        :param connection: serial object
-        :param args:
-        :param kwargs:
-        """
-        self.connection = connection
-        super(SerialIOStream, self).__init__(*args, **kwargs)
-
-    def fileno(self):
-        """
-        Returns serial fd
-        :return:
-        """
-        return self.connection.fileno()
-
-    def close_fd(self):
-        """
-        Closes a serial Fd
-        :return:
-        """
-        if self.connection:
-            self.connection.close()
-            self.connection = None
-
-    def read_from_fd(self):
-        """
-        Reads from a fd
-        :return:
-        """
-        try:
-            chunk = self.connection.readline()
-        except Exception:
-            return None
-
-        return chunk
-
-    def write_to_fd(self, data):
-        """
-        Writes to a fd
-        :param data:
-        :return:
-        """
-        try:
-            return self.connection.write(data)
-        except  Exception as e:
-            LOGGER.error(e)
-
-
-class AsyncModbusSerialClient(BaseTornadoSerialClient):
-    """
-    Tornado based asynchronous serial client
-    """
-    def get_socket(self):
-        """
-        Creates Pyserial object
-        :return: serial object
-        """
-        return Serial(port=self.port, **self.serial_settings)
-
-    @gen.coroutine
-    def connect(self):
-        """Connect to the socket identified by host and port
-
-        :returns: Future
-        :rtype: tornado.concurrent.Future
-        """
-        conn = self.get_socket()
-        if self.io_loop is None:
-            self.io_loop = IOLoop.current()
-        try:
-            self.stream = SerialIOStream(conn, io_loop=self.io_loop)
-        except Exception as e:
-            LOGGER.exception(e)
-
-        self._connected = True
-        LOGGER.debug("Client connected")
-
-        raise gen.Return(self)
-
-
-class AsyncModbusTCPClient(BaseTornadoClient):
-    """
-    Tornado based Async tcp client
-    """
-    def get_socket(self):
-        """
-        Creates socket object
-        :return: socket
-        """
-        return socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
-
-
-class AsyncModbusUDPClient(BaseTornadoClient):
-    """
-    Tornado based Async UDP client
-    """
-    def get_socket(self):
-        """
-        Create socket object
-        :return: socket
-        """
-        return socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
\ No newline at end of file
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/twisted/__init__.py b/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/twisted/__init__.py
deleted file mode 100644
index b1841a8..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/twisted/__init__.py
+++ /dev/null
@@ -1,251 +0,0 @@
-"""
-Implementation of a Modbus Client Using Twisted
---------------------------------------------------
-
-Example run::
-
-    from twisted.internet import reactor, protocol
-    from pymodbus.client.asynchronous import ModbusClientProtocol
-
-    def printResult(result):
-        print "Result: %d" % result.bits[0]
-
-    def process(client):
-        result = client.write_coil(1, True)
-        result.addCallback(printResult)
-        reactor.callLater(1, reactor.stop)
-
-    defer = protocol.ClientCreator(reactor, ModbusClientProtocol
-            ).connectTCP("localhost", 502)
-    defer.addCallback(process)
-
-Another example::
-
-    from twisted.internet import reactor
-    from pymodbus.client.asynchronous import ModbusClientFactory
-
-    def process():
-        factory = reactor.connectTCP("localhost", 502, ModbusClientFactory())
-        reactor.stop()
-
-    if __name__ == "__main__":
-       reactor.callLater(1, process)
-       reactor.run()
-"""
-from __future__ import unicode_literals
-from twisted.internet import defer, protocol
-
-from pymodbus.exceptions import ConnectionException
-from pymodbus.factory import ClientDecoder
-from pymodbus.client.asynchronous.mixins import AsyncModbusClientMixin
-from pymodbus.transaction import FifoTransactionManager, DictTransactionManager
-from pymodbus.transaction import ModbusSocketFramer, ModbusRtuFramer
-from pymodbus.compat import  byte2int
-from twisted.python.failure import Failure
-
-
-# --------------------------------------------------------------------------- #
-# Logging
-# --------------------------------------------------------------------------- #
-import logging
-_logger = logging.getLogger(__name__)
-
-
-# --------------------------------------------------------------------------- #
-# Connected Client Protocols
-# --------------------------------------------------------------------------- #
-class ModbusClientProtocol(protocol.Protocol,
-                           AsyncModbusClientMixin):
-    """
-    This represents the base modbus client protocol.  All the application
-    layer code is deferred to a higher level wrapper.
-    """
-    framer = None
-
-    def __init__(self, framer=None, **kwargs):
-        self._connected = False
-        self.framer = framer or ModbusSocketFramer(ClientDecoder())
-        if isinstance(self.framer, type):
-            # Framer class not instance
-            self.framer = self.framer(ClientDecoder(), client=None)
-        if isinstance(self.framer, ModbusSocketFramer):
-            self.transaction = DictTransactionManager(self, **kwargs)
-        else:
-            self.transaction = FifoTransactionManager(self, **kwargs)
-
-    def connectionMade(self):
-        """ 
-        Called upon a successful client connection.
-        """
-        _logger.debug("Client connected to modbus server")
-        self._connected = True
-
-    def connectionLost(self, reason=None):
-        """ 
-        Called upon a client disconnect
-
-        :param reason: The reason for the disconnect
-        """
-        _logger.debug("Client disconnected from modbus server: %s" % reason)
-        self._connected = False
-        for tid in list(self.transaction):
-            self.transaction.getTransaction(tid).errback(Failure(
-                ConnectionException('Connection lost during request')))
-
-    def dataReceived(self, data):
-        """ 
-        Get response, check for valid message, decode result
-
-        :param data: The data returned from the server
-        """
-        unit = self.framer.decode_data(data).get("uid", 0)
-        self.framer.processIncomingPacket(data, self._handleResponse,
-                                          unit=unit)
-
-    def execute(self, request):
-        """ 
-        Starts the producer to send the next request to
-        consumer.write(Frame(request))
-        """
-        request.transaction_id = self.transaction.getNextTID()
-        packet = self.framer.buildPacket(request)
-        _logger.debug("send: " + " ".join([hex(byte2int(x)) for x in packet]))
-        self.transport.write(packet)
-        return self._buildResponse(request.transaction_id)
-
-    def _handleResponse(self, reply, **kwargs):
-        """ 
-        Handle the processed response and link to correct deferred
-
-        :param reply: The reply to process
-        """
-        if reply is not None:
-            tid = reply.transaction_id
-            handler = self.transaction.getTransaction(tid)
-            if handler:
-                handler.callback(reply)
-            else:
-                _logger.debug("Unrequested message: " + str(reply))
-
-    def _buildResponse(self, tid):
-        """ 
-        Helper method to return a deferred response
-        for the current request.
-
-        :param tid: The transaction identifier for this response
-        :returns: A defer linked to the latest request
-        """
-        if not self._connected:
-            return defer.fail(Failure(
-                ConnectionException('Client is not connected')))
-
-        d = defer.Deferred()
-        self.transaction.addTransaction(d, tid)
-        return d
-
-    def close(self):
-        """
-        Closes underlying transport layer ,essentially closing the client
-        :return: 
-        """
-        if self.transport and hasattr(self.transport, "close"):
-            self.transport.close()
-        self._connected = False
-
-
-class ModbusTcpClientProtocol(ModbusClientProtocol):
-    """
-    Async TCP Client protocol based on twisted.
-    
-    Default framer: ModbusSocketFramer
-    """
-    framer = ModbusSocketFramer(ClientDecoder())
-
-
-class ModbusSerClientProtocol(ModbusClientProtocol):
-    """
-    Async Serial Client protocol based on twisted
-    
-    Default framer: ModbusRtuFramer
-    """
-    def __init__(self, framer=None, **kwargs):
-        framer = framer or ModbusRtuFramer(ClientDecoder())
-        super(ModbusSerClientProtocol, self).__init__(framer, **kwargs)
-
-
-# --------------------------------------------------------------------------- #
-# Not Connected Client Protocol
-# --------------------------------------------------------------------------- #
-class ModbusUdpClientProtocol(protocol.DatagramProtocol, 
-                              AsyncModbusClientMixin):
-    """
-    This represents the base modbus client protocol.  All the application
-    layer code is deferred to a higher level wrapper.
-    """
-
-    def datagramReceived(self, data, params):
-        """
-        Get response, check for valid message, decode result
-
-        :param data: The data returned from the server
-        :param params: The host parameters sending the datagram
-        """
-        _logger.debug("Datagram from: %s:%d" % params)
-        unit = self.framer.decode_data(data).get("uid", 0)
-        self.framer.processIncomingPacket(data, self._handleResponse, unit=unit)
-
-    def execute(self, request):
-        """
-        Starts the producer to send the next request to
-        consumer.write(Frame(request))
-        """
-        request.transaction_id = self.transaction.getNextTID()
-        packet = self.framer.buildPacket(request)
-        self.transport.write(packet, (self.host, self.port))
-        return self._buildResponse(request.transaction_id)
-
-    def _handleResponse(self, reply, **kwargs):
-        """
-        Handle the processed response and link to correct deferred
-
-        :param reply: The reply to process
-        """
-        if reply is not None:
-            tid = reply.transaction_id
-            handler = self.transaction.getTransaction(tid)
-            if handler:
-                handler.callback(reply)
-            else: _logger.debug("Unrequested message: " + str(reply))
-
-    def _buildResponse(self, tid):
-        """
-        Helper method to return a deferred response
-        for the current request.
-
-        :param tid: The transaction identifier for this response
-        :returns: A defer linked to the latest request
-        """
-        d = defer.Deferred()
-        self.transaction.addTransaction(d, tid)
-        return d
-
-
-# --------------------------------------------------------------------------- #
-# Client Factories
-# --------------------------------------------------------------------------- #
-class ModbusClientFactory(protocol.ReconnectingClientFactory):
-    """ Simple client protocol factory """
-
-    protocol = ModbusClientProtocol
-
-# --------------------------------------------------------------------------- #
-# Exported symbols
-# --------------------------------------------------------------------------- #
-
-
-__all__ = [
-    "ModbusClientProtocol",
-    "ModbusUdpClientProtocol",
-    "ModbusClientFactory"
-]
-
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/udp.py b/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/udp.py
deleted file mode 100644
index a111d96..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/asynchronous/udp.py
+++ /dev/null
@@ -1,47 +0,0 @@
-from __future__ import unicode_literals
-from __future__ import absolute_import
-
-import logging
-from pymodbus.constants import Defaults
-from pymodbus.compat import IS_PYTHON3, PYTHON_VERSION
-from pymodbus.client.asynchronous.schedulers import ASYNC_IO
-from pymodbus.client.asynchronous.factory.udp import get_factory
-
-logger = logging.getLogger(__name__)
-
-
-class AsyncModbusUDPClient(object):
-    """
-    Actual Async UDP Client to be used.
-
-    To use do::
-
-        from pymodbus.client.asynchronous.tcp import AsyncModbusUDPClient
-    """
-    def __new__(cls, scheduler, host="127.0.0.1", port=Defaults.Port,
-                framer=None, source_address=None, timeout=None, **kwargs):
-        """
-        Scheduler to use:
-            - reactor (Twisted)
-            - io_loop (Tornado)
-            - async_io (asyncio)
-        :param scheduler: Backend to use
-        :param host: Host IP address
-        :param port: Port
-        :param framer: Modbus Framer to use
-        :param source_address: source address specific to underlying backend
-        :param timeout: Time out in seconds
-        :param kwargs: Other extra args specific to Backend being used
-        :return:
-        """
-        if (not (IS_PYTHON3 and PYTHON_VERSION >= (3, 4))
-                and scheduler == ASYNC_IO):
-            logger.critical("ASYNCIO is supported only on python3")
-            import sys
-            sys.exit(1)
-        factory_class = get_factory(scheduler)
-        yieldable = factory_class(host=host, port=port, framer=framer,
-                                  source_address=source_address,
-                                  timeout=timeout, **kwargs)
-        return yieldable
-
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/common.py b/venv/lib/python3.7/site-packages/pymodbus/client/common.py
deleted file mode 100644
index ea3c981..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/common.py
+++ /dev/null
@@ -1,155 +0,0 @@
-'''
-Modbus Client Common
-----------------------------------
-
-This is a common client mixin that can be used by
-both the synchronous and asynchronous clients to
-simplify the interface.
-'''
-from pymodbus.bit_read_message import *
-from pymodbus.bit_write_message import *
-from pymodbus.register_read_message import *
-from pymodbus.register_write_message import *
-from pymodbus.diag_message import *
-from pymodbus.file_message import *
-from pymodbus.other_message import *
-
-from pymodbus.utilities import ModbusTransactionState
-
-
-class ModbusClientMixin(object):
-    '''
-    This is a modbus client mixin that provides additional factory
-    methods for all the current modbus methods. This can be used
-    instead of the normal pattern of::
-
-       # instead of this
-       client = ModbusClient(...)
-       request = ReadCoilsRequest(1,10)
-       response = client.execute(request)
-
-       # now like this
-       client = ModbusClient(...)
-       response = client.read_coils(1, 10)
-    '''
-    state = ModbusTransactionState.IDLE
-    last_frame_end = 0
-    silent_interval = 0
-
-    def read_coils(self, address, count=1, **kwargs):
-        '''
-
-        :param address: The starting address to read from
-        :param count: The number of coils to read
-        :param unit: The slave unit this request is targeting
-        :returns: A deferred response handle
-        '''
-        request = ReadCoilsRequest(address, count, **kwargs)
-        return self.execute(request)
-
-    def read_discrete_inputs(self, address, count=1, **kwargs):
-        '''
-
-        :param address: The starting address to read from
-        :param count: The number of discretes to read
-        :param unit: The slave unit this request is targeting
-        :returns: A deferred response handle
-        '''
-        request = ReadDiscreteInputsRequest(address, count, **kwargs)
-        return self.execute(request)
-
-    def write_coil(self, address, value, **kwargs):
-        '''
-
-        :param address: The starting address to write to
-        :param value: The value to write to the specified address
-        :param unit: The slave unit this request is targeting
-        :returns: A deferred response handle
-        '''
-        request = WriteSingleCoilRequest(address, value, **kwargs)
-        return self.execute(request)
-
-    def write_coils(self, address, values, **kwargs):
-        '''
-
-        :param address: The starting address to write to
-        :param values: The values to write to the specified address
-        :param unit: The slave unit this request is targeting
-        :returns: A deferred response handle
-        '''
-        request = WriteMultipleCoilsRequest(address, values, **kwargs)
-        return self.execute(request)
-
-    def write_register(self, address, value, **kwargs):
-        '''
-
-        :param address: The starting address to write to
-        :param value: The value to write to the specified address
-        :param unit: The slave unit this request is targeting
-        :returns: A deferred response handle
-        '''
-        request = WriteSingleRegisterRequest(address, value, **kwargs)
-        return self.execute(request)
-
-    def write_registers(self, address, values, **kwargs):
-        '''
-
-        :param address: The starting address to write to
-        :param values: The values to write to the specified address
-        :param unit: The slave unit this request is targeting
-        :returns: A deferred response handle
-        '''
-        request = WriteMultipleRegistersRequest(address, values, **kwargs)
-        return self.execute(request)
-
-    def read_holding_registers(self, address, count=1, **kwargs):
-        '''
-
-        :param address: The starting address to read from
-        :param count: The number of registers to read
-        :param unit: The slave unit this request is targeting
-        :returns: A deferred response handle
-        '''
-        request = ReadHoldingRegistersRequest(address, count, **kwargs)
-        return self.execute(request)
-
-    def read_input_registers(self, address, count=1, **kwargs):
-        '''
-
-        :param address: The starting address to read from
-        :param count: The number of registers to read
-        :param unit: The slave unit this request is targeting
-        :returns: A deferred response handle
-        '''
-        request = ReadInputRegistersRequest(address, count, **kwargs)
-        return self.execute(request)
-
-    def readwrite_registers(self, *args, **kwargs):
-        '''
-
-        :param read_address: The address to start reading from
-        :param read_count: The number of registers to read from address
-        :param write_address: The address to start writing to
-        :param write_registers: The registers to write to the specified address
-        :param unit: The slave unit this request is targeting
-        :returns: A deferred response handle
-        '''
-        request = ReadWriteMultipleRegistersRequest(*args, **kwargs)
-        return self.execute(request)
-
-    def mask_write_register(self, *args, **kwargs):
-        '''
-
-        :param address: The address of the register to write
-        :param and_mask: The and bitmask to apply to the register address
-        :param or_mask: The or bitmask to apply to the register address
-        :param unit: The slave unit this request is targeting
-        :returns: A deferred response handle
-        '''
-        request = MaskWriteRegisterRequest(*args, **kwargs)
-        return self.execute(request)
-
-#---------------------------------------------------------------------------#
-# Exported symbols
-#---------------------------------------------------------------------------#
-__all__ = [ 'ModbusClientMixin' ]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/client/sync.py b/venv/lib/python3.7/site-packages/pymodbus/client/sync.py
deleted file mode 100644
index 04d7778..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/client/sync.py
+++ /dev/null
@@ -1,597 +0,0 @@
-import socket
-import select
-import serial
-import time
-import sys
-from functools import partial
-from pymodbus.constants import Defaults
-from pymodbus.utilities import hexlify_packets, ModbusTransactionState
-from pymodbus.factory import ClientDecoder
-from pymodbus.exceptions import NotImplementedException, ParameterException
-from pymodbus.exceptions import ConnectionException
-from pymodbus.transaction import FifoTransactionManager
-from pymodbus.transaction import DictTransactionManager
-from pymodbus.transaction import ModbusSocketFramer, ModbusBinaryFramer
-from pymodbus.transaction import ModbusAsciiFramer, ModbusRtuFramer
-from pymodbus.client.common import ModbusClientMixin
-
-# --------------------------------------------------------------------------- #
-# Logging
-# --------------------------------------------------------------------------- #
-import logging
-_logger = logging.getLogger(__name__)
-
-# --------------------------------------------------------------------------- #
-# The Synchronous Clients
-# --------------------------------------------------------------------------- #
-
-
-class BaseModbusClient(ModbusClientMixin):
-    """
-    Inteface for a modbus synchronous client. Defined here are all the
-    methods for performing the related request methods.  Derived classes
-    simply need to implement the transport methods and set the correct
-    framer.
-    """
-    def __init__(self, framer, **kwargs):
-        """ Initialize a client instance
-
-        :param framer: The modbus framer implementation to use
-        """
-        self.framer = framer
-        self.transaction = DictTransactionManager(self, **kwargs)
-        self._debug = False
-        self._debugfd = None
-        self.broadcast_enable = kwargs.get('broadcast_enable', Defaults.broadcast_enable)
-
-    # ----------------------------------------------------------------------- #
-    # Client interface
-    # ----------------------------------------------------------------------- #
-    def connect(self):
-        """ Connect to the modbus remote host
-
-        :returns: True if connection succeeded, False otherwise
-        """
-        raise NotImplementedException("Method not implemented by derived class")
-
-    def close(self):
-        """ Closes the underlying socket connection
-        """
-        pass
-
-    def is_socket_open(self):
-        """
-        Check whether the underlying socket/serial is open or not.
-
-        :returns: True if socket/serial is open, False otherwise
-        """
-        raise NotImplementedException(
-            "is_socket_open() not implemented by {}".format(self.__str__())
-        )
-
-    def send(self, request):
-        _logger.debug("New Transaction state 'SENDING'")
-        self.state = ModbusTransactionState.SENDING
-        return self._send(request)
-
-    def _send(self, request):
-        """ Sends data on the underlying socket
-
-        :param request: The encoded request to send
-        :return: The number of bytes written
-        """
-        raise NotImplementedException("Method not implemented by derived class")
-
-    def recv(self, size):
-        return self._recv(size)
-
-    def _recv(self, size):
-        """ Reads data from the underlying descriptor
-
-        :param size: The number of bytes to read
-        :return: The bytes read
-        """
-        raise NotImplementedException("Method not implemented by derived class")
-
-    # ----------------------------------------------------------------------- #
-    # Modbus client methods
-    # ----------------------------------------------------------------------- #
-    def execute(self, request=None):
-        """
-        :param request: The request to process
-        :returns: The result of the request execution
-        """
-        if not self.connect():
-            raise ConnectionException("Failed to connect[%s]" % (self.__str__()))
-        return self.transaction.execute(request)
-
-    # ----------------------------------------------------------------------- #
-    # The magic methods
-    # ----------------------------------------------------------------------- #
-    def __enter__(self):
-        """ Implement the client with enter block
-
-        :returns: The current instance of the client
-        """
-        if not self.connect():
-            raise ConnectionException("Failed to connect[%s]" % (self.__str__()))
-        return self
-
-    def __exit__(self, klass, value, traceback):
-        """ Implement the client with exit block """
-        self.close()
-
-    def idle_time(self):
-        """
-        Bus Idle Time to initiate next transaction
-        :return: time stamp
-        """
-        if self.last_frame_end is None or self.silent_interval is None:
-            return 0
-        return self.last_frame_end + self.silent_interval
-
-    def debug_enabled(self):
-        """
-        Returns a boolean indicating if debug is enabled.
-        """
-        return self._debug
-
-    def set_debug(self, debug):
-        """
-        Sets the current debug flag.
-        """
-        self._debug = debug
-
-    def trace(self, writeable):
-        if writeable:
-            self.set_debug(True)
-        self._debugfd = writeable
-
-    def _dump(self, data, direction):
-        fd = self._debugfd if self._debugfd else sys.stdout
-        try:
-            fd.write(hexlify_packets(data))
-        except Exception as e:
-            self._logger.debug(hexlify_packets(data))
-            self._logger.exception(e)
-
-    def register(self, function):
-        """
-        Registers a function and sub function class with the decoder
-        :param function: Custom function class to register
-        :return:
-        """
-        self.framer.decoder.register(function)
-
-    def __str__(self):
-        """ Builds a string representation of the connection
-
-        :returns: The string representation
-        """
-        return "Null Transport"
-
-
-# --------------------------------------------------------------------------- #
-# Modbus TCP Client Transport Implementation
-# --------------------------------------------------------------------------- #
-class ModbusTcpClient(BaseModbusClient):
-    """ Implementation of a modbus tcp client
-    """
-
-    def __init__(self, host='127.0.0.1', port=Defaults.Port,
-        framer=ModbusSocketFramer, **kwargs):
-        """ Initialize a client instance
-
-        :param host: The host to connect to (default 127.0.0.1)
-        :param port: The modbus port to connect to (default 502)
-        :param source_address: The source address tuple to bind to (default ('', 0))
-        :param timeout: The timeout to use for this socket (default Defaults.Timeout)
-        :param framer: The modbus framer to use (default ModbusSocketFramer)
-
-        .. note:: The host argument will accept ipv4 and ipv6 hosts
-        """
-        self.host = host
-        self.port = port
-        self.source_address = kwargs.get('source_address', ('', 0))
-        self.socket = None
-        self.timeout = kwargs.get('timeout',  Defaults.Timeout)
-        BaseModbusClient.__init__(self, framer(ClientDecoder(), self), **kwargs)
-
-    def connect(self):
-        """ Connect to the modbus tcp server
-
-        :returns: True if connection succeeded, False otherwise
-        """
-        if self.socket: return True
-        try:
-            self.socket = socket.create_connection(
-                (self.host, self.port),
-                timeout=self.timeout,
-                source_address=self.source_address)
-        except socket.error as msg:
-            _logger.error('Connection to (%s, %s) '
-                          'failed: %s' % (self.host, self.port, msg))
-            self.close()
-        return self.socket is not None
-
-    def close(self):
-        """ Closes the underlying socket connection
-        """
-        if self.socket:
-            self.socket.close()
-        self.socket = None
-
-    def _send(self, request):
-        """ Sends data on the underlying socket
-
-        :param request: The encoded request to send
-        :return: The number of bytes written
-        """
-        if not self.socket:
-            raise ConnectionException(self.__str__())
-        if request:
-            return self.socket.send(request)
-        return 0
-
-    def _recv(self, size):
-        """ Reads data from the underlying descriptor
-
-        :param size: The number of bytes to read
-        :return: The bytes read
-        """
-        if not self.socket:
-            raise ConnectionException(self.__str__())
-
-        # socket.recv(size) waits until it gets some data from the host but
-        # not necessarily the entire response that can be fragmented in
-        # many packets.
-        # To avoid the splitted responses to be recognized as invalid
-        # messages and to be discarded, loops socket.recv until full data
-        # is received or timeout is expired.
-        # If timeout expires returns the read data, also if its length is
-        # less than the expected size.
-        self.socket.setblocking(0)
-
-        timeout = self.timeout
-
-        # If size isn't specified read 1 byte at a time.
-        if size is None:
-            recv_size = 1
-        else:
-            recv_size = size
-
-        data = b''
-        time_ = time.time()
-        end = time_ + timeout
-        while recv_size > 0:
-            ready = select.select([self.socket], [], [], end - time_)
-            if ready[0]:
-                data += self.socket.recv(recv_size)
-            time_ = time.time()
-
-            # If size isn't specified continue to read until timeout expires.
-            if size:
-                recv_size = size - len(data)
-
-            # Timeout is reduced also if some data has been received in order
-            # to avoid infinite loops when there isn't an expected response
-            # size and the slave sends noisy data continuosly.
-            if time_ > end:
-                break
-
-        return data
-
-    def is_socket_open(self):
-        return True if self.socket is not None else False
-
-    def __str__(self):
-        """ Builds a string representation of the connection
-
-        :returns: The string representation
-        """
-        return "ModbusTcpClient(%s:%s)" % (self.host, self.port)
-
-    def __repr__(self):
-        return (
-            "<{} at {} socket={self.socket}, ipaddr={self.host}, "
-            "port={self.port}, timeout={self.timeout}>"
-        ).format(self.__class__.__name__, hex(id(self)), self=self)
-
-# --------------------------------------------------------------------------- #
-# Modbus UDP Client Transport Implementation
-# --------------------------------------------------------------------------- #
-
-
-class ModbusUdpClient(BaseModbusClient):
-    """ Implementation of a modbus udp client
-    """
-
-    def __init__(self, host='127.0.0.1', port=Defaults.Port,
-                 framer=ModbusSocketFramer, **kwargs):
-        """ Initialize a client instance
-
-        :param host: The host to connect to (default 127.0.0.1)
-        :param port: The modbus port to connect to (default 502)
-        :param framer: The modbus framer to use (default ModbusSocketFramer)
-        :param timeout: The timeout to use for this socket (default None)
-        """
-        self.host = host
-        self.port = port
-        self.socket = None
-        self.timeout = kwargs.get('timeout', None)
-        BaseModbusClient.__init__(self, framer(ClientDecoder(), self), **kwargs)
-
-    @classmethod
-    def _get_address_family(cls, address):
-        """ A helper method to get the correct address family
-        for a given address.
-
-        :param address: The address to get the af for
-        :returns: AF_INET for ipv4 and AF_INET6 for ipv6
-        """
-        try:
-            _ = socket.inet_pton(socket.AF_INET6, address)
-        except socket.error: # not a valid ipv6 address
-            return socket.AF_INET
-        return socket.AF_INET6
-
-    def connect(self):
-        """ Connect to the modbus tcp server
-
-        :returns: True if connection succeeded, False otherwise
-        """
-        if self.socket:
-            return True
-        try:
-            family = ModbusUdpClient._get_address_family(self.host)
-            self.socket = socket.socket(family, socket.SOCK_DGRAM)
-            self.socket.settimeout(self.timeout)
-        except socket.error as ex:
-            _logger.error('Unable to create udp socket %s' % ex)
-            self.close()
-        return self.socket is not None
-
-    def close(self):
-        """ Closes the underlying socket connection
-        """
-        self.socket = None
-
-    def _send(self, request):
-        """ Sends data on the underlying socket
-
-        :param request: The encoded request to send
-        :return: The number of bytes written
-        """
-        if not self.socket:
-            raise ConnectionException(self.__str__())
-        if request:
-            return self.socket.sendto(request, (self.host, self.port))
-        return 0
-
-    def _recv(self, size):
-        """ Reads data from the underlying descriptor
-
-        :param size: The number of bytes to read
-        :return: The bytes read
-        """
-        if not self.socket:
-            raise ConnectionException(self.__str__())
-        return self.socket.recvfrom(size)[0]
-
-    def is_socket_open(self):
-        return True if self.socket is not None else False
-
-    def __str__(self):
-        """ Builds a string representation of the connection
-
-        :returns: The string representation
-        """
-        return "ModbusUdpClient(%s:%s)" % (self.host, self.port)
-
-    def __repr__(self):
-        return (
-            "<{} at {} socket={self.socket}, ipaddr={self.host}, "
-            "port={self.port}, timeout={self.timeout}>"
-        ).format(self.__class__.__name__, hex(id(self)), self=self)
-
-# --------------------------------------------------------------------------- #
-# Modbus Serial Client Transport Implementation
-# --------------------------------------------------------------------------- #
-
-
-class ModbusSerialClient(BaseModbusClient):
-    """ Implementation of a modbus serial client
-    """
-    state = ModbusTransactionState.IDLE
-    inter_char_timeout = 0
-    silent_interval = 0
-
-    def __init__(self, method='ascii', **kwargs):
-        """ Initialize a serial client instance
-
-        The methods to connect are::
-
-          - ascii
-          - rtu
-          - binary
-
-        :param method: The method to use for connection
-        :param port: The serial port to attach to
-        :param stopbits: The number of stop bits to use
-        :param bytesize: The bytesize of the serial messages
-        :param parity: Which kind of parity to use
-        :param baudrate: The baud rate to use for the serial device
-        :param timeout: The timeout between serial requests (default 3s)
-        :param strict:  Use Inter char timeout for baudrates <= 19200 (adhere
-        to modbus standards)
-        """
-        self.method = method
-        self.socket = None
-        BaseModbusClient.__init__(self, self.__implementation(method, self),
-                                  **kwargs)
-
-        self.port = kwargs.get('port', 0)
-        self.stopbits = kwargs.get('stopbits', Defaults.Stopbits)
-        self.bytesize = kwargs.get('bytesize', Defaults.Bytesize)
-        self.parity = kwargs.get('parity',   Defaults.Parity)
-        self.baudrate = kwargs.get('baudrate', Defaults.Baudrate)
-        self.timeout = kwargs.get('timeout',  Defaults.Timeout)
-        self._strict = kwargs.get("strict", True)
-        self.last_frame_end = None
-        if self.method == "rtu":
-            if self.baudrate > 19200:
-                self.silent_interval = 1.75 / 1000  # ms
-            else:
-                self._t0 = float((1 + 8 + 2)) / self.baudrate
-                self.inter_char_timeout = 1.5 * self._t0
-                self.silent_interval = 3.5 * self._t0
-            self.silent_interval = round(self.silent_interval, 6)
-
-    @staticmethod
-    def __implementation(method, client):
-        """ Returns the requested framer
-
-        :method: The serial framer to instantiate
-        :returns: The requested serial framer
-        """
-        method = method.lower()
-        if method == 'ascii':
-            return ModbusAsciiFramer(ClientDecoder(), client)
-        elif method == 'rtu':
-            return ModbusRtuFramer(ClientDecoder(), client)
-        elif method == 'binary':
-            return ModbusBinaryFramer(ClientDecoder(), client)
-        elif method == 'socket':
-            return ModbusSocketFramer(ClientDecoder(), client)
-        raise ParameterException("Invalid framer method requested")
-
-    def connect(self):
-        """ Connect to the modbus serial server
-
-        :returns: True if connection succeeded, False otherwise
-        """
-        if self.socket:
-            return True
-        try:
-            self.socket = serial.Serial(port=self.port,
-                                        timeout=self.timeout,
-                                        bytesize=self.bytesize,
-                                        stopbits=self.stopbits,
-                                        baudrate=self.baudrate,
-                                        parity=self.parity)
-            if self.method == "rtu":
-                if self._strict:
-                    self.socket.interCharTimeout = self.inter_char_timeout
-                self.last_frame_end = None
-        except serial.SerialException as msg:
-            _logger.error(msg)
-            self.close()
-        return self.socket is not None
-
-    def close(self):
-        """ Closes the underlying socket connection
-        """
-        if self.socket:
-            self.socket.close()
-        self.socket = None
-
-    def _in_waiting(self):
-        in_waiting = ("in_waiting" if hasattr(
-            self.socket, "in_waiting") else "inWaiting")
-
-        if in_waiting == "in_waiting":
-            waitingbytes = getattr(self.socket, in_waiting)
-        else:
-            waitingbytes = getattr(self.socket, in_waiting)()
-        return waitingbytes
-
-    def _send(self, request):
-        """ Sends data on the underlying socket
-
-        If receive buffer still holds some data then flush it.
-
-        Sleep if last send finished less than 3.5 character
-        times ago.
-
-        :param request: The encoded request to send
-        :return: The number of bytes written
-        """
-        if not self.socket:
-            raise ConnectionException(self.__str__())
-        if request:
-            try:
-                waitingbytes = self._in_waiting()
-                if waitingbytes:
-                    result = self.socket.read(waitingbytes)
-                    if _logger.isEnabledFor(logging.WARNING):
-                        _logger.warning("Cleanup recv buffer before "
-                                        "send: " + hexlify_packets(result))
-            except NotImplementedError:
-                pass
-
-            size = self.socket.write(request)
-            return size
-        return 0
-
-    def _wait_for_data(self):
-        size = 0
-        more_data = False
-        if self.timeout is not None and self.timeout != 0:
-            condition = partial(lambda start, timeout:
-                                (time.time() - start) <= timeout,
-                                timeout=self.timeout)
-        else:
-            condition = partial(lambda dummy1, dummy2: True, dummy2=None)
-        start = time.time()
-        while condition(start):
-            avaialble = self._in_waiting()
-            if (more_data and not avaialble) or (more_data and avaialble == size):
-                break
-            if avaialble and avaialble != size:
-                more_data = True
-                size = avaialble
-            time.sleep(0.01)
-        return size
-
-    def _recv(self, size):
-        """ Reads data from the underlying descriptor
-
-        :param size: The number of bytes to read
-        :return: The bytes read
-        """
-        if not self.socket:
-            raise ConnectionException(self.__str__())
-        if size is None:
-            size = self._wait_for_data()
-        result = self.socket.read(size)
-        return result
-
-    def is_socket_open(self):
-        if self.socket:
-            if hasattr(self.socket, "is_open"):
-                return self.socket.is_open
-            else:
-                return self.socket.isOpen()
-        return False
-
-    def __str__(self):
-        """ Builds a string representation of the connection
-
-        :returns: The string representation
-        """
-        return "ModbusSerialClient(%s baud[%s])" % (self.method, self.baudrate)
-
-    def __repr__(self):
-        return (
-            "<{} at {} socket={self.socket}, method={self.method}, "
-            "timeout={self.timeout}>"
-        ).format(self.__class__.__name__, hex(id(self)), self=self)
-
-# --------------------------------------------------------------------------- #
-# Exported symbols
-# --------------------------------------------------------------------------- #
-
-
-__all__ = [
-    "ModbusTcpClient", "ModbusUdpClient", "ModbusSerialClient"
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/compat.py b/venv/lib/python3.7/site-packages/pymodbus/compat.py
deleted file mode 100644
index 48920ba..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/compat.py
+++ /dev/null
@@ -1,96 +0,0 @@
-"""
-Python 2.x/3.x Compatibility Layer
--------------------------------------------------
-
-This is mostly based on the jinja2 compat code:
-
-    Some py2/py3 compatibility support based on a stripped down
-    version of six so we don't have to depend on a specific version
-    of it.
-
-    :copyright: Copyright 2013 by the Jinja team, see AUTHORS.
-    :license: BSD, see LICENSE for details.
-"""
-import sys
-import six
-
-# --------------------------------------------------------------------------- #
-# python version checks
-# --------------------------------------------------------------------------- #
-PYTHON_VERSION = sys.version_info
-IS_PYTHON2 = six.PY2
-IS_PYTHON3 = six.PY3
-IS_PYPY = hasattr(sys, 'pypy_translation_info')
-IS_JYTHON = sys.platform.startswith('java')
-
-# --------------------------------------------------------------------------- #
-# python > 3.3 compatibility layer
-# --------------------------------------------------------------------------- #
-# ----------------------------------------------------------------------- #
-# portable builtins
-# ----------------------------------------------------------------------- #
-int2byte = six.int2byte
-unichr = six.unichr
-range_type = six.moves.range
-text_type = six.string_types
-string_types = six.string_types
-iterkeys = six.iterkeys
-itervalues = six.itervalues
-iteritems = six.iteritems
-get_next = six.next
-unicode_string = six.u
-
-NativeStringIO = six.StringIO
-ifilter = six.moves.filter
-imap = six.moves.map
-izip = six.moves.zip
-intern = six.moves.intern
-
-if not IS_PYTHON2:
-    # ----------------------------------------------------------------------- #
-    # module renames
-    # ----------------------------------------------------------------------- #
-    import socketserver
-
-    # ----------------------------------------------------------------------- #
-    # decorators
-    # ----------------------------------------------------------------------- #
-    implements_to_string = lambda x: x
-
-    byte2int = lambda b: b
-    if PYTHON_VERSION >= (3, 4):
-        def is_installed(module):
-            import importlib.util
-            found = importlib.util.find_spec(module)
-            return found
-    else:
-        def is_installed(module):
-            import importlib
-            found = importlib.find_loader(module)
-            return found
-# --------------------------------------------------------------------------- #
-# python > 2.5 compatability layer
-# --------------------------------------------------------------------------- #
-else:
-    byte2int = six.byte2int
-    # ----------------------------------------------------------------------- #
-    # module renames
-
-    # ----------------------------------------------------------------------- #
-    import SocketServer as socketserver
-
-    # ----------------------------------------------------------------------- #
-    # decorators
-    # ----------------------------------------------------------------------- #
-    def implements_to_string(klass):
-        klass.__unicode__ = klass.__str__
-        klass.__str__ = lambda x: x.__unicode__().encode('utf-8')
-        return klass
-
-    def is_installed(module):
-        import imp
-        try:
-            imp.find_module(module)
-            return True
-        except ImportError:
-            return False
\ No newline at end of file
diff --git a/venv/lib/python3.7/site-packages/pymodbus/constants.py b/venv/lib/python3.7/site-packages/pymodbus/constants.py
deleted file mode 100644
index c05f0b5..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/constants.py
+++ /dev/null
@@ -1,251 +0,0 @@
-'''
-Constants For Modbus Server/Client
-----------------------------------
-
-This is the single location for storing default
-values for the servers and clients.
-'''
-from pymodbus.interfaces import Singleton
-
-
-class Defaults(Singleton):
-    ''' A collection of modbus default values
-
-    .. attribute:: Port
-
-       The default modbus tcp server port (502)
-
-    .. attribute:: Retries
-
-       The default number of times a client should retry the given
-       request before failing (3)
-
-    .. attribute:: RetryOnEmpty
-
-       A flag indicating if a transaction should be retried in the
-       case that an empty response is received. This is useful for
-       slow clients that may need more time to process a requst.
-
-    .. attribute:: Timeout
-
-       The default amount of time a client should wait for a request
-       to be processed (3 seconds)
-
-    .. attribute:: Reconnects
-
-       The default number of times a client should attempt to reconnect
-       before deciding the server is down (0)
-
-    .. attribute:: TransactionId
-
-       The starting transaction identifier number (0)
-
-    .. attribute:: ProtocolId
-
-       The modbus protocol id.  Currently this is set to 0 in all
-       but proprietary implementations.
-
-    .. attribute:: UnitId
-
-       The modbus slave addrss.  Currently this is set to 0x00 which
-       means this request should be broadcast to all the slave devices
-       (really means that all the devices should respons).
-
-    .. attribute:: Baudrate
-
-       The speed at which the data is transmitted over the serial line.
-       This defaults to 19200.
-
-    .. attribute:: Parity
-
-       The type of checksum to use to verify data integrity. This can be
-       on of the following::
-
-         - (E)ven - 1 0 1 0 | P(0)
-         - (O)dd  - 1 0 1 0 | P(1)
-         - (N)one - 1 0 1 0 | no parity
-
-       This defaults to (N)one.
-
-    .. attribute:: Bytesize
-
-       The number of bits in a byte of serial data.  This can be one of
-       5, 6, 7, or 8. This defaults to 8.
-
-    .. attribute:: Stopbits
-
-       The number of bits sent after each character in a message to
-       indicate the end of the byte.  This defaults to 1.
-
-    .. attribute:: ZeroMode
-
-       Indicates if the slave datastore should use indexing at 0 or 1.
-       More about this can be read in section 4.4 of the modbus specification.
-
-    .. attribute:: IgnoreMissingSlaves
-
-       In case a request is made to a missing slave, this defines if an error
-       should be returned or simply ignored. This is useful for the case of a
-       serial server emulater where a request to a non-existant slave on a bus
-       will never respond. The client in this case will simply timeout.
-
-    .. attribute:: broadcast_enable
-
-      When False unit_id 0 will be treated as any other unit_id. When True and
-      the unit_id is 0 the server will execute all requests on all server
-      contexts and not respond and the client will skip trying to receive a
-      response. Default value False does not conform to Modbus spec but maintains
-      legacy behavior for existing pymodbus users.
-
-    '''
-    Port                = 502
-    Retries             = 3
-    RetryOnEmpty        = False
-    Timeout             = 3
-    Reconnects          = 0
-    TransactionId       = 0
-    ProtocolId          = 0
-    UnitId              = 0x00
-    Baudrate            = 19200
-    Parity              = 'N'
-    Bytesize            = 8
-    Stopbits            = 1
-    ZeroMode            = False
-    IgnoreMissingSlaves = False
-    ReadSize            = 1024
-    broadcast_enable    = False
-
-class ModbusStatus(Singleton):
-    '''
-    These represent various status codes in the modbus
-    protocol.
-
-    .. attribute:: Waiting
-
-       This indicates that a modbus device is currently
-       waiting for a given request to finish some running task.
-
-    .. attribute:: Ready
-
-       This indicates that a modbus device is currently
-       free to perform the next request task.
-
-    .. attribute:: On
-
-       This indicates that the given modbus entity is on
-
-    .. attribute:: Off
-
-       This indicates that the given modbus entity is off
-
-    .. attribute:: SlaveOn
-
-       This indicates that the given modbus slave is running
-
-    .. attribute:: SlaveOff
-
-       This indicates that the given modbus slave is not running
-    '''
-    Waiting  = 0xffff
-    Ready    = 0x0000
-    On       = 0xff00
-    Off      = 0x0000
-    SlaveOn  = 0xff
-    SlaveOff = 0x00
-
-
-class Endian(Singleton):
-    ''' An enumeration representing the various byte endianess.
-
-    .. attribute:: Auto
-
-       This indicates that the byte order is chosen by the
-       current native environment.
-
-    .. attribute:: Big
-
-       This indicates that the bytes are in little endian format
-
-    .. attribute:: Little
-
-       This indicates that the bytes are in big endian format
-
-    .. note:: I am simply borrowing the format strings from the
-       python struct module for my convenience.
-    '''
-    Auto   = '@'
-    Big    = '>'
-    Little = '<'
-
-
-class ModbusPlusOperation(Singleton):
-    ''' Represents the type of modbus plus request
-
-    .. attribute:: GetStatistics
-
-       Operation requesting that the current modbus plus statistics
-       be returned in the response.
-
-    .. attribute:: ClearStatistics
-
-       Operation requesting that the current modbus plus statistics
-       be cleared and not returned in the response.
-    '''
-    GetStatistics   = 0x0003
-    ClearStatistics = 0x0004
-
-
-class DeviceInformation(Singleton):
-    ''' Represents what type of device information to read
-
-    .. attribute:: Basic
-
-       This is the basic (required) device information to be returned.
-       This includes VendorName, ProductCode, and MajorMinorRevision
-       code.
-
-    .. attribute:: Regular
-
-       In addition to basic data objects, the device provides additional
-       and optinoal identification and description data objects. All of
-       the objects of this category are defined in the standard but their
-       implementation is optional.
-
-    .. attribute:: Extended
-
-       In addition to regular data objects, the device provides additional
-       and optional identification and description private data about the
-       physical device itself. All of these data are device dependent.
-
-    .. attribute:: Specific
-
-       Request to return a single data object.
-    '''
-    Basic    = 0x01
-    Regular  = 0x02
-    Extended = 0x03
-    Specific = 0x04
-
-
-class MoreData(Singleton):
-    ''' Represents the more follows condition
-
-    .. attribute:: Nothing
-
-       This indiates that no more objects are going to be returned.
-
-    .. attribute:: KeepReading
-
-       This indicates that there are more objects to be returned.
-    '''
-    Nothing     = 0x00
-    KeepReading = 0xFF
-
-#---------------------------------------------------------------------------#
-# Exported Identifiers
-#---------------------------------------------------------------------------#
-__all__ = [
-    "Defaults", "ModbusStatus", "Endian",
-    "ModbusPlusOperation",
-    "DeviceInformation", "MoreData",
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/datastore/__init__.py b/venv/lib/python3.7/site-packages/pymodbus/datastore/__init__.py
deleted file mode 100644
index a981d4b..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/datastore/__init__.py
+++ /dev/null
@@ -1,12 +0,0 @@
-from pymodbus.datastore.store import ModbusSequentialDataBlock
-from pymodbus.datastore.store import ModbusSparseDataBlock
-from pymodbus.datastore.context import ModbusSlaveContext
-from pymodbus.datastore.context import ModbusServerContext
-
-#---------------------------------------------------------------------------#
-# Exported symbols
-#---------------------------------------------------------------------------#
-__all__ = [
-    "ModbusSequentialDataBlock", "ModbusSparseDataBlock",
-    "ModbusSlaveContext", "ModbusServerContext",
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/datastore/context.py b/venv/lib/python3.7/site-packages/pymodbus/datastore/context.py
deleted file mode 100644
index ab87ffb..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/datastore/context.py
+++ /dev/null
@@ -1,184 +0,0 @@
-from pymodbus.exceptions import ParameterException, NoSuchSlaveException
-from pymodbus.interfaces import IModbusSlaveContext
-from pymodbus.datastore.store import ModbusSequentialDataBlock
-from pymodbus.constants import Defaults
-from pymodbus.compat import iteritems, itervalues
-
-#---------------------------------------------------------------------------#
-# Logging
-#---------------------------------------------------------------------------#
-import logging
-_logger = logging.getLogger(__name__)
-
-
-#---------------------------------------------------------------------------#
-# Slave Contexts
-#---------------------------------------------------------------------------#
-class ModbusSlaveContext(IModbusSlaveContext):
-    '''
-    This creates a modbus data model with each data access
-    stored in its own personal block
-    '''
-
-    def __init__(self, *args, **kwargs):
-        ''' Initializes the datastores, defaults to fully populated
-        sequential data blocks if none are passed in.
-
-        :param kwargs: Each element is a ModbusDataBlock
-
-            'di' - Discrete Inputs initializer
-            'co' - Coils initializer
-            'hr' - Holding Register initializer
-            'ir' - Input Registers iniatializer
-        '''
-        self.store = dict()
-        self.store['d'] = kwargs.get('di', ModbusSequentialDataBlock.create())
-        self.store['c'] = kwargs.get('co', ModbusSequentialDataBlock.create())
-        self.store['i'] = kwargs.get('ir', ModbusSequentialDataBlock.create())
-        self.store['h'] = kwargs.get('hr', ModbusSequentialDataBlock.create())
-        self.zero_mode = kwargs.get('zero_mode', Defaults.ZeroMode)
-
-    def __str__(self):
-        ''' Returns a string representation of the context
-
-        :returns: A string representation of the context
-        '''
-        return "Modbus Slave Context"
-
-    def reset(self):
-        ''' Resets all the datastores to their default values '''
-        for datastore in itervalues(self.store):
-            datastore.reset()
-
-    def validate(self, fx, address, count=1):
-        ''' Validates the request to make sure it is in range
-
-        :param fx: The function we are working with
-        :param address: The starting address
-        :param count: The number of values to test
-        :returns: True if the request in within range, False otherwise
-        '''
-        if not self.zero_mode:
-            address = address + 1
-        _logger.debug("validate: fc-[%d] address-%d: count-%d" % (fx, address,
-                                                                  count))
-        return self.store[self.decode(fx)].validate(address, count)
-
-    def getValues(self, fx, address, count=1):
-        ''' Get `count` values from datastore
-
-        :param fx: The function we are working with
-        :param address: The starting address
-        :param count: The number of values to retrieve
-        :returns: The requested values from a:a+c
-        '''
-        if not self.zero_mode:
-            address = address + 1
-        _logger.debug("getValues fc-[%d] address-%d: count-%d" % (fx, address,
-                                                                  count))
-        return self.store[self.decode(fx)].getValues(address, count)
-
-    def setValues(self, fx, address, values):
-        ''' Sets the datastore with the supplied values
-
-        :param fx: The function we are working with
-        :param address: The starting address
-        :param values: The new values to be set
-        '''
-        if not self.zero_mode:
-            address = address + 1
-        _logger.debug("setValues[%d] %d:%d" % (fx, address, len(values)))
-        self.store[self.decode(fx)].setValues(address, values)
-
-    def register(self, fc, fx, datablock=None):
-        """
-        Registers a datablock with the slave context
-        :param fc: function code (int)
-        :param fx: string representation of function code (e.g 'cf' )
-        :param datablock: datablock to associate with this function code
-        :return:
-        """
-        self.store[fx] = datablock or ModbusSequentialDataBlock.create()
-        self._IModbusSlaveContext__fx_mapper[fc] = fx
-
-
-class ModbusServerContext(object):
-    ''' This represents a master collection of slave contexts.
-    If single is set to true, it will be treated as a single
-    context so every unit-id returns the same context. If single
-    is set to false, it will be interpreted as a collection of
-    slave contexts.
-    '''
-
-    def __init__(self, slaves=None, single=True):
-        ''' Initializes a new instance of a modbus server context.
-
-        :param slaves: A dictionary of client contexts
-        :param single: Set to true to treat this as a single context
-        '''
-        self.single = single
-        self._slaves = slaves or {}
-        if self.single:
-            self._slaves = {Defaults.UnitId: self._slaves}
-
-    def __iter__(self):
-        ''' Iterater over the current collection of slave
-        contexts.
-
-        :returns: An iterator over the slave contexts
-        '''
-        return iteritems(self._slaves)
-
-    def __contains__(self, slave):
-        ''' Check if the given slave is in this list
-
-        :param slave: slave The slave to check for existance
-        :returns: True if the slave exists, False otherwise
-        '''
-        if self.single and self._slaves:
-            return True
-        else:
-            return slave in self._slaves
-
-    def __setitem__(self, slave, context):
-        ''' Used to set a new slave context
-
-        :param slave: The slave context to set
-        :param context: The new context to set for this slave
-        '''
-        if self.single:
-            slave = Defaults.UnitId
-        if 0xf7 >= slave >= 0x00:
-            self._slaves[slave] = context
-        else:
-            raise NoSuchSlaveException('slave index :{} '
-                                       'out of range'.format(slave))
-
-    def __delitem__(self, slave):
-        ''' Wrapper used to access the slave context
-
-        :param slave: The slave context to remove
-        '''
-        if not self.single and (0xf7 >= slave >= 0x00):
-            del self._slaves[slave]
-        else:
-            raise NoSuchSlaveException('slave index: {} '
-                                       'out of range'.format(slave))
-
-    def __getitem__(self, slave):
-        ''' Used to get access to a slave context
-
-        :param slave: The slave context to get
-        :returns: The requested slave context
-        '''
-        if self.single:
-            slave = Defaults.UnitId
-        if slave in self._slaves:
-            return self._slaves.get(slave)
-        else:
-            raise NoSuchSlaveException("slave - {} does not exist, "
-                                       "or is out of range".format(slave))
-
-    def slaves(self):
-        # Python3 now returns keys() as iterable
-        return list(self._slaves.keys())
diff --git a/venv/lib/python3.7/site-packages/pymodbus/datastore/database/__init__.py b/venv/lib/python3.7/site-packages/pymodbus/datastore/database/__init__.py
deleted file mode 100644
index dbb2609..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/datastore/database/__init__.py
+++ /dev/null
@@ -1,7 +0,0 @@
-from pymodbus.datastore.database.sql_datastore import SqlSlaveContext
-from pymodbus.datastore.database.redis_datastore import RedisSlaveContext
-
-#---------------------------------------------------------------------------#
-# Exported symbols
-#---------------------------------------------------------------------------#
-__all__ = ["SqlSlaveContext", "RedisSlaveContext"]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/datastore/database/redis_datastore.py b/venv/lib/python3.7/site-packages/pymodbus/datastore/database/redis_datastore.py
deleted file mode 100644
index 98bf5be..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/datastore/database/redis_datastore.py
+++ /dev/null
@@ -1,243 +0,0 @@
-import redis
-from pymodbus.interfaces import IModbusSlaveContext
-from pymodbus.utilities import pack_bitstring, unpack_bitstring
-
-#---------------------------------------------------------------------------#
-# Logging
-#---------------------------------------------------------------------------#
-import logging
-_logger = logging.getLogger(__name__)
-
-
-#---------------------------------------------------------------------------#
-# Context
-#---------------------------------------------------------------------------#
-class RedisSlaveContext(IModbusSlaveContext):
-    '''
-    This is a modbus slave context using redis as a backing
-    store.
-    '''
-
-    def __init__(self, **kwargs):
-        ''' Initializes the datastores
-
-        :param host: The host to connect to
-        :param port: The port to connect to
-        :param prefix: A prefix for the keys
-        '''
-        host = kwargs.get('host', 'localhost')
-        port = kwargs.get('port', 6379)
-        self.prefix = kwargs.get('prefix', 'pymodbus')
-        self.client = kwargs.get('client', redis.Redis(host=host, port=port))
-        self._build_mapping()
-
-    def __str__(self):
-        ''' Returns a string representation of the context
-
-        :returns: A string representation of the context
-        '''
-        return "Redis Slave Context %s" % self.client
-
-    def reset(self):
-        ''' Resets all the datastores to their default values '''
-        self.client.flushall()
-
-    def validate(self, fx, address, count=1):
-        ''' Validates the request to make sure it is in range
-
-        :param fx: The function we are working with
-        :param address: The starting address
-        :param count: The number of values to test
-        :returns: True if the request in within range, False otherwise
-        '''
-        address = address + 1  # section 4.4 of specification
-        _logger.debug("validate[%d] %d:%d" % (fx, address, count))
-        return self._val_callbacks[self.decode(fx)](address, count)
-
-    def getValues(self, fx, address, count=1):
-        ''' Get `count` values from datastore
-
-        :param fx: The function we are working with
-        :param address: The starting address
-        :param count: The number of values to retrieve
-        :returns: The requested values from a:a+c
-        '''
-        address = address + 1  # section 4.4 of specification
-        _logger.debug("getValues[%d] %d:%d" % (fx, address, count))
-        return self._get_callbacks[self.decode(fx)](address, count)
-
-    def setValues(self, fx, address, values):
-        ''' Sets the datastore with the supplied values
-
-        :param fx: The function we are working with
-        :param address: The starting address
-        :param values: The new values to be set
-        '''
-        address = address + 1  # section 4.4 of specification
-        _logger.debug("setValues[%d] %d:%d" % (fx, address, len(values)))
-        self._set_callbacks[self.decode(fx)](address, values)
-
-    #--------------------------------------------------------------------------#
-    # Redis Helper Methods
-    #--------------------------------------------------------------------------#
-    def _get_prefix(self, key):
-        ''' This is a helper to abstract getting bit values
-
-        :param key: The key prefix to use
-        :returns: The key prefix to redis
-        '''
-        return "%s:%s" % (self.prefix, key)
-
-    def _build_mapping(self):
-        '''
-        A quick helper method to build the function
-        code mapper.
-        '''
-        self._val_callbacks = {
-            'd': lambda o, c: self._val_bit('d', o, c),
-            'c': lambda o, c: self._val_bit('c', o, c),
-            'h': lambda o, c: self._val_reg('h', o, c),
-            'i': lambda o, c: self._val_reg('i', o, c),
-        }
-        self._get_callbacks = {
-            'd': lambda o, c: self._get_bit('d', o, c),
-            'c': lambda o, c: self._get_bit('c', o, c),
-            'h': lambda o, c: self._get_reg('h', o, c),
-            'i': lambda o, c: self._get_reg('i', o, c),
-        }
-        self._set_callbacks = {
-            'd': lambda o, v: self._set_bit('d', o, v),
-            'c': lambda o, v: self._set_bit('c', o, v),
-            'h': lambda o, v: self._set_reg('h', o, v),
-            'i': lambda o, v: self._set_reg('i', o, v),
-        }
-
-    #--------------------------------------------------------------------------#
-    # Redis discrete implementation
-    #--------------------------------------------------------------------------#
-    _bit_size = 16
-    _bit_default = '\x00' * (_bit_size % 8)
-
-    def _get_bit_values(self, key, offset, count):
-        ''' This is a helper to abstract getting bit values
-
-        :param key: The key prefix to use
-        :param offset: The address offset to start at
-        :param count: The number of bits to read
-        '''
-        key = self._get_prefix(key)
-        s = divmod(offset, self._bit_size)[0]
-        e = divmod(offset + count, self._bit_size)[0]
-
-        request = ('%s:%s' % (key, v) for v in range(s, e + 1))
-        response = self.client.mget(request)
-        return response
-
-    def _val_bit(self, key, offset, count):
-        ''' Validates that the given range is currently set in redis.
-        If any of the keys return None, then it is invalid.
-
-        :param key: The key prefix to use
-        :param offset: The address offset to start at
-        :param count: The number of bits to read
-        '''
-        response = self._get_bit_values(key, offset, count)
-        return True if None not in response else False
-
-    def _get_bit(self, key, offset, count):
-        '''
-
-        :param key: The key prefix to use
-        :param offset: The address offset to start at
-        :param count: The number of bits to read
-        '''
-        response = self._get_bit_values(key, offset, count)
-        response = (r or self._bit_default for r in response)
-        result = ''.join(response)
-        result = unpack_bitstring(result)
-        return result[offset:offset + count]
-
-    def _set_bit(self, key, offset, values):
-        '''
-
-        :param key: The key prefix to use
-        :param offset: The address offset to start at
-        :param values: The values to set
-        '''
-        count = len(values)
-        s = divmod(offset, self._bit_size)[0]
-        e = divmod(offset + count, self._bit_size)[0]
-        value = pack_bitstring(values)
-
-        current = self._get_bit_values(key, offset, count)
-        current = (r or self._bit_default for r in current)
-        current = ''.join(current)
-        current = current[0:offset] + value.decode('utf-8') + current[offset + count:]
-        final = (current[s:s + self._bit_size] for s in range(0, count, self._bit_size))
-
-        key = self._get_prefix(key)
-        request = ('%s:%s' % (key, v) for v in range(s, e + 1))
-        request = dict(zip(request, final))
-        self.client.mset(request)
-
-    #--------------------------------------------------------------------------#
-    # Redis register implementation
-    #--------------------------------------------------------------------------#
-    _reg_size = 16
-    _reg_default = '\x00' * (_reg_size % 8)
-
-    def _get_reg_values(self, key, offset, count):
-        ''' This is a helper to abstract getting register values
-
-        :param key: The key prefix to use
-        :param offset: The address offset to start at
-        :param count: The number of bits to read
-        '''
-        key = self._get_prefix(key)
-        #s = divmod(offset, self.__reg_size)[0]
-        #e = divmod(offset+count, self.__reg_size)[0]
-
-        #request  = ('%s:%s' % (key, v) for v in range(s, e + 1))
-        request = ('%s:%s' % (key, v) for v in range(offset, count + 1))
-        response = self.client.mget(request)
-        return response
-
-    def _val_reg(self, key, offset, count):
-        ''' Validates that the given range is currently set in redis.
-        If any of the keys return None, then it is invalid.
-
-        :param key: The key prefix to use
-        :param offset: The address offset to start at
-        :param count: The number of bits to read
-        '''
-        response = self._get_reg_values(key, offset, count)
-        return None not in response
-
-    def _get_reg(self, key, offset, count):
-        '''
-
-        :param key: The key prefix to use
-        :param offset: The address offset to start at
-        :param count: The number of bits to read
-        '''
-        response = self._get_reg_values(key, offset, count)
-        response = [r or self._reg_default for r in response]
-        return response[offset:offset + count]
-
-    def _set_reg(self, key, offset, values):
-        '''
-
-        :param key: The key prefix to use
-        :param offset: The address offset to start at
-        :param values: The values to set
-        '''
-        count = len(values)
-        #s = divmod(offset, self.__reg_size)
-        #e = divmod(offset+count, self.__reg_size)
-
-        #current = self.__get_reg_values(key, offset, count)
-
-        key = self._get_prefix(key)
-        request = ('%s:%s' % (key, v) for v in range(offset, count + 1))
-        request = dict(zip(request, values))
-        self.client.mset(request)
diff --git a/venv/lib/python3.7/site-packages/pymodbus/datastore/database/sql_datastore.py b/venv/lib/python3.7/site-packages/pymodbus/datastore/database/sql_datastore.py
deleted file mode 100644
index 769dab7..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/datastore/database/sql_datastore.py
+++ /dev/null
@@ -1,184 +0,0 @@
-import sqlalchemy
-import sqlalchemy.types as sqltypes
-from sqlalchemy.sql import and_
-from sqlalchemy.schema import UniqueConstraint
-from sqlalchemy.sql.expression import bindparam
-
-from pymodbus.exceptions import NotImplementedException
-from pymodbus.interfaces import IModbusSlaveContext
-
-# --------------------------------------------------------------------------- #
-# Logging
-# --------------------------------------------------------------------------- #
-import logging
-_logger = logging.getLogger(__name__)
-
-
-# --------------------------------------------------------------------------- #
-# Context
-# --------------------------------------------------------------------------- #
-class SqlSlaveContext(IModbusSlaveContext):
-    """
-    This creates a modbus data model with each data access
-    stored in its own personal block
-    """
-
-    def __init__(self, *args, **kwargs):
-        """ Initializes the datastores
-
-        :param kwargs: Each element is a ModbusDataBlock
-        """
-        self.table = kwargs.get('table', 'pymodbus')
-        self.database = kwargs.get('database', 'sqlite:///pymodbus.db')
-        self._db_create(self.table, self.database)
-
-    def __str__(self):
-        """ Returns a string representation of the context
-
-        :returns: A string representation of the context
-        """
-        return "Modbus Slave Context"
-
-    def reset(self):
-        """ Resets all the datastores to their default values """
-        self._metadata.drop_all()
-        self._db_create(self.table, self.database)
-
-    def validate(self, fx, address, count=1):
-        """ Validates the request to make sure it is in range
-
-        :param fx: The function we are working with
-        :param address: The starting address
-        :param count: The number of values to test
-        :returns: True if the request in within range, False otherwise
-        """
-        address = address + 1  # section 4.4 of specification
-        _logger.debug("validate[%d] %d:%d" % (fx, address, count))
-        return self._validate(self.decode(fx), address, count)
-
-    def getValues(self, fx, address, count=1):
-        """ Get `count` values from datastore
-
-        :param fx: The function we are working with
-        :param address: The starting address
-        :param count: The number of values to retrieve
-        :returns: The requested values from a:a+c
-        """
-        address = address + 1  # section 4.4 of specification
-        _logger.debug("get-values[%d] %d:%d" % (fx, address, count))
-        return self._get(self.decode(fx), address, count)
-
-    def setValues(self, fx, address, values, update=True):
-        """ Sets the datastore with the supplied values
-
-        :param fx: The function we are working with
-        :param address: The starting address
-        :param values: The new values to be set
-        :param update: Update existing register in the db
-        """
-        address = address + 1  # section 4.4 of specification
-        _logger.debug("set-values[%d] %d:%d" % (fx, address, len(values)))
-        if update:
-            self._update(self.decode(fx), address, values)
-        else:
-            self._set(self.decode(fx), address, values)
-
-    # ----------------------------------------------------------------------- #
-    # Sqlite Helper Methods
-    # ----------------------------------------------------------------------- #
-    def _db_create(self, table, database):
-        """ A helper method to initialize the database and handles
-
-        :param table: The table name to create
-        :param database: The database uri to use
-        """
-        self._engine = sqlalchemy.create_engine(database, echo=False)
-        self._metadata = sqlalchemy.MetaData(self._engine)
-        self._table = sqlalchemy.Table(table, self._metadata,
-                                       sqlalchemy.Column('type', sqltypes.String(1)),
-                                       sqlalchemy.Column('index', sqltypes.Integer),
-                                       sqlalchemy.Column('value', sqltypes.Integer),
-                                       UniqueConstraint('type', 'index', name='key'))
-        self._table.create(checkfirst=True)
-        self._connection = self._engine.connect()
-
-    def _get(self, type, offset, count):
-        """
-        :param type: The key prefix to use
-        :param offset: The address offset to start at
-        :param count: The number of bits to read
-        :returns: The resulting values
-        """
-        query = self._table.select(and_(
-            self._table.c.type == type,
-            self._table.c.index >= offset,
-            self._table.c.index <= offset + count - 1)
-        )
-        query = query.order_by(self._table.c.index.asc())
-        result = self._connection.execute(query).fetchall()
-        return [row.value for row in result]
-
-    def _build_set(self, type, offset, values, prefix=''):
-        """ A helper method to generate the sql update context
-
-        :param type: The key prefix to use
-        :param offset: The address offset to start at
-        :param values: The values to set
-        :param prefix: Prefix fields index and type, defaults to empty string
-        """
-        result = []
-        for index, value in enumerate(values):
-            result.append({
-                prefix + 'type': type,
-                prefix + 'index': offset + index,
-                'value': value
-            })
-        return result
-
-    def _check(self, type, offset, values):
-        result = self._get(type, offset, count=1)
-        return False if len(result) > 0 else True
-
-    def _set(self, type, offset, values):
-        """
-
-        :param key: The type prefix to use
-        :param offset: The address offset to start at
-        :param values: The values to set
-        """
-        if self._check(type, offset, values):
-            context = self._build_set(type, offset, values)
-            query = self._table.insert()
-            result = self._connection.execute(query, context)
-            return result.rowcount == len(values)
-        else:
-            return False
-
-    def _update(self, type, offset, values):
-        """
-
-        :param type: The type prefix to use
-        :param offset: The address offset to start at
-        :param values: The values to set
-        """
-        context = self._build_set(type, offset, values, prefix='x_')
-        query = self._table.update().values(value='value')
-        query = query.where(and_(
-            self._table.c.type == bindparam('x_type'),
-            self._table.c.index == bindparam('x_index')))
-        result = self._connection.execute(query, context)
-        return result.rowcount == len(values)
-
-    def _validate(self, type, offset, count):
-        """
-        :param key: The key prefix to use
-        :param offset: The address offset to start at
-        :param count: The number of bits to read
-        :returns: The result of the validation
-        """
-        query = self._table.select(and_(
-            self._table.c.type == type,
-            self._table.c.index >= offset,
-            self._table.c.index <= offset + count - 1))
-        result = self._connection.execute(query).fetchall()
-        return len(result) == count
diff --git a/venv/lib/python3.7/site-packages/pymodbus/datastore/remote.py b/venv/lib/python3.7/site-packages/pymodbus/datastore/remote.py
deleted file mode 100644
index 17161cc..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/datastore/remote.py
+++ /dev/null
@@ -1,108 +0,0 @@
-from pymodbus.exceptions import NotImplementedException
-from pymodbus.interfaces import IModbusSlaveContext
-
-#---------------------------------------------------------------------------#
-# Logging
-#---------------------------------------------------------------------------#
-import logging
-_logger = logging.getLogger(__name__)
-
-
-#---------------------------------------------------------------------------#
-# Context
-#---------------------------------------------------------------------------#
-class RemoteSlaveContext(IModbusSlaveContext):
-    ''' TODO
-    This creates a modbus data model that connects to
-    a remote device (depending on the client used)
-    '''
-
-    def __init__(self, client, unit=None):
-        ''' Initializes the datastores
-
-        :param client: The client to retrieve values with
-        :param unit: Unit ID of the remote slave
-        '''
-        self._client = client
-        self.unit = unit
-        self.__build_mapping()
-
-    def reset(self):
-        ''' Resets all the datastores to their default values '''
-        raise NotImplementedException()
-
-    def validate(self, fx, address, count=1):
-        ''' Validates the request to make sure it is in range
-
-        :param fx: The function we are working with
-        :param address: The starting address
-        :param count: The number of values to test
-        :returns: True if the request in within range, False otherwise
-        '''
-        _logger.debug("validate[%d] %d:%d" % (fx, address, count))
-        result = self.__get_callbacks[self.decode(fx)](address, count)
-        return not result.isError()
-
-    def getValues(self, fx, address, count=1):
-        ''' Get `count` values from datastore
-
-        :param fx: The function we are working with
-        :param address: The starting address
-        :param count: The number of values to retrieve
-        :returns: The requested values from a:a+c
-        '''
-        # TODO deal with deferreds
-        _logger.debug("get values[%d] %d:%d" % (fx, address, count))
-        result = self.__get_callbacks[self.decode(fx)](address, count)
-        return self.__extract_result(self.decode(fx), result)
-
-    def setValues(self, fx, address, values):
-        ''' Sets the datastore with the supplied values
-
-        :param fx: The function we are working with
-        :param address: The starting address
-        :param values: The new values to be set
-        '''
-        # TODO deal with deferreds
-        _logger.debug("set values[%d] %d:%d" % (fx, address, len(values)))
-        self.__set_callbacks[self.decode(fx)](address, values)
-
-    def __str__(self):
-        ''' Returns a string representation of the context
-
-        :returns: A string representation of the context
-        '''
-        return "Remote Slave Context(%s)" % self._client
-
-    def __build_mapping(self):
-        '''
-        A quick helper method to build the function
-        code mapper.
-        '''
-        kwargs = {}
-        if self.unit:
-            kwargs["unit"] = self.unit
-        self.__get_callbacks = {
-            'd': lambda a, c: self._client.read_discrete_inputs(a, c, **kwargs),
-            'c': lambda a, c: self._client.read_coils(a, c, **kwargs),
-            'h': lambda a, c: self._client.read_holding_registers(a, c, **kwargs),
-            'i': lambda a, c: self._client.read_input_registers(a, c, **kwargs),
-        }
-        self.__set_callbacks = {
-            'd': lambda a, v: self._client.write_coils(a, v, **kwargs),
-            'c': lambda a, v: self._client.write_coils(a, v, **kwargs),
-            'h': lambda a, v: self._client.write_registers(a, v, **kwargs),
-            'i': lambda a, v: self._client.write_registers(a, v, **kwargs),
-        }
-
-    def __extract_result(self, fx, result):
-        ''' A helper method to extract the values out of
-        a response.  TODO make this consistent (values?)
-        '''
-        if not result.isError():
-            if fx in ['d', 'c']:
-                return result.bits
-            if fx in ['h', 'i']:
-                return result.registers
-        else:
-            return result
diff --git a/venv/lib/python3.7/site-packages/pymodbus/datastore/store.py b/venv/lib/python3.7/site-packages/pymodbus/datastore/store.py
deleted file mode 100644
index 2d99f1a..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/datastore/store.py
+++ /dev/null
@@ -1,255 +0,0 @@
-"""
-Modbus Server Datastore
--------------------------
-
-For each server, you will create a ModbusServerContext and pass
-in the default address space for each data access.  The class
-will create and manage the data.
-
-Further modification of said data accesses should be performed
-with [get,set][access]Values(address, count)
-
-Datastore Implementation
--------------------------
-
-There are two ways that the server datastore can be implemented.
-The first is a complete range from 'address' start to 'count'
-number of indecies.  This can be thought of as a straight array::
-
-    data = range(1, 1 + count)
-    [1,2,3,...,count]
-
-The other way that the datastore can be implemented (and how
-many devices implement it) is a associate-array::
-
-    data = {1:'1', 3:'3', ..., count:'count'}
-    [1,3,...,count]
-
-The difference between the two is that the latter will allow
-arbitrary gaps in its datastore while the former will not.
-This is seen quite commonly in some modbus implementations.
-What follows is a clear example from the field:
-
-Say a company makes two devices to monitor power usage on a rack.
-One works with three-phase and the other with a single phase. The
-company will dictate a modbus data mapping such that registers::
-
-    n:      phase 1 power
-    n+1:    phase 2 power
-    n+2:    phase 3 power
-
-Using this, layout, the first device will implement n, n+1, and n+2,
-however, the second device may set the latter two values to 0 or
-will simply not implmented the registers thus causing a single read
-or a range read to fail.
-
-I have both methods implemented, and leave it up to the user to change
-based on their preference.
-"""
-from pymodbus.exceptions import NotImplementedException, ParameterException
-from pymodbus.compat import iteritems, iterkeys, itervalues, get_next
-
-#---------------------------------------------------------------------------#
-# Logging
-#---------------------------------------------------------------------------#
-import logging
-_logger = logging.getLogger(__name__)
-
-
-#---------------------------------------------------------------------------#
-# Datablock Storage
-#---------------------------------------------------------------------------#
-class BaseModbusDataBlock(object):
-    '''
-    Base class for a modbus datastore
-
-    Derived classes must create the following fields:
-            @address The starting address point
-            @defult_value The default value of the datastore
-            @values The actual datastore values
-
-    Derived classes must implemented the following methods:
-            validate(self, address, count=1)
-            getValues(self, address, count=1)
-            setValues(self, address, values)
-    '''
-
-    def default(self, count, value=False):
-        ''' Used to initialize a store to one value
-
-        :param count: The number of fields to set
-        :param value: The default value to set to the fields
-        '''
-        self.default_value = value
-        self.values = [self.default_value] * count
-        self.address = 0x00
-
-    def reset(self):
-        ''' Resets the datastore to the initialized default value '''
-        self.values = [self.default_value] * len(self.values)
-
-    def validate(self, address, count=1):
-        ''' Checks to see if the request is in range
-
-        :param address: The starting address
-        :param count: The number of values to test for
-        :returns: True if the request in within range, False otherwise
-        '''
-        raise NotImplementedException("Datastore Address Check")
-
-    def getValues(self, address, count=1):
-        ''' Returns the requested values from the datastore
-
-        :param address: The starting address
-        :param count: The number of values to retrieve
-        :returns: The requested values from a:a+c
-        '''
-        raise NotImplementedException("Datastore Value Retrieve")
-
-    def setValues(self, address, values):
-        ''' Returns the requested values from the datastore
-
-        :param address: The starting address
-        :param values: The values to store
-        '''
-        raise NotImplementedException("Datastore Value Retrieve")
-
-    def __str__(self):
-        ''' Build a representation of the datastore
-
-        :returns: A string representation of the datastore
-        '''
-        return "DataStore(%d, %d)" % (len(self.values), self.default_value)
-
-    def __iter__(self):
-        ''' Iterater over the data block data
-
-        :returns: An iterator of the data block data
-        '''
-        if isinstance(self.values, dict):
-            return iteritems(self.values)
-        return enumerate(self.values, self.address)
-
-
-class ModbusSequentialDataBlock(BaseModbusDataBlock):
-    ''' Creates a sequential modbus datastore '''
-
-    def __init__(self, address, values):
-        ''' Initializes the datastore
-
-        :param address: The starting address of the datastore
-        :param values: Either a list or a dictionary of values
-        '''
-        self.address = address
-        if hasattr(values, '__iter__'):
-            self.values = list(values)
-        else:
-            self.values = [values]
-        self.default_value = self.values[0].__class__()
-
-    @classmethod
-    def create(klass):
-        ''' Factory method to create a datastore with the
-        full address space initialized to 0x00
-
-        :returns: An initialized datastore
-        '''
-        return klass(0x00, [0x00] * 65536)
-
-    def validate(self, address, count=1):
-        ''' Checks to see if the request is in range
-
-        :param address: The starting address
-        :param count: The number of values to test for
-        :returns: True if the request in within range, False otherwise
-        '''
-        result  = (self.address <= address)
-        result &= ((self.address + len(self.values)) >= (address + count))
-        return result
-
-    def getValues(self, address, count=1):
-        ''' Returns the requested values of the datastore
-
-        :param address: The starting address
-        :param count: The number of values to retrieve
-        :returns: The requested values from a:a+c
-        '''
-        start = address - self.address
-        return self.values[start:start + count]
-
-    def setValues(self, address, values):
-        ''' Sets the requested values of the datastore
-
-        :param address: The starting address
-        :param values: The new values to be set
-        '''
-        if not isinstance(values, list):
-            values = [values]
-        start = address - self.address
-        self.values[start:start + len(values)] = values
-
-
-class ModbusSparseDataBlock(BaseModbusDataBlock):
-    ''' Creates a sparse modbus datastore '''
-
-    def __init__(self, values):
-        ''' Initializes the datastore
-
-        Using the input values we create the default
-        datastore value and the starting address
-
-        :param values: Either a list or a dictionary of values
-        '''
-        if isinstance(values, dict):
-            self.values = values
-        elif hasattr(values, '__iter__'):
-            self.values = dict(enumerate(values))
-        else: raise ParameterException(
-            "Values for datastore must be a list or dictionary")
-        self.default_value = get_next(itervalues(self.values)).__class__()
-        self.address = get_next(iterkeys(self.values))
-
-    @classmethod
-    def create(klass):
-        ''' Factory method to create a datastore with the
-        full address space initialized to 0x00
-
-        :returns: An initialized datastore
-        '''
-        return klass([0x00] * 65536)
-
-    def validate(self, address, count=1):
-        ''' Checks to see if the request is in range
-
-        :param address: The starting address
-        :param count: The number of values to test for
-        :returns: True if the request in within range, False otherwise
-        '''
-        if count == 0:
-            return False
-        handle = set(range(address, address + count))
-        return handle.issubset(set(iterkeys(self.values)))
-
-    def getValues(self, address, count=1):
-        ''' Returns the requested values of the datastore
-
-        :param address: The starting address
-        :param count: The number of values to retrieve
-        :returns: The requested values from a:a+c
-        '''
-        return [self.values[i] for i in range(address, address + count)]
-
-    def setValues(self, address, values):
-        ''' Sets the requested values of the datastore
-
-        :param address: The starting address
-        :param values: The new values to be set
-        '''
-        if isinstance(values, dict):
-            for idx, val in iteritems(values):
-                self.values[idx] = val
-        else:
-            if not isinstance(values, list):
-                values = [values]
-            for idx, val in enumerate(values):
-                self.values[address + idx] = val
diff --git a/venv/lib/python3.7/site-packages/pymodbus/device.py b/venv/lib/python3.7/site-packages/pymodbus/device.py
deleted file mode 100644
index 28256a7..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/device.py
+++ /dev/null
@@ -1,626 +0,0 @@
-"""
-Modbus Device Controller
--------------------------
-
-These are the device management handlers.  They should be
-maintained in the server context and the various methods
-should be inserted in the correct locations.
-"""
-from pymodbus.constants import DeviceInformation
-from pymodbus.interfaces import Singleton
-from pymodbus.utilities import dict_property
-from pymodbus.compat import iteritems, itervalues, izip, int2byte
-
-from collections import OrderedDict
-
-#---------------------------------------------------------------------------#
-# Network Access Control
-#---------------------------------------------------------------------------#
-class ModbusAccessControl(Singleton):
-    '''
-    This is a simple implementation of a Network Management System table.
-    Its purpose is to control access to the server (if it is used).
-    We assume that if an entry is in the table, it is allowed accesses to
-    resources.  However, if the host does not appear in the table (all
-    unknown hosts) its connection will simply be closed.
-
-    Since it is a singleton, only one version can possible exist and all
-    instances pull from here.
-    '''
-    __nmstable = [
-            "127.0.0.1",
-    ]
-
-    def __iter__(self):
-        ''' Iterater over the network access table
-
-        :returns: An iterator of the network access table
-        '''
-        return self.__nmstable.__iter__()
-
-    def __contains__(self, host):
-        ''' Check if a host is allowed to access resources
-
-        :param host: The host to check
-        '''
-        return host in self.__nmstable
-
-    def add(self, host):
-        ''' Add allowed host(s) from the NMS table
-
-        :param host: The host to add
-        '''
-        if not isinstance(host, list):
-            host = [host]
-        for entry in host:
-            if entry not in self.__nmstable:
-                self.__nmstable.append(entry)
-
-    def remove(self, host):
-        ''' Remove allowed host(s) from the NMS table
-
-        :param host: The host to remove
-        '''
-        if not isinstance(host, list):
-            host = [host]
-        for entry in host:
-            if entry in self.__nmstable:
-                self.__nmstable.remove(entry)
-
-    def check(self, host):
-        ''' Check if a host is allowed to access resources
-
-        :param host: The host to check
-        '''
-        return host in self.__nmstable
-
-
-#---------------------------------------------------------------------------#
-# Modbus Plus Statistics
-#---------------------------------------------------------------------------#
-class ModbusPlusStatistics(object):
-    '''
-    This is used to maintain the current modbus plus statistics count. As of
-    right now this is simply a stub to complete the modbus implementation.
-    For more information, see the modbus implementation guide page 87.
-    '''
-
-    __data = OrderedDict({
-        'node_type_id'                   : [0x00] * 2, # 00
-        'software_version_number'        : [0x00] * 2, # 01
-        'network_address'                : [0x00] * 2, # 02
-        'mac_state_variable'             : [0x00] * 2, # 03
-        'peer_status_code'               : [0x00] * 2, # 04
-        'token_pass_counter'             : [0x00] * 2, # 05
-        'token_rotation_time'            : [0x00] * 2, # 06
-
-        'program_master_token_failed'    : [0x00],     # 07 hi
-        'data_master_token_failed'       : [0x00],     # 07 lo
-        'program_master_token_owner'     : [0x00],     # 08 hi
-        'data_master_token_owner'        : [0x00],     # 08 lo
-        'program_slave_token_owner'      : [0x00],     # 09 hi
-        'data_slave_token_owner'         : [0x00],     # 09 lo
-        'data_slave_command_transfer'    : [0x00],     # 10 hi
-        '__unused_10_lowbit'             : [0x00],     # 10 lo
-
-        'program_slave_command_transfer' : [0x00],     # 11 hi
-        'program_master_rsp_transfer'    : [0x00],     # 11 lo
-        'program_slave_auto_logout'      : [0x00],     # 12 hi
-        'program_master_connect_status'  : [0x00],     # 12 lo
-        'receive_buffer_dma_overrun'     : [0x00],     # 13 hi
-        'pretransmit_deferral_error'     : [0x00],     # 13 lo
-        'frame_size_error'               : [0x00],     # 14 hi
-        'repeated_command_received'      : [0x00],     # 14 lo
-        'receiver_alignment_error'       : [0x00],     # 15 hi
-        'receiver_collision_abort_error' : [0x00],     # 15 lo
-        'bad_packet_length_error'        : [0x00],     # 16 hi
-        'receiver_crc_error'             : [0x00],     # 16 lo
-        'transmit_buffer_dma_underrun'   : [0x00],     # 17 hi
-        'bad_link_address_error'         : [0x00],     # 17 lo
-
-        'bad_mac_function_code_error'    : [0x00],     # 18 hi
-        'internal_packet_length_error'   : [0x00],     # 18 lo
-        'communication_failed_error'     : [0x00],     # 19 hi
-        'communication_retries'          : [0x00],     # 19 lo
-        'no_response_error'              : [0x00],     # 20 hi
-        'good_receive_packet'            : [0x00],     # 20 lo
-        'unexpected_path_error'          : [0x00],     # 21 hi
-        'exception_response_error'       : [0x00],     # 21 lo
-        'forgotten_transaction_error'    : [0x00],     # 22 hi
-        'unexpected_response_error'      : [0x00],     # 22 lo
-
-        'active_station_bit_map'         : [0x00] * 8, # 23-26
-        'token_station_bit_map'          : [0x00] * 8, # 27-30
-        'global_data_bit_map'            : [0x00] * 8, # 31-34
-        'receive_buffer_use_bit_map'     : [0x00] * 8, # 35-37
-        'data_master_output_path'        : [0x00] * 8, # 38-41
-        'data_slave_input_path'          : [0x00] * 8, # 42-45
-        'program_master_outptu_path'     : [0x00] * 8, # 46-49
-        'program_slave_input_path'       : [0x00] * 8, # 50-53
-    })
-
-    def __init__(self):
-        '''
-        Initialize the modbus plus statistics with the default
-        information.
-        '''
-        self.reset()
-
-    def __iter__(self):
-        ''' Iterater over the statistics
-
-        :returns: An iterator of the modbus plus statistics
-        '''
-        return iteritems(self.__data)
-
-    def reset(self):
-        ''' This clears all of the modbus plus statistics
-        '''
-        for key in self.__data:
-            self.__data[key] = [0x00] * len(self.__data[key])
-
-    def summary(self):
-        ''' Returns a summary of the modbus plus statistics
-
-        :returns: 54 16-bit words representing the status
-        '''
-        return itervalues(self.__data)
-
-    def encode(self):
-        ''' Returns a summary of the modbus plus statistics
-
-        :returns: 54 16-bit words representing the status
-        '''
-        total, values = [], sum(self.__data.values(), [])
-        for c in range(0, len(values), 2):
-            total.append((values[c] << 8) | values[c+1])
-        return total
-
-
-#---------------------------------------------------------------------------#
-# Device Information Control
-#---------------------------------------------------------------------------#
-class ModbusDeviceIdentification(object):
-    '''
-    This is used to supply the device identification
-    for the readDeviceIdentification function
-
-    For more information read section 6.21 of the modbus
-    application protocol.
-    '''
-    __data = {
-        0x00: '',  # VendorName
-        0x01: '',  # ProductCode
-        0x02: '',  # MajorMinorRevision
-        0x03: '',  # VendorUrl
-        0x04: '',  # ProductName
-        0x05: '',  # ModelName
-        0x06: '',  # UserApplicationName
-        0x07: '',  # reserved
-        0x08: '',  # reserved
-        # 0x80 -> 0xFF are private
-    }
-
-    __names = [
-        'VendorName',
-        'ProductCode',
-        'MajorMinorRevision',
-        'VendorUrl',
-        'ProductName',
-        'ModelName',
-        'UserApplicationName',
-    ]
-
-    def __init__(self, info=None):
-        '''
-        Initialize the datastore with the elements you need.
-        (note acceptable range is [0x00-0x06,0x80-0xFF] inclusive)
-
-        :param information: A dictionary of {int:string} of values
-        '''
-        if isinstance(info, dict):
-            for key in info:
-                if (0x06 >= key >= 0x00) or (0xFF >= key >= 0x80):
-                    self.__data[key] = info[key]
-
-    def __iter__(self):
-        ''' Iterater over the device information
-
-        :returns: An iterator of the device information
-        '''
-        return iteritems(self.__data)
-
-    def summary(self):
-        ''' Return a summary of the main items
-
-        :returns: An dictionary of the main items
-        '''
-        return dict(zip(self.__names, itervalues(self.__data)))
-
-    def update(self, value):
-        ''' Update the values of this identity
-        using another identify as the value
-
-        :param value: The value to copy values from
-        '''
-        self.__data.update(value)
-
-    def __setitem__(self, key, value):
-        ''' Wrapper used to access the device information
-
-        :param key: The register to set
-        :param value: The new value for referenced register
-        '''
-        if key not in [0x07, 0x08]:
-            self.__data[key] = value
-
-    def __getitem__(self, key):
-        ''' Wrapper used to access the device information
-
-        :param key: The register to read
-        '''
-        return self.__data.setdefault(key, '')
-
-    def __str__(self):
-        ''' Build a representation of the device
-
-        :returns: A string representation of the device
-        '''
-        return "DeviceIdentity"
-
-    #-------------------------------------------------------------------------#
-    # Properties
-    #-------------------------------------------------------------------------#
-    VendorName          = dict_property(lambda s: s.__data, 0)
-    ProductCode         = dict_property(lambda s: s.__data, 1)
-    MajorMinorRevision  = dict_property(lambda s: s.__data, 2)
-    VendorUrl           = dict_property(lambda s: s.__data, 3)
-    ProductName         = dict_property(lambda s: s.__data, 4)
-    ModelName           = dict_property(lambda s: s.__data, 5)
-    UserApplicationName = dict_property(lambda s: s.__data, 6)
-
-
-class DeviceInformationFactory(Singleton):
-    ''' This is a helper factory that really just hides
-    some of the complexity of processing the device information
-    requests (function code 0x2b 0x0e).
-    '''
-
-    __lookup = {
-        DeviceInformation.Basic: lambda c, r, i: c.__gets(r, list(range(i, 0x03))),
-        DeviceInformation.Regular: lambda c, r, i: c.__gets(r, list(range(i, 0x07))
-            if c.__get(r, i)[i] else list(range(0, 0x07))),
-        DeviceInformation.Extended: lambda c, r, i: c.__gets(r,
-            [x for x in range(i, 0x100) if x not in range(0x07, 0x80)]
-            if c.__get(r, i)[i] else
-            [x for x in range(0, 0x100) if x not in range(0x07, 0x80)]),
-        DeviceInformation.Specific: lambda c, r, i: c.__get(r, i),
-    }
-
-    @classmethod
-    def get(cls, control, read_code=DeviceInformation.Basic, object_id=0x00):
-        ''' Get the requested device data from the system
-
-        :param control: The control block to pull data from
-        :param read_code: The read code to process
-        :param object_id: The specific object_id to read
-        :returns: The requested data (id, length, value)
-        '''
-        identity = control.Identity
-        return cls.__lookup[read_code](cls, identity, object_id)
-
-    @classmethod
-    def __get(cls, identity, object_id):
-        ''' Read a single object_id from the device information
-
-        :param identity: The identity block to pull data from
-        :param object_id: The specific object id to read
-        :returns: The requested data (id, length, value)
-        '''
-        return { object_id:identity[object_id] }
-
-    @classmethod
-    def __gets(cls, identity, object_ids):
-        ''' Read multiple object_ids from the device information
-
-        :param identity: The identity block to pull data from
-        :param object_ids: The specific object ids to read
-        :returns: The requested data (id, length, value)
-        '''
-        return dict((oid, identity[oid]) for oid in object_ids if identity[oid])
-
-
-#---------------------------------------------------------------------------#
-# Counters Handler
-#---------------------------------------------------------------------------#
-class ModbusCountersHandler(object):
-    '''
-    This is a helper class to simplify the properties for the counters::
-
-    0x0B  1  Return Bus Message Count
-
-             Quantity of messages that the remote
-             device has detected on the communications system since its
-             last restart, clear counters operation, or power-up.  Messages
-             with bad CRC are not taken into account.
-
-    0x0C  2  Return Bus Communication Error Count
-
-             Quantity of CRC errors encountered by the remote device since its
-             last restart, clear counters operation, or power-up.  In case of
-             an error detected on the character level, (overrun, parity error),
-             or in case of a message length < 3 bytes, the receiving device is
-             not able to calculate the CRC. In such cases, this counter is
-             also incremented.
-
-    0x0D  3  Return Slave Exception Error Count
-
-             Quantity of MODBUS exception error detected by the remote device
-             since its last restart, clear counters operation, or power-up.  It
-             comprises also the error detected in broadcast messages even if an
-             exception message is not returned in this case.
-             Exception errors are described and listed in "MODBUS Application
-             Protocol Specification" document.
-
-    0xOE  4  Return Slave Message Count
-
-             Quantity of messages addressed to the remote device,  including
-             broadcast messages, that the remote device has processed since its
-             last restart, clear counters operation, or power-up.
-
-    0x0F  5  Return Slave No Response Count
-
-             Quantity of messages received by the remote device for which it
-             returned no response (neither a normal response nor an exception
-             response), since its last restart, clear counters operation, or
-             power-up. Then, this counter counts the number of broadcast
-             messages it has received.
-
-    0x10  6  Return Slave NAK Count
-
-             Quantity of messages addressed to the remote device for which it
-             returned a Negative Acknowledge (NAK) exception response, since
-             its last restart, clear counters operation, or power-up. Exception
-             responses are described and listed in "MODBUS Application Protocol
-             Specification" document.
-
-    0x11  7  Return Slave Busy Count
-
-             Quantity of messages addressed to the remote device for which it
-             returned a Slave Device Busy exception response, since its last
-             restart, clear counters operation, or power-up. Exception
-             responses are described and listed in "MODBUS Application
-             Protocol Specification" document.
-
-    0x12  8  Return Bus Character Overrun Count
-
-             Quantity of messages addressed to the remote device that it could
-             not handle due to a character overrun condition, since its last
-             restart, clear counters operation, or power-up. A character
-             overrun is caused by data characters arriving at the port faster
-             than they can.
-
-    .. note:: I threw the event counter in here for convinience
-    '''
-    __data = dict([(i, 0x0000) for i in range(9)])
-    __names   = [
-        'BusMessage',
-        'BusCommunicationError',
-        'SlaveExceptionError',
-        'SlaveMessage',
-        'SlaveNoResponse',
-        'SlaveNAK',
-        'SlaveBusy',
-        'BusCharacterOverrun'
-        'Event '
-    ]
-
-    def __iter__(self):
-        ''' Iterater over the device counters
-
-        :returns: An iterator of the device counters
-        '''
-        return izip(self.__names, itervalues(self.__data))
-
-    def update(self, values):
-        ''' Update the values of this identity
-        using another identify as the value
-
-        :param values: The value to copy values from
-        '''
-        for k, v in iteritems(values):
-            v += self.__getattribute__(k)
-            self.__setattr__(k, v)
-
-    def reset(self):
-        ''' This clears all of the system counters
-        '''
-        self.__data = dict([(i, 0x0000) for i in range(9)])
-
-    def summary(self):
-        ''' Returns a summary of the counters current status
-
-        :returns: A byte with each bit representing each counter
-        '''
-        count, result = 0x01, 0x00
-        for i in itervalues(self.__data):
-            if i != 0x00: result |= count
-            count <<= 1
-        return result
-
-    #-------------------------------------------------------------------------#
-    # Properties
-    #-------------------------------------------------------------------------#
-    BusMessage            = dict_property(lambda s: s.__data, 0)
-    BusCommunicationError = dict_property(lambda s: s.__data, 1)
-    BusExceptionError     = dict_property(lambda s: s.__data, 2)
-    SlaveMessage          = dict_property(lambda s: s.__data, 3)
-    SlaveNoResponse       = dict_property(lambda s: s.__data, 4)
-    SlaveNAK              = dict_property(lambda s: s.__data, 5)
-    SlaveBusy             = dict_property(lambda s: s.__data, 6)
-    BusCharacterOverrun   = dict_property(lambda s: s.__data, 7)
-    Event                 = dict_property(lambda s: s.__data, 8)
-
-
-#---------------------------------------------------------------------------#
-# Main server control block
-#---------------------------------------------------------------------------#
-class ModbusControlBlock(Singleton):
-    '''
-    This is a global singleotn that controls all system information
-
-    All activity should be logged here and all diagnostic requests
-    should come from here.
-    '''
-
-    __mode = 'ASCII'
-    __diagnostic = [False] * 16
-    __instance = None
-    __listen_only = False
-    __delimiter = '\r'
-    __counters = ModbusCountersHandler()
-    __identity = ModbusDeviceIdentification()
-    __plus     = ModbusPlusStatistics()
-    __events   = []
-
-    #-------------------------------------------------------------------------#
-    # Magic
-    #-------------------------------------------------------------------------#
-    def __str__(self):
-        ''' Build a representation of the control block
-
-        :returns: A string representation of the control block
-        '''
-        return "ModbusControl"
-
-    def __iter__(self):
-        ''' Iterater over the device counters
-
-        :returns: An iterator of the device counters
-        '''
-        return self.__counters.__iter__()
-
-    #-------------------------------------------------------------------------#
-    # Events
-    #-------------------------------------------------------------------------#
-    def addEvent(self, event):
-        ''' Adds a new event to the event log
-
-        :param event: A new event to add to the log
-        '''
-        self.__events.insert(0, event)
-        self.__events = self.__events[0:64]  # chomp to 64 entries
-        self.Counter.Event += 1
-
-    def getEvents(self):
-        ''' Returns an encoded collection of the event log.
-
-        :returns: The encoded events packet
-        '''
-        events = [event.encode() for event in self.__events]
-        return b''.join(events)
-
-    def clearEvents(self):
-        ''' Clears the current list of events
-        '''
-        self.__events = []
-
-    #-------------------------------------------------------------------------#
-    # Other Properties
-    #-------------------------------------------------------------------------#
-    Identity = property(lambda s: s.__identity)
-    Counter  = property(lambda s: s.__counters)
-    Events   = property(lambda s: s.__events)
-    Plus     = property(lambda s: s.__plus)
-
-    def reset(self):
-        ''' This clears all of the system counters and the
-            diagnostic register
-        '''
-        self.__events = []
-        self.__counters.reset()
-        self.__diagnostic = [False] * 16
-
-    #-------------------------------------------------------------------------#
-    # Listen Properties
-    #-------------------------------------------------------------------------#
-    def _setListenOnly(self, value):
-        ''' This toggles the listen only status
-
-        :param value: The value to set the listen status to
-        '''
-        self.__listen_only = bool(value)
-
-    ListenOnly = property(lambda s: s.__listen_only, _setListenOnly)
-
-    #-------------------------------------------------------------------------#
-    # Mode Properties
-    #-------------------------------------------------------------------------#
-    def _setMode(self, mode):
-        ''' This toggles the current serial mode
-
-        :param mode: The data transfer method in (RTU, ASCII)
-        '''
-        if mode in ['ASCII', 'RTU']:
-            self.__mode = mode
-
-    Mode = property(lambda s: s.__mode, _setMode)
-
-    #-------------------------------------------------------------------------#
-    # Delimiter Properties
-    #-------------------------------------------------------------------------#
-    def _setDelimiter(self, char):
-        ''' This changes the serial delimiter character
-
-        :param char: The new serial delimiter character
-        '''
-        if isinstance(char, str):
-            self.__delimiter = char.encode()
-        if isinstance(char, bytes):
-            self.__delimiter = char
-        elif isinstance(char, int):
-            self.__delimiter = int2byte(char)
-
-    Delimiter = property(lambda s: s.__delimiter, _setDelimiter)
-
-    #-------------------------------------------------------------------------#
-    # Diagnostic Properties
-    #-------------------------------------------------------------------------#
-    def setDiagnostic(self, mapping):
-        ''' This sets the value in the diagnostic register
-
-        :param mapping: Dictionary of key:value pairs to set
-        '''
-        for entry in iteritems(mapping):
-            if entry[0] >= 0 and entry[0] < len(self.__diagnostic):
-                self.__diagnostic[entry[0]] = (entry[1] != 0)
-
-    def getDiagnostic(self, bit):
-        ''' This gets the value in the diagnostic register
-
-        :param bit: The bit to get
-        :returns: The current value of the requested bit
-        '''
-        try:
-            if bit and bit >= 0 and bit < len(self.__diagnostic):
-                return self.__diagnostic[bit]
-        except Exception:
-            return None
-
-    def getDiagnosticRegister(self):
-        ''' This gets the entire diagnostic register
-
-        :returns: The diagnostic register collection
-        '''
-        return self.__diagnostic
-
-#---------------------------------------------------------------------------#
-# Exported Identifiers
-#---------------------------------------------------------------------------#
-__all__ = [
-        "ModbusAccessControl",
-        "ModbusPlusStatistics",
-        "ModbusDeviceIdentification",
-        "DeviceInformationFactory",
-        "ModbusControlBlock"
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/diag_message.py b/venv/lib/python3.7/site-packages/pymodbus/diag_message.py
deleted file mode 100644
index f6c02cb..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/diag_message.py
+++ /dev/null
@@ -1,789 +0,0 @@
-'''
-Diagnostic Record Read/Write
-------------------------------
-
-These need to be tied into a the current server context
-or linked to the appropriate data
-'''
-import struct
-
-from pymodbus.constants import ModbusStatus, ModbusPlusOperation
-from pymodbus.pdu import ModbusRequest
-from pymodbus.pdu import ModbusResponse
-from pymodbus.device import ModbusControlBlock
-from pymodbus.exceptions import NotImplementedException
-from pymodbus.utilities import pack_bitstring
-
-_MCB = ModbusControlBlock()
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Function Codes Base Classes
-# diagnostic 08, 00-18,20
-#---------------------------------------------------------------------------#
-# TODO Make sure all the data is decoded from the response
-#---------------------------------------------------------------------------#
-class DiagnosticStatusRequest(ModbusRequest):
-    '''
-    This is a base class for all of the diagnostic request functions
-    '''
-    function_code = 0x08
-    _rtu_frame_size = 8
-
-    def __init__(self, **kwargs):
-        '''
-        Base initializer for a diagnostic request
-        '''
-        ModbusRequest.__init__(self, **kwargs)
-        self.message = None
-
-    def encode(self):
-        '''
-        Base encoder for a diagnostic response
-        we encode the data set in self.message
-
-        :returns: The encoded packet
-        '''
-        packet = struct.pack('>H', self.sub_function_code)
-        if self.message is not None:
-            if isinstance(self.message, str):
-                packet += self.message.encode()
-            elif isinstance(self.message, bytes):
-                packet += self.message
-            elif isinstance(self.message, list):
-                for piece in self.message:
-                    packet += struct.pack('>H', piece)
-            elif isinstance(self.message, int):
-                packet += struct.pack('>H', self.message)
-        return packet
-
-    def decode(self, data):
-        ''' Base decoder for a diagnostic request
-
-        :param data: The data to decode into the function code
-        '''
-        self.sub_function_code, self.message = struct.unpack('>HH', data)
-    
-    def get_response_pdu_size(self):
-        """
-        Func_code (1 byte) + Sub function code (2 byte) + Data (2 * N bytes)
-        :return: 
-        """
-        if not isinstance(self.message,list):
-            self.message = [self.message]
-        return 1 + 2 + 2 * len(self.message)
-
-
-class DiagnosticStatusResponse(ModbusResponse):
-    '''
-    This is a base class for all of the diagnostic response functions
-
-    It works by performing all of the encoding and decoding of variable
-    data and lets the higher classes define what extra data to append
-    and how to execute a request
-    '''
-    function_code = 0x08
-    _rtu_frame_size = 8
-
-    def __init__(self, **kwargs):
-        '''
-        Base initializer for a diagnostic response
-        '''
-        ModbusResponse.__init__(self, **kwargs)
-        self.message = None
-
-    def encode(self):
-        '''
-        Base encoder for a diagnostic response
-        we encode the data set in self.message
-
-        :returns: The encoded packet
-        '''
-        packet = struct.pack('>H', self.sub_function_code)
-        if self.message is not None:
-            if isinstance(self.message, str):
-                packet += self.message.encode()
-            elif isinstance(self.message, bytes):
-                packet += self.message
-            elif isinstance(self.message, list):
-                for piece in self.message:
-                    packet += struct.pack('>H', piece)
-            elif isinstance(self.message, int):
-                packet += struct.pack('>H', self.message)
-        return packet
-
-    def decode(self, data):
-        ''' Base decoder for a diagnostic response
-
-        :param data: The data to decode into the function code
-        '''
-        word_len = len(data)//2
-        if len(data) % 2:
-            word_len += 1
-        data = struct.unpack('>' + 'H'*word_len, data)
-        self.sub_function_code, self.message = data[0], data[1:]
-
-
-class DiagnosticStatusSimpleRequest(DiagnosticStatusRequest):
-    '''
-    A large majority of the diagnostic functions are simple
-    status request functions.  They work by sending 0x0000
-    as data and their function code and they are returned
-    2 bytes of data.
-
-    If a function inherits this, they only need to implement
-    the execute method
-    '''
-
-    def __init__(self, data=0x0000, **kwargs):
-        '''
-        General initializer for a simple diagnostic request
-
-        The data defaults to 0x0000 if not provided as over half
-        of the functions require it.
-
-        :param data: The data to send along with the request
-        '''
-        DiagnosticStatusRequest.__init__(self, **kwargs)
-        self.message = data
-
-    def execute(self, *args):
-        ''' Base function to raise if not implemented '''
-        raise NotImplementedException("Diagnostic Message Has No Execute Method")
-
-
-class DiagnosticStatusSimpleResponse(DiagnosticStatusResponse):
-    '''
-    A large majority of the diagnostic functions are simple
-    status request functions.  They work by sending 0x0000
-    as data and their function code and they are returned
-    2 bytes of data.
-    '''
-
-    def __init__(self, data=0x0000, **kwargs):
-        ''' General initializer for a simple diagnostic response
-
-        :param data: The resulting data to return to the client
-        '''
-        DiagnosticStatusResponse.__init__(self, **kwargs)
-        self.message = data
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Sub Code 00
-#---------------------------------------------------------------------------#
-class ReturnQueryDataRequest(DiagnosticStatusRequest):
-    '''
-    The data passed in the request data field is to be returned (looped back)
-    in the response. The entire response message should be identical to the
-    request.
-    '''
-    sub_function_code = 0x0000
-
-    def __init__(self, message=0x0000, **kwargs):
-        ''' Initializes a new instance of the request
-
-        :param message: The message to send to loopback
-        '''
-        DiagnosticStatusRequest.__init__(self, **kwargs)
-        if isinstance(message, list):
-            self.message = message
-        else:
-            self.message = [message]
-
-    def execute(self, *args):
-        ''' Executes the loopback request (builds the response)
-
-        :returns: The populated loopback response message
-        '''
-        return ReturnQueryDataResponse(self.message)
-
-
-class ReturnQueryDataResponse(DiagnosticStatusResponse):
-    '''
-    The data passed in the request data field is to be returned (looped back)
-    in the response. The entire response message should be identical to the
-    request.
-    '''
-    sub_function_code = 0x0000
-
-    def __init__(self, message=0x0000, **kwargs):
-        ''' Initializes a new instance of the response
-
-        :param message: The message to loopback
-        '''
-        DiagnosticStatusResponse.__init__(self, **kwargs)
-        if isinstance(message, list):
-            self.message = message
-        else: self.message = [message]
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Sub Code 01
-#---------------------------------------------------------------------------#
-class RestartCommunicationsOptionRequest(DiagnosticStatusRequest):
-    '''
-    The remote device serial line port must be initialized and restarted, and
-    all of its communications event counters are cleared. If the port is
-    currently in Listen Only Mode, no response is returned. This function is
-    the only one that brings the port out of Listen Only Mode. If the port is
-    not currently in Listen Only Mode, a normal response is returned. This
-    occurs before the restart is executed.
-    '''
-    sub_function_code = 0x0001
-
-    def __init__(self, toggle=False, **kwargs):
-        ''' Initializes a new request
-
-        :param toggle: Set to True to toggle, False otherwise
-        '''
-        DiagnosticStatusRequest.__init__(self, **kwargs)
-        if toggle:
-            self.message   = [ModbusStatus.On]
-        else: self.message = [ModbusStatus.Off]
-
-    def execute(self, *args):
-        ''' Clear event log and restart
-
-        :returns: The initialized response message
-        '''
-        #if _MCB.ListenOnly:
-        return RestartCommunicationsOptionResponse(self.message)
-
-class RestartCommunicationsOptionResponse(DiagnosticStatusResponse):
-    '''
-    The remote device serial line port must be initialized and restarted, and
-    all of its communications event counters are cleared. If the port is
-    currently in Listen Only Mode, no response is returned. This function is
-    the only one that brings the port out of Listen Only Mode. If the port is
-    not currently in Listen Only Mode, a normal response is returned. This
-    occurs before the restart is executed.
-    '''
-    sub_function_code = 0x0001
-
-    def __init__(self, toggle=False, **kwargs):
-        ''' Initializes a new response
-
-        :param toggle: Set to True if we toggled, False otherwise
-        '''
-        DiagnosticStatusResponse.__init__(self, **kwargs)
-        if toggle:
-            self.message   = [ModbusStatus.On]
-        else: self.message = [ModbusStatus.Off]
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Sub Code 02
-#---------------------------------------------------------------------------#
-class ReturnDiagnosticRegisterRequest(DiagnosticStatusSimpleRequest):
-    '''
-    The contents of the remote device's 16-bit diagnostic register are
-    returned in the response
-    '''
-    sub_function_code = 0x0002
-
-    def execute(self, *args):
-        ''' Execute the diagnostic request on the given device
-
-        :returns: The initialized response message
-        '''
-        #if _MCB.isListenOnly():
-        register = pack_bitstring(_MCB.getDiagnosticRegister())
-        return ReturnDiagnosticRegisterResponse(register)
-
-
-class ReturnDiagnosticRegisterResponse(DiagnosticStatusSimpleResponse):
-    '''
-    The contents of the remote device's 16-bit diagnostic register are
-    returned in the response
-    '''
-    sub_function_code = 0x0002
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Sub Code 03
-#---------------------------------------------------------------------------#
-class ChangeAsciiInputDelimiterRequest(DiagnosticStatusSimpleRequest):
-    '''
-    The character 'CHAR' passed in the request data field becomes the end of
-    message delimiter for future messages (replacing the default LF
-    character). This function is useful in cases of a Line Feed is not
-    required at the end of ASCII messages.
-    '''
-    sub_function_code = 0x0003
-
-    def execute(self, *args):
-        ''' Execute the diagnostic request on the given device
-
-        :returns: The initialized response message
-        '''
-        char = (self.message & 0xff00) >> 8
-        _MCB.Delimiter = char
-        return ChangeAsciiInputDelimiterResponse(self.message)
-
-
-class ChangeAsciiInputDelimiterResponse(DiagnosticStatusSimpleResponse):
-    '''
-    The character 'CHAR' passed in the request data field becomes the end of
-    message delimiter for future messages (replacing the default LF
-    character). This function is useful in cases of a Line Feed is not
-    required at the end of ASCII messages.
-    '''
-    sub_function_code = 0x0003
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Sub Code 04
-#---------------------------------------------------------------------------#
-class ForceListenOnlyModeRequest(DiagnosticStatusSimpleRequest):
-    '''
-    Forces the addressed remote device to its Listen Only Mode for MODBUS
-    communications.  This isolates it from the other devices on the network,
-    allowing them to continue communicating without interruption from the
-    addressed remote device. No response is returned.
-    '''
-    sub_function_code = 0x0004
-
-    def execute(self, *args):
-        ''' Execute the diagnostic request on the given device
-
-        :returns: The initialized response message
-        '''
-        _MCB.ListenOnly = True
-        return ForceListenOnlyModeResponse()
-
-
-class ForceListenOnlyModeResponse(DiagnosticStatusResponse):
-    '''
-    Forces the addressed remote device to its Listen Only Mode for MODBUS
-    communications.  This isolates it from the other devices on the network,
-    allowing them to continue communicating without interruption from the
-    addressed remote device. No response is returned.
-
-    This does not send a response
-    '''
-    sub_function_code = 0x0004
-    should_respond    = False
-
-    def __init__(self, **kwargs):
-        ''' Initializer to block a return response
-        '''
-        DiagnosticStatusResponse.__init__(self, **kwargs)
-        self.message = []
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Sub Code 10
-#---------------------------------------------------------------------------#
-class ClearCountersRequest(DiagnosticStatusSimpleRequest):
-    '''
-    The goal is to clear ll counters and the diagnostic register.
-    Also, counters are cleared upon power-up
-    '''
-    sub_function_code = 0x000A
-
-    def execute(self, *args):
-        ''' Execute the diagnostic request on the given device
-
-        :returns: The initialized response message
-        '''
-        _MCB.reset()
-        return ClearCountersResponse(self.message)
-
-
-class ClearCountersResponse(DiagnosticStatusSimpleResponse):
-    '''
-    The goal is to clear ll counters and the diagnostic register.
-    Also, counters are cleared upon power-up
-    '''
-    sub_function_code = 0x000A
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Sub Code 11
-#---------------------------------------------------------------------------#
-class ReturnBusMessageCountRequest(DiagnosticStatusSimpleRequest):
-    '''
-    The response data field returns the quantity of messages that the
-    remote device has detected on the communications systems since its last
-    restart, clear counters operation, or power-up
-    '''
-    sub_function_code = 0x000B
-
-    def execute(self, *args):
-        ''' Execute the diagnostic request on the given device
-
-        :returns: The initialized response message
-        '''
-        count = _MCB.Counter.BusMessage
-        return ReturnBusMessageCountResponse(count)
-
-
-class ReturnBusMessageCountResponse(DiagnosticStatusSimpleResponse):
-    '''
-    The response data field returns the quantity of messages that the
-    remote device has detected on the communications systems since its last
-    restart, clear counters operation, or power-up
-    '''
-    sub_function_code = 0x000B
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Sub Code 12
-#---------------------------------------------------------------------------#
-class ReturnBusCommunicationErrorCountRequest(DiagnosticStatusSimpleRequest):
-    '''
-    The response data field returns the quantity of CRC errors encountered
-    by the remote device since its last restart, clear counter operation, or
-    power-up
-    '''
-    sub_function_code = 0x000C
-
-    def execute(self, *args):
-        ''' Execute the diagnostic request on the given device
-
-        :returns: The initialized response message
-        '''
-        count = _MCB.Counter.BusCommunicationError
-        return ReturnBusCommunicationErrorCountResponse(count)
-
-
-class ReturnBusCommunicationErrorCountResponse(DiagnosticStatusSimpleResponse):
-    '''
-    The response data field returns the quantity of CRC errors encountered
-    by the remote device since its last restart, clear counter operation, or
-    power-up
-    '''
-    sub_function_code = 0x000C
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Sub Code 13
-#---------------------------------------------------------------------------#
-class ReturnBusExceptionErrorCountRequest(DiagnosticStatusSimpleRequest):
-    '''
-    The response data field returns the quantity of modbus exception
-    responses returned by the remote device since its last restart,
-    clear counters operation, or power-up
-    '''
-    sub_function_code = 0x000D
-
-    def execute(self, *args):
-        ''' Execute the diagnostic request on the given device
-
-        :returns: The initialized response message
-        '''
-        count = _MCB.Counter.BusExceptionError
-        return ReturnBusExceptionErrorCountResponse(count)
-
-
-class ReturnBusExceptionErrorCountResponse(DiagnosticStatusSimpleResponse):
-    '''
-    The response data field returns the quantity of modbus exception
-    responses returned by the remote device since its last restart,
-    clear counters operation, or power-up
-    '''
-    sub_function_code = 0x000D
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Sub Code 14
-#---------------------------------------------------------------------------#
-class ReturnSlaveMessageCountRequest(DiagnosticStatusSimpleRequest):
-    '''
-    The response data field returns the quantity of messages addressed to the
-    remote device, or broadcast, that the remote device has processed since
-    its last restart, clear counters operation, or power-up
-    '''
-    sub_function_code = 0x000E
-
-    def execute(self, *args):
-        ''' Execute the diagnostic request on the given device
-
-        :returns: The initialized response message
-        '''
-        count = _MCB.Counter.SlaveMessage
-        return ReturnSlaveMessageCountResponse(count)
-
-
-class ReturnSlaveMessageCountResponse(DiagnosticStatusSimpleResponse):
-    '''
-    The response data field returns the quantity of messages addressed to the
-    remote device, or broadcast, that the remote device has processed since
-    its last restart, clear counters operation, or power-up
-    '''
-    sub_function_code = 0x000E
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Sub Code 15
-#---------------------------------------------------------------------------#
-class ReturnSlaveNoResponseCountRequest(DiagnosticStatusSimpleRequest):
-    '''
-    The response data field returns the quantity of messages addressed to the
-    remote device, or broadcast, that the remote device has processed since
-    its last restart, clear counters operation, or power-up
-    '''
-    sub_function_code = 0x000F
-
-    def execute(self, *args):
-        ''' Execute the diagnostic request on the given device
-
-        :returns: The initialized response message
-        '''
-        count = _MCB.Counter.SlaveNoResponse
-        return ReturnSlaveNoReponseCountResponse(count)
-
-
-class ReturnSlaveNoReponseCountResponse(DiagnosticStatusSimpleResponse):
-    '''
-    The response data field returns the quantity of messages addressed to the
-    remote device, or broadcast, that the remote device has processed since
-    its last restart, clear counters operation, or power-up
-    '''
-    sub_function_code = 0x000F
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Sub Code 16
-#---------------------------------------------------------------------------#
-class ReturnSlaveNAKCountRequest(DiagnosticStatusSimpleRequest):
-    '''
-    The response data field returns the quantity of messages addressed to the
-    remote device for which it returned a Negative Acknowledge (NAK) exception
-    response, since its last restart, clear counters operation, or power-up.
-    Exception responses are described and listed in section 7 .
-    '''
-    sub_function_code = 0x0010
-
-    def execute(self, *args):
-        ''' Execute the diagnostic request on the given device
-
-        :returns: The initialized response message
-        '''
-        count = _MCB.Counter.SlaveNAK
-        return ReturnSlaveNAKCountResponse(count)
-
-
-class ReturnSlaveNAKCountResponse(DiagnosticStatusSimpleResponse):
-    '''
-    The response data field returns the quantity of messages addressed to the
-    remote device for which it returned a Negative Acknowledge (NAK) exception
-    response, since its last restart, clear counters operation, or power-up.
-    Exception responses are described and listed in section 7.
-    '''
-    sub_function_code = 0x0010
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Sub Code 17
-#---------------------------------------------------------------------------#
-class ReturnSlaveBusyCountRequest(DiagnosticStatusSimpleRequest):
-    '''
-    The response data field returns the quantity of messages addressed to the
-    remote device for which it returned a Slave Device Busy exception response,
-    since its last restart, clear counters operation, or power-up.
-    '''
-    sub_function_code = 0x0011
-
-    def execute(self, *args):
-        ''' Execute the diagnostic request on the given device
-
-        :returns: The initialized response message
-        '''
-        count = _MCB.Counter.SlaveBusy
-        return ReturnSlaveBusyCountResponse(count)
-
-
-class ReturnSlaveBusyCountResponse(DiagnosticStatusSimpleResponse):
-    '''
-    The response data field returns the quantity of messages addressed to the
-    remote device for which it returned a Slave Device Busy exception response,
-    since its last restart, clear counters operation, or power-up.
-    '''
-    sub_function_code = 0x0011
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Sub Code 18
-#---------------------------------------------------------------------------#
-class ReturnSlaveBusCharacterOverrunCountRequest(DiagnosticStatusSimpleRequest):
-    '''
-    The response data field returns the quantity of messages addressed to the
-    remote device that it could not handle due to a character overrun condition,
-    since its last restart, clear counters operation, or power-up. A character
-    overrun is caused by data characters arriving at the port faster than they
-    can be stored, or by the loss of a character due to a hardware malfunction.
-    '''
-    sub_function_code = 0x0012
-
-    def execute(self, *args):
-        ''' Execute the diagnostic request on the given device
-
-        :returns: The initialized response message
-        '''
-        count = _MCB.Counter.BusCharacterOverrun
-        return ReturnSlaveBusCharacterOverrunCountResponse(count)
-
-
-class ReturnSlaveBusCharacterOverrunCountResponse(DiagnosticStatusSimpleResponse):
-    '''
-    The response data field returns the quantity of messages addressed to the
-    remote device that it could not handle due to a character overrun condition,
-    since its last restart, clear counters operation, or power-up. A character
-    overrun is caused by data characters arriving at the port faster than they
-    can be stored, or by the loss of a character due to a hardware malfunction.
-    '''
-    sub_function_code = 0x0012
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Sub Code 19
-#---------------------------------------------------------------------------#
-class ReturnIopOverrunCountRequest(DiagnosticStatusSimpleRequest):
-    '''
-    An IOP overrun is caused by data characters arriving at the port
-    faster than they can be stored, or by the loss of a character due
-    to a hardware malfunction.  This function is specific to the 884.
-    '''
-    sub_function_code = 0x0013
-
-    def execute(self, *args):
-        ''' Execute the diagnostic request on the given device
-
-        :returns: The initialized response message
-        '''
-        count = _MCB.Counter.BusCharacterOverrun
-        return ReturnIopOverrunCountResponse(count)
-
-
-class ReturnIopOverrunCountResponse(DiagnosticStatusSimpleResponse):
-    '''
-    The response data field returns the quantity of messages
-    addressed to the slave that it could not handle due to an 884
-    IOP overrun condition, since its last restart, clear counters
-    operation, or power-up.
-    '''
-    sub_function_code = 0x0013
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Sub Code 20
-#---------------------------------------------------------------------------#
-class ClearOverrunCountRequest(DiagnosticStatusSimpleRequest):
-    '''
-    Clears the overrun error counter and reset the error flag
-
-    An error flag should be cleared, but nothing else in the
-    specification mentions is, so it is ignored.
-    '''
-    sub_function_code = 0x0014
-
-    def execute(self, *args):
-        ''' Execute the diagnostic request on the given device
-
-        :returns: The initialized response message
-        '''
-        _MCB.Counter.BusCharacterOverrun = 0x0000
-        return ClearOverrunCountResponse(self.message)
-
-
-class ClearOverrunCountResponse(DiagnosticStatusSimpleResponse):
-    '''
-    Clears the overrun error counter and reset the error flag
-    '''
-    sub_function_code = 0x0014
-
-
-#---------------------------------------------------------------------------#
-# Diagnostic Sub Code 21
-#---------------------------------------------------------------------------#
-class GetClearModbusPlusRequest(DiagnosticStatusSimpleRequest):
-    '''
-    In addition to the Function code (08) and Subfunction code
-    (00 15 hex) in the query, a two-byte Operation field is used
-    to specify either a 'Get Statistics' or a 'Clear Statistics'
-    operation.  The two operations are exclusive - the 'Get'
-    operation cannot clear the statistics, and the 'Clear'
-    operation does not return statistics prior to clearing
-    them. Statistics are also cleared on power-up of the slave
-    device.
-    '''
-    sub_function_code = 0x0015
-
-    def __init__(self, **kwargs):
-        super(GetClearModbusPlusRequest, self).__init__(**kwargs)
-
-    def get_response_pdu_size(self):
-        """
-        Returns a series of 54 16-bit words (108 bytes) in the data field of the response
-        (this function differs from the usual two-byte length of the data field). The data
-        contains the statistics for the Modbus Plus peer processor in the slave device.
-        Func_code (1 byte) + Sub function code (2 byte) + Operation (2 byte) + Data (108 bytes)
-        :return:
-        """
-        if self.message == ModbusPlusOperation.GetStatistics:
-            data = 2 + 108 # byte count(2) + data (54*2)
-        else:
-            data = 0
-        return 1 + 2 + 2 + 2+ data
-
-    def execute(self, *args):
-        ''' Execute the diagnostic request on the given device
-
-        :returns: The initialized response message
-        '''
-        message = None # the clear operation does not return info
-        if self.message == ModbusPlusOperation.ClearStatistics:
-            _MCB.Plus.reset()
-            message = self.message
-        else:
-            message = [self.message]
-            message += _MCB.Plus.encode()
-        return GetClearModbusPlusResponse(message)
-
-    def encode(self):
-        '''
-        Base encoder for a diagnostic response
-        we encode the data set in self.message
-
-        :returns: The encoded packet
-        '''
-        packet = struct.pack('>H', self.sub_function_code)
-        packet += struct.pack('>H', self.message)
-        return packet
-
-
-class GetClearModbusPlusResponse(DiagnosticStatusSimpleResponse):
-    '''
-    Returns a series of 54 16-bit words (108 bytes) in the data field
-    of the response (this function differs from the usual two-byte
-    length of the data field). The data contains the statistics for
-    the Modbus Plus peer processor in the slave device.
-    '''
-    sub_function_code = 0x0015
-
-
-#---------------------------------------------------------------------------#
-# Exported symbols
-#---------------------------------------------------------------------------#
-__all__ = [
-    "DiagnosticStatusRequest", "DiagnosticStatusResponse",
-    "ReturnQueryDataRequest", "ReturnQueryDataResponse",
-    "RestartCommunicationsOptionRequest", "RestartCommunicationsOptionResponse",
-    "ReturnDiagnosticRegisterRequest", "ReturnDiagnosticRegisterResponse",
-    "ChangeAsciiInputDelimiterRequest", "ChangeAsciiInputDelimiterResponse",
-    "ForceListenOnlyModeRequest", "ForceListenOnlyModeResponse",
-    "ClearCountersRequest", "ClearCountersResponse",
-    "ReturnBusMessageCountRequest", "ReturnBusMessageCountResponse",
-    "ReturnBusCommunicationErrorCountRequest", "ReturnBusCommunicationErrorCountResponse",
-    "ReturnBusExceptionErrorCountRequest", "ReturnBusExceptionErrorCountResponse",
-    "ReturnSlaveMessageCountRequest", "ReturnSlaveMessageCountResponse",
-    "ReturnSlaveNoResponseCountRequest", "ReturnSlaveNoReponseCountResponse",
-    "ReturnSlaveNAKCountRequest", "ReturnSlaveNAKCountResponse",
-    "ReturnSlaveBusyCountRequest", "ReturnSlaveBusyCountResponse",
-    "ReturnSlaveBusCharacterOverrunCountRequest", "ReturnSlaveBusCharacterOverrunCountResponse",
-    "ReturnIopOverrunCountRequest", "ReturnIopOverrunCountResponse",
-    "ClearOverrunCountRequest", "ClearOverrunCountResponse",
-    "GetClearModbusPlusRequest", "GetClearModbusPlusResponse",
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/events.py b/venv/lib/python3.7/site-packages/pymodbus/events.py
deleted file mode 100644
index c3ed367..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/events.py
+++ /dev/null
@@ -1,197 +0,0 @@
-'''
-Modbus Remote Events
-------------------------------------------------------------
-
-An event byte returned by the Get Communications Event Log function
-can be any one of four types. The type is defined by bit 7
-(the high-order bit) in each byte. It may be further defined by bit 6.
-'''
-from pymodbus.exceptions import NotImplementedException
-from pymodbus.exceptions import ParameterException
-from pymodbus.utilities import pack_bitstring, unpack_bitstring
-
-
-class ModbusEvent(object):
-
-    def encode(self):
-        ''' Encodes the status bits to an event message
-
-        :returns: The encoded event message
-        '''
-        raise NotImplementedException()
-
-    def decode(self, event):
-        ''' Decodes the event message to its status bits
-
-        :param event: The event to decode
-        '''
-        raise NotImplementedException()
-
-
-class RemoteReceiveEvent(ModbusEvent):
-    ''' Remote device MODBUS Receive Event
-
-    The remote device stores this type of event byte when a query message
-    is received. It is stored before the remote device processes the message.
-    This event is defined by bit 7 set to logic '1'. The other bits will be
-    set to a logic '1' if the corresponding condition is TRUE. The bit layout
-    is::
-
-        Bit Contents
-        ----------------------------------
-        0   Not Used
-        2   Not Used
-        3   Not Used
-        4   Character Overrun
-        5   Currently in Listen Only Mode
-        6   Broadcast Receive
-        7   1
-    '''
-
-    def __init__(self, **kwargs):
-        ''' Initialize a new event instance
-        '''
-        self.overrun   = kwargs.get('overrun', False)
-        self.listen    = kwargs.get('listen', False)
-        self.broadcast = kwargs.get('broadcast', False)
-
-    def encode(self):
-        ''' Encodes the status bits to an event message
-
-        :returns: The encoded event message
-        '''
-        bits  = [False] * 3
-        bits += [self.overrun, self.listen, self.broadcast, True]
-        packet = pack_bitstring(bits)
-        return packet
-
-    def decode(self, event):
-        ''' Decodes the event message to its status bits
-
-        :param event: The event to decode
-        '''
-        bits = unpack_bitstring(event)
-        self.overrun   = bits[4]
-        self.listen    = bits[5]
-        self.broadcast = bits[6]
-
-
-class RemoteSendEvent(ModbusEvent):
-    ''' Remote device MODBUS Send Event
-
-    The remote device stores this type of event byte when it finishes
-    processing a request message. It is stored if the remote device
-    returned a normal or exception response, or no response.
-
-    This event is defined by bit 7 set to a logic '0', with bit 6 set to a '1'.
-    The other bits will be set to a logic '1' if the corresponding
-    condition is TRUE. The bit layout is::
-
-        Bit Contents
-        -----------------------------------------------------------
-        0   Read Exception Sent (Exception Codes 1-3)
-        1   Slave Abort Exception Sent (Exception Code 4)
-        2   Slave Busy Exception Sent (Exception Codes 5-6)
-        3   Slave Program NAK Exception Sent (Exception Code 7)
-        4   Write Timeout Error Occurred
-        5   Currently in Listen Only Mode
-        6   1
-        7   0
-    '''
-
-    def __init__(self, **kwargs):
-        ''' Initialize a new event instance
-        '''
-        self.read          = kwargs.get('read', False)
-        self.slave_abort   = kwargs.get('slave_abort', False)
-        self.slave_busy    = kwargs.get('slave_busy', False)
-        self.slave_nak     = kwargs.get('slave_nak', False)
-        self.write_timeout = kwargs.get('write_timeout', False)
-        self.listen        = kwargs.get('listen', False)
-
-    def encode(self):
-        ''' Encodes the status bits to an event message
-
-        :returns: The encoded event message
-        '''
-        bits = [self.read, self.slave_abort, self.slave_busy,
-            self.slave_nak, self.write_timeout, self.listen]
-        bits  += [True, False]
-        packet = pack_bitstring(bits)
-        return packet
-
-    def decode(self, event):
-        ''' Decodes the event message to its status bits
-
-        :param event: The event to decode
-        '''
-        # todo fix the start byte count
-        bits = unpack_bitstring(event)
-        self.read          = bits[0]
-        self.slave_abort   = bits[1]
-        self.slave_busy    = bits[2]
-        self.slave_nak     = bits[3]
-        self.write_timeout = bits[4]
-        self.listen        = bits[5]
-
-
-class EnteredListenModeEvent(ModbusEvent):
-    ''' Remote device Entered Listen Only Mode
-
-    The remote device stores this type of event byte when it enters
-    the Listen Only Mode. The event is defined by a content of 04 hex.
-    '''
-
-    value = 0x04
-    __encoded = b'\x04'
-
-    def encode(self):
-        ''' Encodes the status bits to an event message
-
-        :returns: The encoded event message
-        '''
-        return self.__encoded
-
-    def decode(self, event):
-        ''' Decodes the event message to its status bits
-
-        :param event: The event to decode
-        '''
-        if event != self.__encoded:
-            raise ParameterException('Invalid decoded value')
-
-
-class CommunicationRestartEvent(ModbusEvent):
-    ''' Remote device Initiated Communication Restart
-
-    The remote device stores this type of event byte when its communications
-    port is restarted. The remote device can be restarted by the Diagnostics
-    function (code 08), with sub-function Restart Communications Option
-    (code 00 01).
-
-    That function also places the remote device into a 'Continue on Error'
-    or 'Stop on Error' mode. If the remote device is placed  into 'Continue on
-    Error' mode, the event byte is added to the existing event log. If the
-    remote device is placed into 'Stop on Error' mode, the byte is added to
-    the log and the rest of the log is cleared to zeros.
-
-    The event is defined by a content of zero.
-    '''
-
-    value = 0x00
-    __encoded = b'\x00'
-
-    def encode(self):
-        ''' Encodes the status bits to an event message
-
-        :returns: The encoded event message
-        '''
-        return self.__encoded
-
-    def decode(self, event):
-        ''' Decodes the event message to its status bits
-
-        :param event: The event to decode
-        '''
-        if event != self.__encoded:
-            raise ParameterException('Invalid decoded value')
diff --git a/venv/lib/python3.7/site-packages/pymodbus/exceptions.py b/venv/lib/python3.7/site-packages/pymodbus/exceptions.py
deleted file mode 100644
index 7918f64..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/exceptions.py
+++ /dev/null
@@ -1,118 +0,0 @@
-"""
-Pymodbus Exceptions
---------------------
-
-Custom exceptions to be used in the Modbus code.
-"""
-
-
-class ModbusException(Exception):
-    """ Base modbus exception """
-
-    def __init__(self, string):
-        """ Initialize the exception
-        :param string: The message to append to the error
-        """
-        self.string = string
-
-    def __str__(self):
-        return 'Modbus Error: %s' % self.string
-
-    def isError(self):
-        """Error"""
-        return True
-
-
-class ModbusIOException(ModbusException):
-    """ Error resulting from data i/o """
-
-    def __init__(self, string="", function_code=None):
-        """ Initialize the exception
-        :param string: The message to append to the error
-        """
-        self.fcode = function_code
-        self.message = "[Input/Output] %s" % string
-        ModbusException.__init__(self, self.message)
-
-
-class ParameterException(ModbusException):
-    """ Error resulting from invalid parameter """
-
-    def __init__(self, string=""):
-        """ Initialize the exception
-
-        :param string: The message to append to the error
-        """
-        message = "[Invalid Parameter] %s" % string
-        ModbusException.__init__(self, message)
-
-
-class NoSuchSlaveException(ModbusException):
-    """ Error resulting from making a request to a slave
-    that does not exist """
-
-    def __init__(self, string=""):
-        """ Initialize the exception
-
-        :param string: The message to append to the error
-        """
-        message = "[No Such Slave] %s" % string
-        ModbusException.__init__(self, message)
-
-
-class NotImplementedException(ModbusException):
-    """ Error resulting from not implemented function """
-
-    def __init__(self, string=""):
-        """ Initialize the exception
-        :param string: The message to append to the error
-        """
-        message = "[Not Implemented] %s" % string
-        ModbusException.__init__(self, message)
-
-
-class ConnectionException(ModbusException):
-    """ Error resulting from a bad connection """
-
-    def __init__(self, string=""):
-        """ Initialize the exception
-
-        :param string: The message to append to the error
-        """
-        message = "[Connection] %s" % string
-        ModbusException.__init__(self, message)
-
-
-class InvalidMessageReceivedException(ModbusException):
-    """
-    Error resulting from invalid response received or decoded
-    """
-
-    def __init__(self, string=""):
-        """ Initialize the exception
-
-        :param string: The message to append to the error
-        """
-        message = "[Invalid Message] %s" % string
-        ModbusException.__init__(self, message)
-
-
-class MessageRegisterException(ModbusException):
-    """
-    Error resulting from failing to register a custom message request/response
-    """
-    def __init__(self, string=""):
-        message = '[Error registering message] %s' % string
-        ModbusException.__init__(self, message)
-
-
-# --------------------------------------------------------------------------- #
-# Exported symbols
-# --------------------------------------------------------------------------- #
-__all__ = [
-    "ModbusException", "ModbusIOException",
-    "ParameterException", "NotImplementedException",
-    "ConnectionException", "NoSuchSlaveException",
-    "InvalidMessageReceivedException",
-    "MessageRegisterException"
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/factory.py b/venv/lib/python3.7/site-packages/pymodbus/factory.py
deleted file mode 100644
index ad2dff1..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/factory.py
+++ /dev/null
@@ -1,312 +0,0 @@
-"""
-Modbus Request/Response Decoder Factories
--------------------------------------------
-
-The following factories make it easy to decode request/response messages.
-To add a new request/response pair to be decodeable by the library, simply
-add them to the respective function lookup table (order doesn't matter, but
-it does help keep things organized).
-
-Regardless of how many functions are added to the lookup, O(1) behavior is
-kept as a result of a pre-computed lookup dictionary.
-"""
-
-from pymodbus.pdu import IllegalFunctionRequest
-from pymodbus.pdu import ExceptionResponse
-from pymodbus.pdu import ModbusRequest, ModbusResponse
-from pymodbus.pdu import ModbusExceptions as ecode
-from pymodbus.interfaces import IModbusDecoder
-from pymodbus.exceptions import ModbusException, MessageRegisterException
-from pymodbus.bit_read_message import *
-from pymodbus.bit_write_message import *
-from pymodbus.diag_message import *
-from pymodbus.file_message import *
-from pymodbus.other_message import *
-from pymodbus.mei_message import *
-from pymodbus.register_read_message import *
-from pymodbus.register_write_message import *
-from pymodbus.compat import byte2int
-
-
-# --------------------------------------------------------------------------- #
-# Logging
-# --------------------------------------------------------------------------- #
-import logging
-_logger = logging.getLogger(__name__)
-
-
-# --------------------------------------------------------------------------- #
-# Server Decoder
-# --------------------------------------------------------------------------- #
-class ServerDecoder(IModbusDecoder):
-    """ Request Message Factory (Server)
-
-    To add more implemented functions, simply add them to the list
-    """
-    __function_table = [
-            ReadHoldingRegistersRequest,
-            ReadDiscreteInputsRequest,
-            ReadInputRegistersRequest,
-            ReadCoilsRequest,
-            WriteMultipleCoilsRequest,
-            WriteMultipleRegistersRequest,
-            WriteSingleRegisterRequest,
-            WriteSingleCoilRequest,
-            ReadWriteMultipleRegistersRequest,
-            DiagnosticStatusRequest,
-            ReadExceptionStatusRequest,
-            GetCommEventCounterRequest,
-            GetCommEventLogRequest,
-            ReportSlaveIdRequest,
-            ReadFileRecordRequest,
-            WriteFileRecordRequest,
-            MaskWriteRegisterRequest,
-            ReadFifoQueueRequest,
-            ReadDeviceInformationRequest,
-    ]
-    __sub_function_table = [
-            ReturnQueryDataRequest,
-            RestartCommunicationsOptionRequest,
-            ReturnDiagnosticRegisterRequest,
-            ChangeAsciiInputDelimiterRequest,
-            ForceListenOnlyModeRequest,
-            ClearCountersRequest,
-            ReturnBusMessageCountRequest,
-            ReturnBusCommunicationErrorCountRequest,
-            ReturnBusExceptionErrorCountRequest,
-            ReturnSlaveMessageCountRequest,
-            ReturnSlaveNoResponseCountRequest,
-            ReturnSlaveNAKCountRequest,
-            ReturnSlaveBusyCountRequest,
-            ReturnSlaveBusCharacterOverrunCountRequest,
-            ReturnIopOverrunCountRequest,
-            ClearOverrunCountRequest,
-            GetClearModbusPlusRequest,
-            ReadDeviceInformationRequest,
-    ]
-
-    def __init__(self):
-        """ Initializes the client lookup tables
-        """
-        functions = set(f.function_code for f in self.__function_table)
-        self.__lookup = dict([(f.function_code, f) for f in self.__function_table])
-        self.__sub_lookup = dict((f, {}) for f in functions)
-        for f in self.__sub_function_table:
-            self.__sub_lookup[f.function_code][f.sub_function_code] = f
-
-    def decode(self, message):
-        """ Wrapper to decode a request packet
-
-        :param message: The raw modbus request packet
-        :return: The decoded modbus message or None if error
-        """
-        try:
-            return self._helper(message)
-        except ModbusException as er:
-            _logger.warning("Unable to decode request %s" % er)
-        return None
-
-    def lookupPduClass(self, function_code):
-        """ Use `function_code` to determine the class of the PDU.
-
-        :param function_code: The function code specified in a frame.
-        :returns: The class of the PDU that has a matching `function_code`.
-        """
-        return self.__lookup.get(function_code, ExceptionResponse)
-
-    def _helper(self, data):
-        """
-        This factory is used to generate the correct request object
-        from a valid request packet. This decodes from a list of the
-        currently implemented request types.
-
-        :param data: The request packet to decode
-        :returns: The decoded request or illegal function request object
-        """
-        function_code = byte2int(data[0])
-        request = self.__lookup.get(function_code, lambda: None)()
-        if not request:
-            _logger.debug("Factory Request[%d]" % function_code)
-            request = IllegalFunctionRequest(function_code)
-        else:
-            fc_string = "%s: %s" % (
-                str(self.__lookup[function_code]).split('.')[-1].rstrip(
-                    "'>"),
-                function_code
-            )
-            _logger.debug("Factory Request[%s]" % fc_string)
-        request.decode(data[1:])
-
-        if hasattr(request, 'sub_function_code'):
-            lookup = self.__sub_lookup.get(request.function_code, {})
-            subtype = lookup.get(request.sub_function_code, None)
-            if subtype: request.__class__ = subtype
-
-        return request
-    
-    def register(self, function=None):
-        """
-        Registers a function and sub function class with the decoder
-        :param function: Custom function class to register
-        :return:
-        """
-        if function and not issubclass(function, ModbusRequest):
-            raise MessageRegisterException("'{}' is Not a valid Modbus Message"
-                                           ". Class needs to be derived from "
-                                           "`pymodbus.pdu.ModbusRequest` "
-                                           "".format(
-                function.__class__.__name__
-            ))
-        self.__lookup[function.function_code] = function
-        if hasattr(function, "sub_function_code"):
-            if function.function_code not in self.__sub_lookup:
-                self.__sub_lookup[function.function_code] = dict()
-            self.__sub_lookup[function.function_code][
-                function.sub_function_code] = function
-
-
-# --------------------------------------------------------------------------- #
-# Client Decoder
-# --------------------------------------------------------------------------- #
-class ClientDecoder(IModbusDecoder):
-    """ Response Message Factory (Client)
-
-    To add more implemented functions, simply add them to the list
-    """
-    __function_table = [
-            ReadHoldingRegistersResponse,
-            ReadDiscreteInputsResponse,
-            ReadInputRegistersResponse,
-            ReadCoilsResponse,
-            WriteMultipleCoilsResponse,
-            WriteMultipleRegistersResponse,
-            WriteSingleRegisterResponse,
-            WriteSingleCoilResponse,
-            ReadWriteMultipleRegistersResponse,
-            DiagnosticStatusResponse,
-            ReadExceptionStatusResponse,
-            GetCommEventCounterResponse,
-            GetCommEventLogResponse,
-            ReportSlaveIdResponse,
-            ReadFileRecordResponse,
-            WriteFileRecordResponse,
-            MaskWriteRegisterResponse,
-            ReadFifoQueueResponse,
-            ReadDeviceInformationResponse,
-    ]
-    __sub_function_table = [
-            ReturnQueryDataResponse,
-            RestartCommunicationsOptionResponse,
-            ReturnDiagnosticRegisterResponse,
-            ChangeAsciiInputDelimiterResponse,
-            ForceListenOnlyModeResponse,
-            ClearCountersResponse,
-            ReturnBusMessageCountResponse,
-            ReturnBusCommunicationErrorCountResponse,
-            ReturnBusExceptionErrorCountResponse,
-            ReturnSlaveMessageCountResponse,
-            ReturnSlaveNoReponseCountResponse,
-            ReturnSlaveNAKCountResponse,
-            ReturnSlaveBusyCountResponse,
-            ReturnSlaveBusCharacterOverrunCountResponse,
-            ReturnIopOverrunCountResponse,
-            ClearOverrunCountResponse,
-            GetClearModbusPlusResponse,
-            ReadDeviceInformationResponse,
-    ]
-
-    def __init__(self):
-        """ Initializes the client lookup tables
-        """
-        functions = set(f.function_code for f in self.__function_table)
-        self.__lookup = dict([(f.function_code, f)
-                              for f in self.__function_table])
-        self.__sub_lookup = dict((f, {}) for f in functions)
-        for f in self.__sub_function_table:
-            self.__sub_lookup[f.function_code][f.sub_function_code] = f
-
-    def lookupPduClass(self, function_code):
-        """ Use `function_code` to determine the class of the PDU.
-
-        :param function_code: The function code specified in a frame.
-        :returns: The class of the PDU that has a matching `function_code`.
-        """
-        return self.__lookup.get(function_code, ExceptionResponse)
-
-    def decode(self, message):
-        """ Wrapper to decode a response packet
-
-        :param message: The raw packet to decode
-        :return: The decoded modbus message or None if error
-        """
-        try:
-            return self._helper(message)
-        except ModbusException as er:
-            _logger.error("Unable to decode response %s" % er)
-
-        except Exception as ex:
-            _logger.error(ex)
-        return None
-
-    def _helper(self, data):
-        """
-        This factory is used to generate the correct response object
-        from a valid response packet. This decodes from a list of the
-        currently implemented request types.
-
-        :param data: The response packet to decode
-        :returns: The decoded request or an exception response object
-        """
-        fc_string = function_code = byte2int(data[0])
-        if function_code in self.__lookup:
-            fc_string = "%s: %s" % (
-                str(self.__lookup[function_code]).split('.')[-1].rstrip("'>"),
-                function_code
-            )
-        _logger.debug("Factory Response[%s]" % fc_string)
-        response = self.__lookup.get(function_code, lambda: None)()
-        if function_code > 0x80:
-            code = function_code & 0x7f  # strip error portion
-            response = ExceptionResponse(code, ecode.IllegalFunction)
-        if not response:
-            raise ModbusException("Unknown response %d" % function_code)
-        response.decode(data[1:])
-
-        if hasattr(response, 'sub_function_code'):
-            lookup = self.__sub_lookup.get(response.function_code, {})
-            subtype = lookup.get(response.sub_function_code, None)
-            if subtype: response.__class__ = subtype
-
-        return response
-
-    def register(self, function=None, sub_function=None, force=False):
-        """
-        Registers a function and sub function class with the decoder
-        :param function: Custom function class to register
-        :param sub_function: Custom sub function class to register
-        :param force: Force update the existing class
-        :return:
-        """
-        if function and not issubclass(function, ModbusResponse):
-            raise MessageRegisterException("'{}' is Not a valid Modbus Message"
-                                           ". Class needs to be derived from "
-                                           "`pymodbus.pdu.ModbusResponse` "
-                                           "".format(
-                function.__class__.__name__
-            ))
-        self.__lookup[function.function_code] = function
-        if hasattr(function, "sub_function_code"):
-            if function.function_code not in self.__sub_lookup:
-                self.__sub_lookup[function.function_code] = dict()
-            self.__sub_lookup[function.function_code][
-                function.sub_function_code] = function
-
-
-# --------------------------------------------------------------------------- #
-# Exported symbols
-# --------------------------------------------------------------------------- #
-
-
-__all__ = ['ServerDecoder', 'ClientDecoder']
-
-
diff --git a/venv/lib/python3.7/site-packages/pymodbus/file_message.py b/venv/lib/python3.7/site-packages/pymodbus/file_message.py
deleted file mode 100644
index 15fba11..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/file_message.py
+++ /dev/null
@@ -1,395 +0,0 @@
-'''
-File Record Read/Write Messages
--------------------------------
-
-Currently none of these messages are implemented
-'''
-import struct
-from pymodbus.pdu import ModbusRequest
-from pymodbus.pdu import ModbusResponse
-from pymodbus.pdu import ModbusExceptions as merror
-from pymodbus.compat import byte2int
-
-
-#---------------------------------------------------------------------------#
-# File Record Types
-#---------------------------------------------------------------------------#
-class FileRecord(object):
-    ''' Represents a file record and its relevant data.
-    '''
-
-    def __init__(self, **kwargs):
-        ''' Initializes a new instance
-
-        :params reference_type: Defaults to 0x06 (must be)
-        :params file_number: Indicates which file number we are reading
-        :params record_number: Indicates which record in the file
-        :params record_data: The actual data of the record
-        :params record_length: The length in registers of the record
-        :params response_length: The length in bytes of the record
-        '''
-        self.reference_type  = kwargs.get('reference_type', 0x06)
-        self.file_number     = kwargs.get('file_number', 0x00)
-        self.record_number   = kwargs.get('record_number', 0x00)
-        self.record_data     = kwargs.get('record_data', '')
-
-        self.record_length   = kwargs.get('record_length',   len(self.record_data) // 2)
-        self.response_length = kwargs.get('response_length', len(self.record_data) + 1)
-
-    def __eq__(self, relf):
-        ''' Compares the left object to the right
-        '''
-        return self.reference_type == relf.reference_type \
-           and self.file_number    == relf.file_number    \
-           and self.record_number  == relf.record_number  \
-           and self.record_length  == relf.record_length  \
-           and self.record_data    == relf.record_data
-
-    def __ne__(self, relf):
-        ''' Compares the left object to the right
-        '''
-        return not self.__eq__(relf)
-
-    def __repr__(self):
-        ''' Gives a representation of the file record
-        '''
-        params = (self.file_number, self.record_number, self.record_length)
-        return 'FileRecord(file=%d, record=%d, length=%d)' % params
-
-
-#---------------------------------------------------------------------------#
-# File Requests/Responses
-#---------------------------------------------------------------------------#
-class ReadFileRecordRequest(ModbusRequest):
-    '''
-    This function code is used to perform a file record read. All request
-    data lengths are provided in terms of number of bytes and all record
-    lengths are provided in terms of registers.
-
-    A file is an organization of records. Each file contains 10000 records,
-    addressed 0000 to 9999 decimal or 0x0000 to 0x270f. For example, record
-    12 is addressed as 12. The function can read multiple groups of
-    references. The groups can be separating (non-contiguous), but the
-    references within each group must be sequential. Each group is defined
-    in a seperate 'sub-request' field that contains seven bytes::
-
-        The reference type: 1 byte (must be 0x06)
-        The file number: 2 bytes
-        The starting record number within the file: 2 bytes
-        The length of the record to be read: 2 bytes
-
-    The quantity of registers to be read, combined with all other fields
-    in the expected response, must not exceed the allowable length of the
-    MODBUS PDU: 235 bytes.
-    '''
-    function_code = 0x14
-    _rtu_byte_count_pos = 2
-
-    def __init__(self, records=None, **kwargs):
-        ''' Initializes a new instance
-
-        :param records: The file record requests to be read
-        '''
-        ModbusRequest.__init__(self, **kwargs)
-        self.records  = records or []
-
-    def encode(self):
-        ''' Encodes the request packet
-
-        :returns: The byte encoded packet
-        '''
-        packet = struct.pack('B', len(self.records) * 7)
-        for record in self.records:
-            packet += struct.pack('>BHHH', 0x06, record.file_number,
-                record.record_number, record.record_length)
-        return packet
-
-    def decode(self, data):
-        ''' Decodes the incoming request
-
-        :param data: The data to decode into the address
-        '''
-        self.records = []
-        byte_count = byte2int(data[0])
-        for count in range(1, byte_count, 7):
-            decoded = struct.unpack('>BHHH', data[count:count+7])
-            record  = FileRecord(file_number=decoded[1],
-                record_number=decoded[2], record_length=decoded[3])
-            if decoded[0] == 0x06: self.records.append(record)
-
-    def execute(self, context):
-        ''' Run a read exeception status request against the store
-
-        :param context: The datastore to request from
-        :returns: The populated response
-        '''
-        # TODO do some new context operation here
-        # if file number, record number, or address + length
-        # is too big, return an error.
-        files = []
-        return ReadFileRecordResponse(files)
-
-
-class ReadFileRecordResponse(ModbusResponse):
-    '''
-    The normal response is a series of 'sub-responses,' one for each
-    'sub-request.' The byte count field is the total combined count of
-    bytes in all 'sub-responses.' In addition, each 'sub-response'
-    contains a field that shows its own byte count.
-    '''
-    function_code = 0x14
-    _rtu_byte_count_pos = 2
-
-    def __init__(self, records=None, **kwargs):
-        ''' Initializes a new instance
-
-        :param records: The requested file records
-        '''
-        ModbusResponse.__init__(self, **kwargs)
-        self.records = records or []
-
-    def encode(self):
-        ''' Encodes the response
-
-        :returns: The byte encoded message
-        '''
-        total  = sum(record.response_length + 1 for record in self.records)
-        packet = struct.pack('B', total)
-        for record in self.records:
-            packet += struct.pack('>BB', 0x06, record.record_length)
-            packet += record.record_data
-        return packet
-
-    def decode(self, data):
-        ''' Decodes a the response
-
-        :param data: The packet data to decode
-        '''
-        count, self.records = 1, []
-        byte_count = byte2int(data[0])
-        while count < byte_count:
-            response_length, reference_type = struct.unpack('>BB', data[count:count+2])
-            count += response_length + 1 # the count is not included
-            record = FileRecord(response_length=response_length,
-                record_data=data[count - response_length + 1:count])
-            if reference_type == 0x06: self.records.append(record)
-
-
-class WriteFileRecordRequest(ModbusRequest):
-    '''
-    This function code is used to perform a file record write. All
-    request data lengths are provided in terms of number of bytes
-    and all record lengths are provided in terms of the number of 16
-    bit words.
-    '''
-    function_code = 0x15
-    _rtu_byte_count_pos = 2
-
-    def __init__(self, records=None, **kwargs):
-        ''' Initializes a new instance
-
-        :param records: The file record requests to be read
-        '''
-        ModbusRequest.__init__(self, **kwargs)
-        self.records  = records or []
-
-    def encode(self):
-        ''' Encodes the request packet
-
-        :returns: The byte encoded packet
-        '''
-        total_length = sum((record.record_length * 2) + 7 for record in self.records)
-        packet = struct.pack('B', total_length)
-        for record in self.records:
-            packet += struct.pack('>BHHH', 0x06, record.file_number,
-                record.record_number, record.record_length)
-            packet += record.record_data
-        return packet
-
-    def decode(self, data):
-        ''' Decodes the incoming request
-
-        :param data: The data to decode into the address
-        '''
-        count, self.records = 1, []
-        byte_count = byte2int(data[0])
-        while count < byte_count:
-            decoded = struct.unpack('>BHHH', data[count:count+7])
-            response_length = decoded[3] * 2
-            count  += response_length + 7
-            record  = FileRecord(record_length=decoded[3],
-                file_number=decoded[1], record_number=decoded[2],
-                record_data=data[count - response_length:count])
-            if decoded[0] == 0x06: self.records.append(record)
-
-    def execute(self, context):
-        ''' Run the write file record request against the context
-
-        :param context: The datastore to request from
-        :returns: The populated response
-        '''
-        # TODO do some new context operation here
-        # if file number, record number, or address + length
-        # is too big, return an error.
-        return WriteFileRecordResponse(self.records)
-
-
-class WriteFileRecordResponse(ModbusResponse):
-    '''
-    The normal response is an echo of the request.
-    '''
-    function_code = 0x15
-    _rtu_byte_count_pos = 2
-
-    def __init__(self, records=None, **kwargs):
-        ''' Initializes a new instance
-
-        :param records: The file record requests to be read
-        '''
-        ModbusResponse.__init__(self, **kwargs)
-        self.records  = records or []
-
-    def encode(self):
-        ''' Encodes the response
-
-        :returns: The byte encoded message
-        '''
-        total_length = sum((record.record_length * 2) + 7 for record in self.records)
-        packet = struct.pack('B', total_length)
-        for record in self.records:
-            packet += struct.pack('>BHHH', 0x06, record.file_number,
-                record.record_number, record.record_length)
-            packet += record.record_data
-        return packet
-
-    def decode(self, data):
-        ''' Decodes the incoming request
-
-        :param data: The data to decode into the address
-        '''
-        count, self.records = 1, []
-        byte_count = byte2int(data[0])
-        while count < byte_count:
-            decoded = struct.unpack('>BHHH', data[count:count+7])
-            response_length = decoded[3] * 2
-            count  += response_length + 7
-            record  = FileRecord(record_length=decoded[3],
-                file_number=decoded[1], record_number=decoded[2],
-                record_data=data[count - response_length:count])
-            if decoded[0] == 0x06: self.records.append(record)
-
-
-class ReadFifoQueueRequest(ModbusRequest):
-    '''
-    This function code allows to read the contents of a First-In-First-Out
-    (FIFO) queue of register in a remote device. The function returns a
-    count of the registers in the queue, followed by the queued data.
-    Up to 32 registers can be read: the count, plus up to 31 queued data
-    registers.
-
-    The queue count register is returned first, followed by the queued data
-    registers.  The function reads the queue contents, but does not clear
-    them.
-    '''
-    function_code = 0x18
-    _rtu_frame_size = 6
-
-    def __init__(self, address=0x0000, **kwargs):
-        ''' Initializes a new instance
-
-        :param address: The fifo pointer address (0x0000 to 0xffff)
-        '''
-        ModbusRequest.__init__(self, **kwargs)
-        self.address = address
-        self.values = []  # this should be added to the context
-
-    def encode(self):
-        ''' Encodes the request packet
-
-        :returns: The byte encoded packet
-        '''
-        return struct.pack('>H', self.address)
-
-    def decode(self, data):
-        ''' Decodes the incoming request
-
-        :param data: The data to decode into the address
-        '''
-        self.address = struct.unpack('>H', data)[0]
-
-    def execute(self, context):
-        ''' Run a read exeception status request against the store
-
-        :param context: The datastore to request from
-        :returns: The populated response
-        '''
-        if not (0x0000 <= self.address <= 0xffff):
-            return self.doException(merror.IllegalValue)
-        if len(self.values) > 31:
-            return self.doException(merror.IllegalValue)
-        # TODO pull the values from some context
-        return ReadFifoQueueResponse(self.values)
-
-
-class ReadFifoQueueResponse(ModbusResponse):
-    '''
-    In a normal response, the byte count shows the quantity of bytes to
-    follow, including the queue count bytes and value register bytes
-    (but not including the error check field).  The queue count is the
-    quantity of data registers in the queue (not including the count register).
-
-    If the queue count exceeds 31, an exception response is returned with an
-    error code of 03 (Illegal Data Value).
-    '''
-    function_code = 0x18
-
-    @classmethod
-    def calculateRtuFrameSize(cls, buffer):
-        ''' Calculates the size of the message
-
-        :param buffer: A buffer containing the data that have been received.
-        :returns: The number of bytes in the response.
-        '''
-        hi_byte = byte2int(buffer[2])
-        lo_byte = byte2int(buffer[3])
-        return (hi_byte << 16) + lo_byte + 6
-
-    def __init__(self, values=None, **kwargs):
-        ''' Initializes a new instance
-
-        :param values: The list of values of the fifo to return
-        '''
-        ModbusResponse.__init__(self, **kwargs)
-        self.values = values or []
-
-    def encode(self):
-        ''' Encodes the response
-
-        :returns: The byte encoded message
-        '''
-        length = len(self.values) * 2
-        packet = struct.pack('>HH', 2 + length, length)
-        for value in self.values:
-            packet += struct.pack('>H', value)
-        return packet
-
-    def decode(self, data):
-        ''' Decodes a the response
-
-        :param data: The packet data to decode
-        '''
-        self.values = []
-        _, count = struct.unpack('>HH', data[0:4])
-        for index in range(0, count - 4):
-            idx = 4 + index * 2
-            self.values.append(struct.unpack('>H', data[idx:idx + 2])[0])
-
-#---------------------------------------------------------------------------#
-# Exported symbols
-#---------------------------------------------------------------------------#
-__all__ = [
-    "FileRecord",
-    "ReadFileRecordRequest", "ReadFileRecordResponse",
-    "WriteFileRecordRequest", "WriteFileRecordResponse",
-    "ReadFifoQueueRequest", "ReadFifoQueueResponse",
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/framer/__init__.py b/venv/lib/python3.7/site-packages/pymodbus/framer/__init__.py
deleted file mode 100644
index 5d84cc4..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/framer/__init__.py
+++ /dev/null
@@ -1,47 +0,0 @@
-from pymodbus.interfaces import IModbusFramer
-import struct
-
-# Unit ID, Function Code
-BYTE_ORDER = '>'
-FRAME_HEADER = 'BB'
-
-# Transaction Id, Protocol ID, Length, Unit ID, Function Code
-SOCKET_FRAME_HEADER = BYTE_ORDER + 'HHH' + FRAME_HEADER
-
-
-class ModbusFramer(IModbusFramer):
-    """
-    Base Framer class
-    """
-
-    def _validate_unit_id(self, units, single):
-        """
-        Validates if the received data is valid for the client
-        :param units: list of unit id for which the transaction is valid
-        :param single: Set to true to treat this as a single context
-        :return:         """
-
-        if single:
-            return True
-        else:
-            if 0 in units or 0xFF in units:
-                # Handle Modbus TCP unit identifier (0x00 0r 0xFF)
-                # in asynchronous requests
-                return True
-            return self._header['uid'] in units
-
-    def sendPacket(self, message):
-        """
-        Sends packets on the bus with 3.5char delay between frames
-        :param message: Message to be sent over the bus
-        :return:
-        """
-        return self.client.send(message)
-
-    def recvPacket(self, size):
-        """
-        Receives packet from the bus with specified len
-        :param size: Number of bytes to read
-        :return:
-        """
-        return self.client.recv(size)
diff --git a/venv/lib/python3.7/site-packages/pymodbus/framer/ascii_framer.py b/venv/lib/python3.7/site-packages/pymodbus/framer/ascii_framer.py
deleted file mode 100644
index a88f649..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/framer/ascii_framer.py
+++ /dev/null
@@ -1,208 +0,0 @@
-import struct
-from binascii import b2a_hex, a2b_hex
-
-from pymodbus.exceptions import ModbusIOException
-from pymodbus.utilities import checkLRC, computeLRC
-from pymodbus.framer import ModbusFramer, FRAME_HEADER, BYTE_ORDER
-
-
-ASCII_FRAME_HEADER = BYTE_ORDER + FRAME_HEADER
-
-# --------------------------------------------------------------------------- #
-# Logging
-# --------------------------------------------------------------------------- #
-import logging
-_logger = logging.getLogger(__name__)
-
-
-# --------------------------------------------------------------------------- #
-# Modbus ASCII Message
-# --------------------------------------------------------------------------- #
-class ModbusAsciiFramer(ModbusFramer):
-    """
-    Modbus ASCII Frame Controller::
-
-        [ Start ][Address ][ Function ][ Data ][ LRC ][ End ]
-          1c        2c         2c         Nc     2c      2c
-
-        * data can be 0 - 2x252 chars
-        * end is '\\r\\n' (Carriage return line feed), however the line feed
-          character can be changed via a special command
-        * start is ':'
-
-    This framer is used for serial transmission.  Unlike the RTU protocol,
-    the data in this framer is transferred in plain text ascii.
-    """
-
-    def __init__(self, decoder, client=None):
-        """ Initializes a new instance of the framer
-
-        :param decoder: The decoder implementation to use
-        """
-        self._buffer = b''
-        self._header = {'lrc': '0000', 'len': 0, 'uid': 0x00}
-        self._hsize = 0x02
-        self._start = b':'
-        self._end = b"\r\n"
-        self.decoder = decoder
-        self.client = client
-
-    # ----------------------------------------------------------------------- #
-    # Private Helper Functions
-    # ----------------------------------------------------------------------- #
-    def decode_data(self, data):
-        if len(data) > 1:
-            uid = int(data[1:3], 16)
-            fcode = int(data[3:5], 16)
-            return dict(unit=uid, fcode=fcode)
-        return dict()
-
-    def checkFrame(self):
-        """ Check and decode the next frame
-
-        :returns: True if we successful, False otherwise
-        """
-        start = self._buffer.find(self._start)
-        if start == -1:
-            return False
-        if start > 0:  # go ahead and skip old bad data
-            self._buffer = self._buffer[start:]
-            start = 0
-
-        end = self._buffer.find(self._end)
-        if end != -1:
-            self._header['len'] = end
-            self._header['uid'] = int(self._buffer[1:3], 16)
-            self._header['lrc'] = int(self._buffer[end - 2:end], 16)
-            data = a2b_hex(self._buffer[start + 1:end - 2])
-            return checkLRC(data, self._header['lrc'])
-        return False
-
-    def advanceFrame(self):
-        """ Skip over the current framed message
-        This allows us to skip over the current message after we have processed
-        it or determined that it contains an error. It also has to reset the
-        current frame header handle
-        """
-        self._buffer = self._buffer[self._header['len'] + 2:]
-        self._header = {'lrc': '0000', 'len': 0, 'uid': 0x00}
-
-    def isFrameReady(self):
-        """ Check if we should continue decode logic
-        This is meant to be used in a while loop in the decoding phase to let
-        the decoder know that there is still data in the buffer.
-
-        :returns: True if ready, False otherwise
-        """
-        return len(self._buffer) > 1
-
-    def addToFrame(self, message):
-        """ Add the next message to the frame buffer
-        This should be used before the decoding while loop to add the received
-        data to the buffer handle.
-
-        :param message: The most recent packet
-        """
-        self._buffer += message
-
-    def getFrame(self):
-        """ Get the next frame from the buffer
-
-        :returns: The frame data or ''
-        """
-        start = self._hsize + 1
-        end = self._header['len'] - 2
-        buffer = self._buffer[start:end]
-        if end > 0:
-            return a2b_hex(buffer)
-        return b''
-
-    def resetFrame(self):
-        """ Reset the entire message frame.
-        This allows us to skip ovver errors that may be in the stream.
-        It is hard to know if we are simply out of sync or if there is
-        an error in the stream as we have no way to check the start or
-        end of the message (python just doesn't have the resolution to
-        check for millisecond delays).
-        """
-        self._buffer = b''
-        self._header = {'lrc': '0000', 'len': 0, 'uid': 0x00}
-
-    def populateResult(self, result):
-        """ Populates the modbus result header
-
-        The serial packets do not have any header information
-        that is copied.
-
-        :param result: The response packet
-        """
-        result.unit_id = self._header['uid']
-
-    # ----------------------------------------------------------------------- #
-    # Public Member Functions
-    # ----------------------------------------------------------------------- #
-    def processIncomingPacket(self, data, callback, unit, **kwargs):
-        """
-        The new packet processing pattern
-
-        This takes in a new request packet, adds it to the current
-        packet stream, and performs framing on it. That is, checks
-        for complete messages, and once found, will process all that
-        exist.  This handles the case when we read N + 1 or 1 // N
-        messages at a time instead of 1.
-
-        The processed and decoded messages are pushed to the callback
-        function to process and send.
-
-        :param data: The new packet data
-        :param callback: The function to send results to
-        :param unit: Process if unit id matches, ignore otherwise (could be a
-               list of unit ids (server) or single unit id(client/server))
-        :param single: True or False (If True, ignore unit address validation)
-
-        """
-        if not isinstance(unit, (list, tuple)):
-            unit = [unit]
-        single = kwargs.get('single', False)
-        self.addToFrame(data)
-        while self.isFrameReady():
-            if self.checkFrame():
-                if self._validate_unit_id(unit, single):
-                    frame = self.getFrame()
-                    result = self.decoder.decode(frame)
-                    if result is None:
-                        raise ModbusIOException("Unable to decode response")
-                    self.populateResult(result)
-                    self.advanceFrame()
-                    callback(result)  # defer this
-                else:
-                    _logger.error("Not a valid unit id - {}, "
-                                  "ignoring!!".format(self._header['uid']))
-                    self.resetFrame()
-            else:
-                break
-
-    def buildPacket(self, message):
-        """ Creates a ready to send modbus packet
-        Built off of a  modbus request/response
-
-        :param message: The request/response to send
-        :return: The encoded packet
-        """
-        encoded = message.encode()
-        buffer = struct.pack(ASCII_FRAME_HEADER, message.unit_id,
-                             message.function_code)
-        checksum = computeLRC(encoded + buffer)
-
-        packet = bytearray()
-        params = (message.unit_id, message.function_code)
-        packet.extend(self._start)
-        packet.extend(('%02x%02x' % params).encode())
-        packet.extend(b2a_hex(encoded))
-        packet.extend(('%02x' % checksum).encode())
-        packet.extend(self._end)
-        return bytes(packet).upper()
-
-
-# __END__
-
diff --git a/venv/lib/python3.7/site-packages/pymodbus/framer/binary_framer.py b/venv/lib/python3.7/site-packages/pymodbus/framer/binary_framer.py
deleted file mode 100644
index ba6655b..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/framer/binary_framer.py
+++ /dev/null
@@ -1,227 +0,0 @@
-import struct
-from pymodbus.exceptions import ModbusIOException
-from pymodbus.utilities import checkCRC, computeCRC
-from pymodbus.framer import ModbusFramer, FRAME_HEADER, BYTE_ORDER
-
-# --------------------------------------------------------------------------- #
-# Logging
-# --------------------------------------------------------------------------- #
-import logging
-_logger = logging.getLogger(__name__)
-
-BINARY_FRAME_HEADER = BYTE_ORDER + FRAME_HEADER
-
-# --------------------------------------------------------------------------- #
-# Modbus Binary Message
-# --------------------------------------------------------------------------- #
-
-
-class ModbusBinaryFramer(ModbusFramer):
-    """
-    Modbus Binary Frame Controller::
-
-        [ Start ][Address ][ Function ][ Data ][ CRC ][ End ]
-          1b        1b         1b         Nb     2b     1b
-
-        * data can be 0 - 2x252 chars
-        * end is   '}'
-        * start is '{'
-
-    The idea here is that we implement the RTU protocol, however,
-    instead of using timing for message delimiting, we use start
-    and end of message characters (in this case { and }). Basically,
-    this is a binary framer.
-
-    The only case we have to watch out for is when a message contains
-    the { or } characters.  If we encounter these characters, we
-    simply duplicate them.  Hopefully we will not encounter those
-    characters that often and will save a little bit of bandwitch
-    without a real-time system.
-
-    Protocol defined by jamod.sourceforge.net.
-    """
-
-    def __init__(self, decoder, client=None):
-        """ Initializes a new instance of the framer
-
-        :param decoder: The decoder implementation to use
-        """
-        self._buffer = b''
-        self._header = {'crc': 0x0000, 'len': 0, 'uid': 0x00}
-        self._hsize = 0x01
-        self._start = b'\x7b'  # {
-        self._end = b'\x7d'  # }
-        self._repeat = [b'}'[0], b'{'[0]] # python3 hack
-        self.decoder = decoder
-        self.client = client
-
-    # ----------------------------------------------------------------------- #
-    # Private Helper Functions
-    # ----------------------------------------------------------------------- #
-    def decode_data(self, data):
-        if len(data) > self._hsize:
-            uid = struct.unpack('>B', data[1:2])[0]
-            fcode = struct.unpack('>B', data[2:3])[0]
-            return dict(unit=uid, fcode=fcode)
-        return dict()
-
-    def checkFrame(self):
-        """ Check and decode the next frame
-
-        :returns: True if we are successful, False otherwise
-        """
-        start = self._buffer.find(self._start)
-        if start == -1:
-            return False
-        if start > 0:  # go ahead and skip old bad data
-            self._buffer = self._buffer[start:]
-
-        end = self._buffer.find(self._end)
-        if end != -1:
-            self._header['len'] = end
-            self._header['uid'] = struct.unpack('>B', self._buffer[1:2])[0]
-            self._header['crc'] = struct.unpack('>H', self._buffer[end - 2:end])[0]
-            data = self._buffer[start + 1:end - 2]
-            return checkCRC(data, self._header['crc'])
-        return False
-
-    def advanceFrame(self):
-        """ Skip over the current framed message
-        This allows us to skip over the current message after we have processed
-        it or determined that it contains an error. It also has to reset the
-        current frame header handle
-        """
-        self._buffer = self._buffer[self._header['len'] + 2:]
-        self._header = {'crc':0x0000, 'len':0, 'uid':0x00}
-
-    def isFrameReady(self):
-        """ Check if we should continue decode logic
-        This is meant to be used in a while loop in the decoding phase to let
-        the decoder know that there is still data in the buffer.
-
-        :returns: True if ready, False otherwise
-        """
-        return len(self._buffer) > 1
-
-    def addToFrame(self, message):
-        """ Add the next message to the frame buffer
-        This should be used before the decoding while loop to add the received
-        data to the buffer handle.
-
-        :param message: The most recent packet
-        """
-        self._buffer += message
-
-    def getFrame(self):
-        """ Get the next frame from the buffer
-
-        :returns: The frame data or ''
-        """
-        start = self._hsize + 1
-        end = self._header['len'] - 2
-        buffer = self._buffer[start:end]
-        if end > 0:
-            return buffer
-        return b''
-
-    def populateResult(self, result):
-        """ Populates the modbus result header
-
-        The serial packets do not have any header information
-        that is copied.
-
-        :param result: The response packet
-        """
-        result.unit_id = self._header['uid']
-
-    # ----------------------------------------------------------------------- #
-    # Public Member Functions
-    # ----------------------------------------------------------------------- #
-    def processIncomingPacket(self, data, callback, unit, **kwargs):
-        """
-        The new packet processing pattern
-
-        This takes in a new request packet, adds it to the current
-        packet stream, and performs framing on it. That is, checks
-        for complete messages, and once found, will process all that
-        exist.  This handles the case when we read N + 1 or 1 // N
-        messages at a time instead of 1.
-
-        The processed and decoded messages are pushed to the callback
-        function to process and send.
-
-        :param data: The new packet data
-        :param callback: The function to send results to
-        :param unit: Process if unit id matches, ignore otherwise (could be a
-               list of unit ids (server) or single unit id(client/server)
-        :param single: True or False (If True, ignore unit address validation)
-
-        """
-        self.addToFrame(data)
-        if not isinstance(unit, (list, tuple)):
-            unit = [unit]
-        single = kwargs.get('single', False)
-        while self.isFrameReady():
-            if self.checkFrame():
-                if self._validate_unit_id(unit, single):
-                    result = self.decoder.decode(self.getFrame())
-                    if result is None:
-                        raise ModbusIOException("Unable to decode response")
-                    self.populateResult(result)
-                    self.advanceFrame()
-                    callback(result)  # defer or push to a thread?
-                else:
-                    _logger.debug("Not a valid unit id - {}, "
-                                  "ignoring!!".format(self._header['uid']))
-                    self.resetFrame()
-                    break
-
-            else:
-                _logger.debug("Frame check failed, ignoring!!")
-                self.resetFrame()
-                break
-
-    def buildPacket(self, message):
-        """ Creates a ready to send modbus packet
-
-        :param message: The request/response to send
-        :returns: The encoded packet
-        """
-        data = self._preflight(message.encode())
-        packet = struct.pack(BINARY_FRAME_HEADER,
-                             message.unit_id,
-                             message.function_code) + data
-        packet += struct.pack(">H", computeCRC(packet))
-        packet = self._start + packet + self._end
-        return packet
-
-    def _preflight(self, data):
-        """
-        Preflight buffer test
-
-        This basically scans the buffer for start and end
-        tags and if found, escapes them.
-
-        :param data: The message to escape
-        :returns: the escaped packet
-        """
-        array = bytearray()
-        for d in data:
-            if d in self._repeat:
-                array.append(d)
-            array.append(d)
-        return bytes(array)
-
-    def resetFrame(self):
-        """ Reset the entire message frame.
-        This allows us to skip ovver errors that may be in the stream.
-        It is hard to know if we are simply out of sync or if there is
-        an error in the stream as we have no way to check the start or
-        end of the message (python just doesn't have the resolution to
-        check for millisecond delays).
-        """
-        self._buffer = b''
-        self._header = {'crc': 0x0000, 'len': 0, 'uid': 0x00}
-
-
-# __END__
diff --git a/venv/lib/python3.7/site-packages/pymodbus/framer/rtu_framer.py b/venv/lib/python3.7/site-packages/pymodbus/framer/rtu_framer.py
deleted file mode 100644
index c2d74d0..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/framer/rtu_framer.py
+++ /dev/null
@@ -1,324 +0,0 @@
-import struct
-import time
-
-from pymodbus.exceptions import ModbusIOException
-from pymodbus.exceptions import InvalidMessageReceivedException
-from pymodbus.utilities import checkCRC, computeCRC
-from pymodbus.utilities import hexlify_packets, ModbusTransactionState
-from pymodbus.compat import byte2int
-from pymodbus.framer import ModbusFramer, FRAME_HEADER, BYTE_ORDER
-
-# --------------------------------------------------------------------------- #
-# Logging
-# --------------------------------------------------------------------------- #
-import logging
-_logger = logging.getLogger(__name__)
-
-RTU_FRAME_HEADER = BYTE_ORDER + FRAME_HEADER
-
-
-# --------------------------------------------------------------------------- #
-# Modbus RTU Message
-# --------------------------------------------------------------------------- #
-class ModbusRtuFramer(ModbusFramer):
-    """
-    Modbus RTU Frame controller::
-
-        [ Start Wait ] [Address ][ Function Code] [ Data ][ CRC ][  End Wait  ]
-          3.5 chars     1b         1b               Nb      2b      3.5 chars
-
-    Wait refers to the amount of time required to transmit at least x many
-    characters.  In this case it is 3.5 characters.  Also, if we receive a
-    wait of 1.5 characters at any point, we must trigger an error message.
-    Also, it appears as though this message is little endian. The logic is
-    simplified as the following::
-
-        block-on-read:
-            read until 3.5 delay
-            check for errors
-            decode
-
-    The following table is a listing of the baud wait times for the specified
-    baud rates::
-
-        ------------------------------------------------------------------
-         Baud  1.5c (18 bits)   3.5c (38 bits)
-        ------------------------------------------------------------------
-         1200   13333.3 us       31666.7 us
-         4800    3333.3 us        7916.7 us
-         9600    1666.7 us        3958.3 us
-        19200     833.3 us        1979.2 us
-        38400     416.7 us         989.6 us
-        ------------------------------------------------------------------
-        1 Byte = start + 8 bits + parity + stop = 11 bits
-        (1/Baud)(bits) = delay seconds
-    """
-
-    def __init__(self, decoder, client=None):
-        """ Initializes a new instance of the framer
-
-        :param decoder: The decoder factory implementation to use
-        """
-        self._buffer = b''
-        self._header = {'uid': 0x00, 'len': 0, 'crc': '0000'}
-        self._hsize = 0x01
-        self._end = b'\x0d\x0a'
-        self._min_frame_size = 4
-        self.decoder = decoder
-        self.client = client
-
-    # ----------------------------------------------------------------------- #
-    # Private Helper Functions
-    # ----------------------------------------------------------------------- #
-    def decode_data(self, data):
-        if len(data) > self._hsize:
-            uid = byte2int(data[0])
-            fcode = byte2int(data[1])
-            return dict(unit=uid, fcode=fcode)
-        return dict()
-
-    def checkFrame(self):
-        """
-        Check if the next frame is available.
-        Return True if we were successful.
-
-        1. Populate header
-        2. Discard frame if UID does not match
-        """
-        try:
-            self.populateHeader()
-            frame_size = self._header['len']
-            data = self._buffer[:frame_size - 2]
-            crc = self._buffer[frame_size - 2:frame_size]
-            crc_val = (byte2int(crc[0]) << 8) + byte2int(crc[1])
-            if checkCRC(data, crc_val):
-                return True
-            else:
-                _logger.debug("CRC invalid, discarding header!!")
-                self.resetFrame()
-                return False
-        except (IndexError, KeyError, struct.error):
-            return False
-
-    def advanceFrame(self):
-        """
-        Skip over the current framed message
-        This allows us to skip over the current message after we have processed
-        it or determined that it contains an error. It also has to reset the
-        current frame header handle
-        """
-        try:
-            self._buffer = self._buffer[self._header['len']:]
-        except KeyError:
-            #   Error response, no header len found
-            self.resetFrame()
-        _logger.debug("Frame advanced, resetting header!!")
-        self._header = {}
-
-    def resetFrame(self):
-        """
-        Reset the entire message frame.
-        This allows us to skip over errors that may be in the stream.
-        It is hard to know if we are simply out of sync or if there is
-        an error in the stream as we have no way to check the start or
-        end of the message (python just doesn't have the resolution to
-        check for millisecond delays).
-        """
-        _logger.debug("Resetting frame - Current Frame in "
-                      "buffer - {}".format(hexlify_packets(self._buffer)))
-        self._buffer = b''
-        self._header = {}
-
-    def isFrameReady(self):
-        """
-        Check if we should continue decode logic
-        This is meant to be used in a while loop in the decoding phase to let
-        the decoder know that there is still data in the buffer.
-
-        :returns: True if ready, False otherwise
-        """
-        return len(self._buffer) > self._hsize
-
-    def populateHeader(self, data=None):
-        """
-        Try to set the headers `uid`, `len` and `crc`.
-
-        This method examines `self._buffer` and writes meta
-        information into `self._header`. It calculates only the
-        values for headers that are not already in the dictionary.
-
-        Beware that this method will raise an IndexError if
-        `self._buffer` is not yet long enough.
-        """
-        data = data if data else self._buffer
-        self._header['uid'] = byte2int(data[0])
-        func_code = byte2int(data[1])
-        pdu_class = self.decoder.lookupPduClass(func_code)
-        size = pdu_class.calculateRtuFrameSize(data)
-        self._header['len'] = size
-        self._header['crc'] = data[size - 2:size]
-
-    def addToFrame(self, message):
-        """
-        This should be used before the decoding while loop to add the received
-        data to the buffer handle.
-
-        :param message: The most recent packet
-        """
-        self._buffer += message
-
-    def getFrame(self):
-        """
-        Get the next frame from the buffer
-
-        :returns: The frame data or ''
-        """
-        start = self._hsize
-        end = self._header['len'] - 2
-        buffer = self._buffer[start:end]
-        if end > 0:
-            _logger.debug("Getting Frame - {}".format(hexlify_packets(buffer)))
-            return buffer
-        return b''
-
-    def populateResult(self, result):
-        """
-        Populates the modbus result header
-
-        The serial packets do not have any header information
-        that is copied.
-
-        :param result: The response packet
-        """
-        result.unit_id = self._header['uid']
-        result.transaction_id = self._header['uid']
-
-    # ----------------------------------------------------------------------- #
-    # Public Member Functions
-    # ----------------------------------------------------------------------- #
-    def processIncomingPacket(self, data, callback, unit, **kwargs):
-        """
-        The new packet processing pattern
-
-        This takes in a new request packet, adds it to the current
-        packet stream, and performs framing on it. That is, checks
-        for complete messages, and once found, will process all that
-        exist.  This handles the case when we read N + 1 or 1 // N
-        messages at a time instead of 1.
-
-        The processed and decoded messages are pushed to the callback
-        function to process and send.
-
-        :param data: The new packet data
-        :param callback: The function to send results to
-        :param unit: Process if unit id matches, ignore otherwise (could be a
-               list of unit ids (server) or single unit id(client/server)
-        :param single: True or False (If True, ignore unit address validation)
-
-        """
-        if not isinstance(unit, (list, tuple)):
-            unit = [unit]
-        self.addToFrame(data)
-        single = kwargs.get("single", False)
-        if self.isFrameReady():
-            if self.checkFrame():
-                if self._validate_unit_id(unit, single):
-                    self._process(callback)
-                else:
-                    _logger.debug("Not a valid unit id - {}, "
-                                  "ignoring!!".format(self._header['uid']))
-                    self.resetFrame()
-            else:
-                _logger.debug("Frame check failed, ignoring!!")
-                self.resetFrame()
-        else:
-            _logger.debug("Frame - [{}] not ready".format(data))
-
-    def buildPacket(self, message):
-        """
-        Creates a ready to send modbus packet
-
-        :param message: The populated request/response to send
-        """
-        data = message.encode()
-        packet = struct.pack(RTU_FRAME_HEADER,
-                             message.unit_id,
-                             message.function_code) + data
-        packet += struct.pack(">H", computeCRC(packet))
-        message.transaction_id = message.unit_id  # Ensure that transaction is actually the unit id for serial comms
-        return packet
-
-    def sendPacket(self, message):
-        """
-        Sends packets on the bus with 3.5char delay between frames
-        :param message: Message to be sent over the bus
-        :return:
-        """
-        start = time.time()
-        timeout = start + self.client.timeout
-        while self.client.state != ModbusTransactionState.IDLE:
-            if self.client.state == ModbusTransactionState.TRANSACTION_COMPLETE:
-                ts = round(time.time(), 6)
-                _logger.debug("Changing state to IDLE - Last Frame End - {}, "
-                              "Current Time stamp - {}".format(
-                    self.client.last_frame_end, ts)
-                )
-
-                if self.client.last_frame_end:
-                    idle_time = self.client.idle_time()
-                    if round(ts - idle_time, 6) <= self.client.silent_interval:
-                        _logger.debug("Waiting for 3.5 char before next "
-                                      "send - {} ms".format(
-                            self.client.silent_interval * 1000)
-                        )
-                        time.sleep(self.client.silent_interval)
-                else:
-                    # Recovering from last error ??
-                    time.sleep(self.client.silent_interval)
-                self.client.state = ModbusTransactionState.IDLE
-            else:
-                if time.time() > timeout:
-                    _logger.debug("Spent more time than the read time out, "
-                                  "resetting the transaction to IDLE")
-                    self.client.state = ModbusTransactionState.IDLE
-                else:
-                    _logger.debug("Sleeping")
-                    time.sleep(self.client.silent_interval)
-        size = self.client.send(message)
-        self.client.last_frame_end = round(time.time(), 6)
-        return size
-
-    def recvPacket(self, size):
-        """
-        Receives packet from the bus with specified len
-        :param size: Number of bytes to read
-        :return:
-        """
-        result = self.client.recv(size)
-        self.client.last_frame_end = round(time.time(), 6)
-        return result
-
-    def _process(self, callback, error=False):
-        """
-        Process incoming packets irrespective error condition
-        """
-        data = self.getRawFrame() if error else self.getFrame()
-        result = self.decoder.decode(data)
-        if result is None:
-            raise ModbusIOException("Unable to decode request")
-        elif error and result.function_code < 0x80:
-            raise InvalidMessageReceivedException(result)
-        else:
-            self.populateResult(result)
-            self.advanceFrame()
-            callback(result)  # defer or push to a thread?
-
-    def getRawFrame(self):
-        """
-        Returns the complete buffer
-        """
-        _logger.debug("Getting Raw Frame - "
-                      "{}".format(hexlify_packets(self._buffer)))
-        return self._buffer
-
-# __END__
diff --git a/venv/lib/python3.7/site-packages/pymodbus/framer/socket_framer.py b/venv/lib/python3.7/site-packages/pymodbus/framer/socket_framer.py
deleted file mode 100644
index fff99d9..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/framer/socket_framer.py
+++ /dev/null
@@ -1,217 +0,0 @@
-import struct
-from pymodbus.exceptions import ModbusIOException
-from pymodbus.exceptions import InvalidMessageReceivedException
-from pymodbus.utilities import hexlify_packets
-from pymodbus.framer import ModbusFramer, SOCKET_FRAME_HEADER
-
-# --------------------------------------------------------------------------- #
-# Logging
-# --------------------------------------------------------------------------- #
-import logging
-_logger = logging.getLogger(__name__)
-
-# --------------------------------------------------------------------------- #
-# Modbus TCP Message
-# --------------------------------------------------------------------------- #
-
-
-class ModbusSocketFramer(ModbusFramer):
-    """ Modbus Socket Frame controller
-
-    Before each modbus TCP message is an MBAP header which is used as a
-    message frame.  It allows us to easily separate messages as follows::
-
-        [         MBAP Header         ] [ Function Code] [ Data ] \
-        [ tid ][ pid ][ length ][ uid ]
-          2b     2b     2b        1b           1b           Nb
-
-        while len(message) > 0:
-            tid, pid, length`, uid = struct.unpack(">HHHB", message)
-            request = message[0:7 + length - 1`]
-            message = [7 + length - 1:]
-
-        * length = uid + function code + data
-        * The -1 is to account for the uid byte
-    """
-
-    def __init__(self, decoder, client=None):
-        """ Initializes a new instance of the framer
-
-        :param decoder: The decoder factory implementation to use
-        """
-        self._buffer = b''
-        self._header = {'tid': 0, 'pid': 0, 'len': 0, 'uid': 0}
-        self._hsize = 0x07
-        self.decoder = decoder
-        self.client = client
-
-    # ----------------------------------------------------------------------- #
-    # Private Helper Functions
-    # ----------------------------------------------------------------------- #
-    def checkFrame(self):
-        """
-        Check and decode the next frame Return true if we were successful
-        """
-        if self.isFrameReady():
-            (self._header['tid'], self._header['pid'],
-             self._header['len'], self._header['uid']) = struct.unpack(
-                '>HHHB', self._buffer[0:self._hsize])
-
-            # someone sent us an error? ignore it
-            if self._header['len'] < 2:
-                self.advanceFrame()
-            # we have at least a complete message, continue
-            elif len(self._buffer) - self._hsize + 1 >= self._header['len']:
-                return True
-        # we don't have enough of a message yet, wait
-        return False
-
-    def advanceFrame(self):
-        """ Skip over the current framed message
-        This allows us to skip over the current message after we have processed
-        it or determined that it contains an error. It also has to reset the
-        current frame header handle
-        """
-        length = self._hsize + self._header['len'] - 1
-        self._buffer = self._buffer[length:]
-        self._header = {'tid': 0, 'pid': 0, 'len': 0, 'uid': 0}
-
-    def isFrameReady(self):
-        """ Check if we should continue decode logic
-        This is meant to be used in a while loop in the decoding phase to let
-        the decoder factory know that there is still data in the buffer.
-
-        :returns: True if ready, False otherwise
-        """
-        return len(self._buffer) > self._hsize
-
-    def addToFrame(self, message):
-        """ Adds new packet data to the current frame buffer
-
-        :param message: The most recent packet
-        """
-        self._buffer += message
-
-    def getFrame(self):
-        """ Return the next frame from the buffered data
-
-        :returns: The next full frame buffer
-        """
-        length = self._hsize + self._header['len'] - 1
-        return self._buffer[self._hsize:length]
-
-    def populateResult(self, result):
-        """
-        Populates the modbus result with the transport specific header
-        information (pid, tid, uid, checksum, etc)
-
-        :param result: The response packet
-        """
-        result.transaction_id = self._header['tid']
-        result.protocol_id = self._header['pid']
-        result.unit_id = self._header['uid']
-
-    # ----------------------------------------------------------------------- #
-    # Public Member Functions
-    # ----------------------------------------------------------------------- #
-    def decode_data(self, data):
-        if len(data) > self._hsize:
-            tid, pid, length, uid, fcode = struct.unpack(SOCKET_FRAME_HEADER,
-                                                         data[0:self._hsize+1])
-            return dict(tid=tid, pid=pid, lenght=length, unit=uid, fcode=fcode)
-        return dict()
-
-    def processIncomingPacket(self, data, callback, unit, **kwargs):
-        """
-        The new packet processing pattern
-
-        This takes in a new request packet, adds it to the current
-        packet stream, and performs framing on it. That is, checks
-        for complete messages, and once found, will process all that
-        exist.  This handles the case when we read N + 1 or 1 // N
-        messages at a time instead of 1.
-
-        The processed and decoded messages are pushed to the callback
-        function to process and send.
-
-        :param data: The new packet data
-        :param callback: The function to send results to
-        :param unit: Process if unit id matches, ignore otherwise (could be a
-               list of unit ids (server) or single unit id(client/server)
-        :param single: True or False (If True, ignore unit address validation)
-        :return:
-        """
-        if not isinstance(unit, (list, tuple)):
-            unit = [unit]
-        single = kwargs.get("single", False)
-        _logger.debug("Processing: " + hexlify_packets(data))
-        self.addToFrame(data)
-        while True:
-            if self.isFrameReady():
-                if self.checkFrame():
-                    if self._validate_unit_id(unit, single):
-                        self._process(callback)
-                    else:
-                        _logger.debug("Not a valid unit id - {}, "
-                                      "ignoring!!".format(self._header['uid']))
-                        self.resetFrame()
-                else:
-                    _logger.debug("Frame check failed, ignoring!!")
-                    self.resetFrame()
-            else:
-                if len(self._buffer):
-                    # Possible error ???
-                    if self._header['len'] < 2:
-                        self._process(callback, error=True)
-                break
-
-    def _process(self, callback, error=False):
-        """
-        Process incoming packets irrespective error condition
-        """
-        data = self.getRawFrame() if error else self.getFrame()
-        result = self.decoder.decode(data)
-        if result is None:
-            raise ModbusIOException("Unable to decode request")
-        elif error and result.function_code < 0x80:
-            raise InvalidMessageReceivedException(result)
-        else:
-            self.populateResult(result)
-            self.advanceFrame()
-            callback(result)  # defer or push to a thread?
-
-    def resetFrame(self):
-        """
-        Reset the entire message frame.
-        This allows us to skip ovver errors that may be in the stream.
-        It is hard to know if we are simply out of sync or if there is
-        an error in the stream as we have no way to check the start or
-        end of the message (python just doesn't have the resolution to
-        check for millisecond delays).
-        """
-        self._buffer = b''
-        self._header = {'tid': 0, 'pid': 0, 'len': 0, 'uid': 0}
-
-    def getRawFrame(self):
-        """
-        Returns the complete buffer
-        """
-        return self._buffer
-
-    def buildPacket(self, message):
-        """ Creates a ready to send modbus packet
-
-        :param message: The populated request/response to send
-        """
-        data = message.encode()
-        packet = struct.pack(SOCKET_FRAME_HEADER,
-                             message.transaction_id,
-                             message.protocol_id,
-                             len(data) + 2,
-                             message.unit_id,
-                             message.function_code)
-        packet += data
-        return packet
-
-
-# __END__
diff --git a/venv/lib/python3.7/site-packages/pymodbus/interfaces.py b/venv/lib/python3.7/site-packages/pymodbus/interfaces.py
deleted file mode 100644
index d32e997..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/interfaces.py
+++ /dev/null
@@ -1,248 +0,0 @@
-"""
-Pymodbus Interfaces
----------------------
-
-A collection of base classes that are used throughout
-the pymodbus library.
-"""
-from pymodbus.exceptions import (NotImplementedException,
-                                 MessageRegisterException)
-
-
-# --------------------------------------------------------------------------- #
-# Generic
-# --------------------------------------------------------------------------- #
-class Singleton(object):
-    """
-    Singleton base class
-    http://mail.python.org/pipermail/python-list/2007-July/450681.html
-    """
-    def __new__(cls, *args, **kwargs):
-        """ Create a new instance
-        """
-        if '_inst' not in vars(cls):
-            cls._inst = object.__new__(cls)
-        return cls._inst
-
-
-# --------------------------------------------------------------------------- #
-# Project Specific
-# --------------------------------------------------------------------------- #
-class IModbusDecoder(object):
-    """ Modbus Decoder Base Class
-
-    This interface must be implemented by a modbus message
-    decoder factory. These factories are responsible for
-    abstracting away converting a raw packet into a request / response
-    message object.
-    """
-
-    def decode(self, message):
-        """ Wrapper to decode a given packet
-
-        :param message: The raw modbus request packet
-        :return: The decoded modbus message or None if error
-        """
-        raise NotImplementedException(
-            "Method not implemented by derived class")
-
-    def lookupPduClass(self, function_code):
-        """ Use `function_code` to determine the class of the PDU.
-
-        :param function_code: The function code specified in a frame.
-        :returns: The class of the PDU that has a matching `function_code`.
-        """
-        raise NotImplementedException(
-            "Method not implemented by derived class")
-
-    def register(self, function=None):
-        """
-        Registers a function and sub function class with the decoder
-        :param function: Custom function class to register
-        :return:
-        """
-        raise NotImplementedException(
-            "Method not implemented by derived class")
-
-
-class IModbusFramer(object):
-    """
-    A framer strategy interface. The idea is that we abstract away all the
-    detail about how to detect if a current message frame exists, decoding
-    it, sending it, etc so that we can plug in a new Framer object (tcp,
-    rtu, ascii).
-    """
-
-    def checkFrame(self):
-        """ Check and decode the next frame
-
-        :returns: True if we successful, False otherwise
-        """
-        raise NotImplementedException(
-            "Method not implemented by derived class")
-
-    def advanceFrame(self):
-        """ Skip over the current framed message
-        This allows us to skip over the current message after we have processed
-        it or determined that it contains an error. It also has to reset the
-        current frame header handle
-        """
-        raise NotImplementedException(
-            "Method not implemented by derived class")
-
-    def addToFrame(self, message):
-        """ Add the next message to the frame buffer
-
-        This should be used before the decoding while loop to add the received
-        data to the buffer handle.
-
-        :param message: The most recent packet
-        """
-        raise NotImplementedException(
-            "Method not implemented by derived class")
-
-    def isFrameReady(self):
-        """ Check if we should continue decode logic
-
-        This is meant to be used in a while loop in the decoding phase to let
-        the decoder know that there is still data in the buffer.
-
-        :returns: True if ready, False otherwise
-        """
-        raise NotImplementedException(
-            "Method not implemented by derived class")
-
-    def getFrame(self):
-        """ Get the next frame from the buffer
-
-        :returns: The frame data or ''
-        """
-        raise NotImplementedException(
-            "Method not implemented by derived class")
-
-    def populateResult(self, result):
-        """ Populates the modbus result with current frame header
-
-        We basically copy the data back over from the current header
-        to the result header. This may not be needed for serial messages.
-
-        :param result: The response packet
-        """
-        raise NotImplementedException(
-            "Method not implemented by derived class")
-
-    def processIncomingPacket(self, data, callback):
-        """ The new packet processing pattern
-
-        This takes in a new request packet, adds it to the current
-        packet stream, and performs framing on it. That is, checks
-        for complete messages, and once found, will process all that
-        exist.  This handles the case when we read N + 1 or 1 / N
-        messages at a time instead of 1.
-
-        The processed and decoded messages are pushed to the callback
-        function to process and send.
-
-        :param data: The new packet data
-        :param callback: The function to send results to
-        """
-        raise NotImplementedException(
-            "Method not implemented by derived class")
-
-    def buildPacket(self, message):
-        """ Creates a ready to send modbus packet
-
-        The raw packet is built off of a fully populated modbus
-        request / response message.
-
-        :param message: The request/response to send
-        :returns: The built packet
-        """
-        raise NotImplementedException(
-            "Method not implemented by derived class")
-
-
-class IModbusSlaveContext(object):
-    """
-    Interface for a modbus slave data context
-
-    Derived classes must implemented the following methods:
-            reset(self)
-            validate(self, fx, address, count=1)
-            getValues(self, fx, address, count=1)
-            setValues(self, fx, address, values)
-    """
-    __fx_mapper = {2: 'd', 4: 'i'}
-    __fx_mapper.update([(i, 'h') for i in [3, 6, 16, 22, 23]])
-    __fx_mapper.update([(i, 'c') for i in [1, 5, 15]])
-
-    def decode(self, fx):
-        """ Converts the function code to the datastore to
-
-        :param fx: The function we are working with
-        :returns: one of [d(iscretes),i(inputs),h(oliding),c(oils)
-        """
-        return self.__fx_mapper[fx]
-
-    def reset(self):
-        """ Resets all the datastores to their default values
-        """
-        raise NotImplementedException("Context Reset")
-
-    def validate(self, fx, address, count=1):
-        """ Validates the request to make sure it is in range
-
-        :param fx: The function we are working with
-        :param address: The starting address
-        :param count: The number of values to test
-        :returns: True if the request in within range, False otherwise
-        """
-        raise NotImplementedException("validate context values")
-
-    def getValues(self, fx, address, count=1):
-        """ Get `count` values from datastore
-
-        :param fx: The function we are working with
-        :param address: The starting address
-        :param count: The number of values to retrieve
-        :returns: The requested values from a:a+c
-        """
-        raise NotImplementedException("get context values")
-
-    def setValues(self, fx, address, values):
-        """ Sets the datastore with the supplied values
-
-        :param fx: The function we are working with
-        :param address: The starting address
-        :param values: The new values to be set
-        """
-        raise NotImplementedException("set context values")
-
-
-class IPayloadBuilder(object):
-    """
-    This is an interface to a class that can build a payload
-    for a modbus register write command. It should abstract
-    the codec for encoding data to the required format
-    (bcd, binary, char, etc).
-    """
-
-    def build(self):
-        """ Return the payload buffer as a list
-
-        This list is two bytes per element and can
-        thus be treated as a list of registers.
-
-        :returns: The payload buffer as a list
-        """
-        raise NotImplementedException("set context values")
-
-
-# --------------------------------------------------------------------------- #
-# Exported symbols
-# --------------------------------------------------------------------------- #
-__all__ = [
-    'Singleton',
-    'IModbusDecoder', 'IModbusFramer', 'IModbusSlaveContext',
-    'IPayloadBuilder',
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/internal/__init__.py b/venv/lib/python3.7/site-packages/pymodbus/internal/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/venv/lib/python3.7/site-packages/pymodbus/internal/ptwisted.py b/venv/lib/python3.7/site-packages/pymodbus/internal/ptwisted.py
deleted file mode 100644
index fdd15a6..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/internal/ptwisted.py
+++ /dev/null
@@ -1,42 +0,0 @@
-'''
-A collection of twisted utility code
-'''
-from pymodbus.compat import IS_PYTHON2, IS_PYTHON3
-if IS_PYTHON2:
-    from twisted.cred import portal, checkers
-    from twisted.conch import manhole, manhole_ssh
-    from twisted.conch.insults import insults
-
-#---------------------------------------------------------------------------#
-# Logging
-#---------------------------------------------------------------------------#
-import logging
-_logger = logging.getLogger(__name__)
-
-
-#---------------------------------------------------------------------------#
-# Twisted Helper Methods
-#---------------------------------------------------------------------------#
-def InstallManagementConsole(namespace, users={'admin': 'admin'}, port=503):
-    ''' Helper method to start an ssh management console
-        for the modbus server.
-
-    :param namespace: The data to constrain the server to
-    :param users: The users to login with
-    :param port: The port to host the server on
-    '''
-    if IS_PYTHON3:
-        raise NotImplemented("This code currently doesn't work on python3")
-    from twisted.internet import reactor
-
-    def build_protocol():
-        p = insults.ServerProtocol(manhole.ColoredManhole, namespace)
-        return p
-
-    r = manhole_ssh.TerminalRealm()
-    r.chainedProtocolFactory = build_protocol
-    c = checkers.InMemoryUsernamePasswordDatabaseDontUse(**users)
-    p = portal.Portal(r, [c])
-    factory = manhole_ssh.ConchFactory(p)
-    reactor.listenTCP(port, factory)
-
diff --git a/venv/lib/python3.7/site-packages/pymodbus/mei_message.py b/venv/lib/python3.7/site-packages/pymodbus/mei_message.py
deleted file mode 100644
index 44f70ed..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/mei_message.py
+++ /dev/null
@@ -1,213 +0,0 @@
-'''
-Encapsulated Interface (MEI) Transport Messages
------------------------------------------------
-
-'''
-import struct
-from pymodbus.constants import DeviceInformation, MoreData
-from pymodbus.pdu import ModbusRequest
-from pymodbus.pdu import ModbusResponse
-from pymodbus.device import ModbusControlBlock
-from pymodbus.device import DeviceInformationFactory
-from pymodbus.pdu import ModbusExceptions as merror
-from pymodbus.compat import iteritems, byte2int, IS_PYTHON3
-
-_MCB = ModbusControlBlock()
-
-
-class _OutOfSpaceException(Exception):
-    # This exception exists here as a simple, local way to manage response
-    # length control for the only MODBUS command which requires it under
-    # standard, non-error conditions. It and the structures associated with
-    # it should ideally be refactored and applied to all responses, however,
-    # since a Client can make requests which result in disallowed conditions,
-    # such as, for instance, requesting a register read of more registers
-    # than will fit in a single PDU. As per the specification, the PDU is
-    # restricted to 253 bytes, irrespective of the transport used.
-    #
-    # See Page 5/50 of MODBUS Application Protocol Specification V1.1b3.
-    def __init__(self, oid):
-        self.oid = oid
-
-
-#---------------------------------------------------------------------------#
-# Read Device Information
-#---------------------------------------------------------------------------#
-class ReadDeviceInformationRequest(ModbusRequest):
-    '''
-    This function code allows reading the identification and additional
-    information relative to the physical and functional description of a
-    remote device, only.
-
-    The Read Device Identification interface is modeled as an address space
-    composed of a set of addressable data elements. The data elements are
-    called objects and an object Id identifies them.
-    '''
-    function_code = 0x2b
-    sub_function_code = 0x0e
-    _rtu_frame_size = 7
-
-    def __init__(self, read_code=None, object_id=0x00, **kwargs):
-        ''' Initializes a new instance
-
-        :param read_code: The device information read code
-        :param object_id: The object to read from
-        '''
-        ModbusRequest.__init__(self, **kwargs)
-        self.read_code = read_code or DeviceInformation.Basic
-        self.object_id = object_id
-
-    def encode(self):
-        ''' Encodes the request packet
-
-        :returns: The byte encoded packet
-        '''
-        packet = struct.pack('>BBB', self.sub_function_code,
-            self.read_code, self.object_id)
-        return packet
-
-    def decode(self, data):
-        ''' Decodes data part of the message.
-
-        :param data: The incoming data
-        '''
-        params = struct.unpack('>BBB', data)
-        self.sub_function_code, self.read_code, self.object_id = params
-
-    def execute(self, context):
-        ''' Run a read exeception status request against the store
-
-        :param context: The datastore to request from
-        :returns: The populated response
-        '''
-        if not (0x00 <= self.object_id <= 0xff):
-            return self.doException(merror.IllegalValue)
-        if not (0x00 <= self.read_code <= 0x04):
-            return self.doException(merror.IllegalValue)
-
-        information = DeviceInformationFactory.get(_MCB,
-            self.read_code, self.object_id)
-        return ReadDeviceInformationResponse(self.read_code, information)
-
-    def __str__(self):
-        ''' Builds a representation of the request
-
-        :returns: The string representation of the request
-        '''
-        params = (self.read_code, self.object_id)
-        return "ReadDeviceInformationRequest(%d,%d)" % params
-
-
-class ReadDeviceInformationResponse(ModbusResponse):
-    '''
-    '''
-    function_code = 0x2b
-    sub_function_code = 0x0e
-
-    @classmethod
-    def calculateRtuFrameSize(cls, buffer):
-        ''' Calculates the size of the message
-
-        :param buffer: A buffer containing the data that have been received.
-        :returns: The number of bytes in the response.
-        '''
-        size  = 8 # skip the header information
-        count = byte2int(buffer[7])
-
-        while count > 0:
-            _, object_length = struct.unpack('>BB', buffer[size:size+2])
-            size += object_length + 2
-            count -= 1
-        return size + 2
-
-    def __init__(self, read_code=None, information=None, **kwargs):
-        ''' Initializes a new instance
-
-        :param read_code: The device information read code
-        :param information: The requested information request
-        '''
-        ModbusResponse.__init__(self, **kwargs)
-        self.read_code = read_code or DeviceInformation.Basic
-        self.information = information or {}
-        self.number_of_objects = 0
-        self.conformity = 0x83  # I support everything right now
-        self.next_object_id = 0x00
-        self.more_follows = MoreData.Nothing
-        self.space_left = None
-
-    def _encode_object(self, object_id, data):
-        self.space_left -= (2 + len(data))
-        if self.space_left <= 0:
-            raise _OutOfSpaceException(object_id)
-        encoded_obj = struct.pack('>BB', object_id, len(data))
-        if IS_PYTHON3:
-            if isinstance(data, bytes):
-                encoded_obj += data
-            else:
-                encoded_obj += data.encode()
-        else:
-            encoded_obj += data.encode()
-        self.number_of_objects += 1
-        return encoded_obj
-
-    def encode(self):
-        ''' Encodes the response
-
-        :returns: The byte encoded message
-        '''
-        packet = struct.pack('>BBB', self.sub_function_code,
-                             self.read_code, self.conformity)
-        self.space_left = 253 - 6
-        objects = b''
-        try:
-            for (object_id, data) in iteritems(self.information):
-                if isinstance(data, list):
-                    for item in data:
-                        objects += self._encode_object(object_id, item)
-                else:
-                    objects += self._encode_object(object_id, data)
-        except _OutOfSpaceException as e:
-            self.next_object_id = e.oid
-            self.more_follows = MoreData.KeepReading
-
-        packet += struct.pack('>BBB', self.more_follows, self.next_object_id,
-                              self.number_of_objects)
-        packet += objects
-        return packet
-
-    def decode(self, data):
-        ''' Decodes a the response
-
-        :param data: The packet data to decode
-        '''
-        params = struct.unpack('>BBBBBB', data[0:6])
-        self.sub_function_code, self.read_code = params[0:2]
-        self.conformity, self.more_follows = params[2:4]
-        self.next_object_id, self.number_of_objects = params[4:6]
-        self.information, count = {}, 6 # skip the header information
-
-        while count < len(data):
-            object_id, object_length = struct.unpack('>BB', data[count:count+2])
-            count += object_length + 2
-            if object_id not in self.information.keys():
-                self.information[object_id] = data[count-object_length:count]
-            else:
-                if isinstance(self.information[object_id], list):
-                    self.information[object_id].append(data[count-object_length:count])
-                else:
-                    self.information[object_id] = [self.information[object_id],
-                                                   data[count - object_length:count]]
-
-    def __str__(self):
-        ''' Builds a representation of the response
-
-        :returns: The string representation of the response
-        '''
-        return "ReadDeviceInformationResponse(%d)" % self.read_code
-
-#---------------------------------------------------------------------------#
-# Exported symbols
-#---------------------------------------------------------------------------#
-__all__ = [
-    "ReadDeviceInformationRequest", "ReadDeviceInformationResponse",
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/other_message.py b/venv/lib/python3.7/site-packages/pymodbus/other_message.py
deleted file mode 100644
index 88c361b..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/other_message.py
+++ /dev/null
@@ -1,448 +0,0 @@
-'''
-Diagnostic record read/write
-
-Currently not all implemented
-'''
-import struct
-from pymodbus.constants import ModbusStatus
-from pymodbus.pdu import ModbusRequest
-from pymodbus.pdu import ModbusResponse
-from pymodbus.device import ModbusControlBlock, DeviceInformationFactory
-from pymodbus.compat import byte2int, int2byte
-
-_MCB = ModbusControlBlock()
-
-
-#---------------------------------------------------------------------------#
-# TODO Make these only work on serial
-#---------------------------------------------------------------------------#
-class ReadExceptionStatusRequest(ModbusRequest):
-    '''
-    This function code is used to read the contents of eight Exception Status
-    outputs in a remote device.  The function provides a simple method for
-    accessing this information, because the Exception Output references are
-    known (no output reference is needed in the function).
-    '''
-    function_code = 0x07
-    _rtu_frame_size = 4
-
-    def __init__(self, **kwargs):
-        ''' Initializes a new instance
-        '''
-        ModbusRequest.__init__(self, **kwargs)
-
-    def encode(self):
-        ''' Encodes the message
-        '''
-        return b''
-
-    def decode(self, data):
-        ''' Decodes data part of the message.
-
-        :param data: The incoming data
-        '''
-        pass
-
-    def execute(self, context=None):
-        ''' Run a read exeception status request against the store
-
-        :returns: The populated response
-        '''
-        status = _MCB.Counter.summary()
-        return ReadExceptionStatusResponse(status)
-
-    def __str__(self):
-        ''' Builds a representation of the request
-
-        :returns: The string representation of the request
-        '''
-        return "ReadExceptionStatusRequest(%d)" % (self.function_code)
-
-
-class ReadExceptionStatusResponse(ModbusResponse):
-    '''
-    The normal response contains the status of the eight Exception Status
-    outputs. The outputs are packed into one data byte, with one bit
-    per output. The status of the lowest output reference is contained
-    in the least significant bit of the byte.  The contents of the eight
-    Exception Status outputs are device specific.
-    '''
-    function_code = 0x07
-    _rtu_frame_size = 5
-
-    def __init__(self, status=0x00, **kwargs):
-        ''' Initializes a new instance
-
-        :param status: The status response to report
-        '''
-        ModbusResponse.__init__(self, **kwargs)
-        self.status = status
-
-    def encode(self):
-        ''' Encodes the response
-
-        :returns: The byte encoded message
-        '''
-        return struct.pack('>B', self.status)
-
-    def decode(self, data):
-        ''' Decodes a the response
-
-        :param data: The packet data to decode
-        '''
-        self.status = byte2int(data[0])
-
-    def __str__(self):
-        ''' Builds a representation of the response
-
-        :returns: The string representation of the response
-        '''
-        arguments = (self.function_code, self.status)
-        return "ReadExceptionStatusResponse(%d, %s)" % arguments
-
-# Encapsulate interface transport 43, 14
-# CANopen general reference 43, 13
-
-
-#---------------------------------------------------------------------------#
-# TODO Make these only work on serial
-#---------------------------------------------------------------------------#
-class GetCommEventCounterRequest(ModbusRequest):
-    '''
-    This function code is used to get a status word and an event count from
-    the remote device's communication event counter.
-
-    By fetching the current count before and after a series of messages, a
-    client can determine whether the messages were handled normally by the
-    remote device.
-
-    The device's event counter is incremented once  for each successful
-    message completion. It is not incremented for exception responses,
-    poll commands, or fetch event counter commands.
-
-    The event counter can be reset by means of the Diagnostics function
-    (code 08), with a subfunction of Restart Communications Option
-    (code 00 01) or Clear Counters and Diagnostic Register (code 00 0A).
-    '''
-    function_code = 0x0b
-    _rtu_frame_size = 4
-
-    def __init__(self, **kwargs):
-        ''' Initializes a new instance
-        '''
-        ModbusRequest.__init__(self, **kwargs)
-
-    def encode(self):
-        ''' Encodes the message
-        '''
-        return b''
-
-    def decode(self, data):
-        ''' Decodes data part of the message.
-
-        :param data: The incoming data
-        '''
-        pass
-
-    def execute(self, context=None):
-        ''' Run a read exeception status request against the store
-
-        :returns: The populated response
-        '''
-        status = _MCB.Counter.Event
-        return GetCommEventCounterResponse(status)
-
-    def __str__(self):
-        ''' Builds a representation of the request
-
-        :returns: The string representation of the request
-        '''
-        return "GetCommEventCounterRequest(%d)" % (self.function_code)
-
-
-class GetCommEventCounterResponse(ModbusResponse):
-    '''
-    The normal response contains a two-byte status word, and a two-byte
-    event count. The status word will be all ones (FF FF hex) if a
-    previously-issued program command is still being processed by the
-    remote device (a busy condition exists). Otherwise, the status word
-    will be all zeros.
-    '''
-    function_code = 0x0b
-    _rtu_frame_size = 8
-
-    def __init__(self, count=0x0000, **kwargs):
-        ''' Initializes a new instance
-
-        :param count: The current event counter value
-        '''
-        ModbusResponse.__init__(self, **kwargs)
-        self.count = count
-        self.status = True  # this means we are ready, not waiting
-
-    def encode(self):
-        ''' Encodes the response
-
-        :returns: The byte encoded message
-        '''
-        if self.status: ready = ModbusStatus.Ready
-        else: ready = ModbusStatus.Waiting
-        return struct.pack('>HH', ready, self.count)
-
-    def decode(self, data):
-        ''' Decodes a the response
-
-        :param data: The packet data to decode
-        '''
-        ready, self.count = struct.unpack('>HH', data)
-        self.status = (ready == ModbusStatus.Ready)
-
-    def __str__(self):
-        ''' Builds a representation of the response
-
-        :returns: The string representation of the response
-        '''
-        arguments = (self.function_code, self.count, self.status)
-        return "GetCommEventCounterResponse(%d, %d, %d)" % arguments
-
-
-#---------------------------------------------------------------------------#
-# TODO Make these only work on serial
-#---------------------------------------------------------------------------#
-class GetCommEventLogRequest(ModbusRequest):
-    '''
-    This function code is used to get a status word, event count, message
-    count, and a field of event bytes from the remote device.
-
-    The status word and event counts are identical  to that returned by
-    the Get Communications Event Counter function (11, 0B hex).
-
-    The message counter contains the quantity of  messages processed by the
-    remote device since its last restart, clear counters operation, or
-    power-up.  This count is identical to that returned by the Diagnostic
-    function (code 08), sub-function Return Bus Message Count (code 11,
-    0B hex).
-
-    The event bytes field contains 0-64 bytes, with each byte corresponding
-    to the status of one MODBUS send or receive operation for the remote
-    device.  The remote device enters the events into the field in
-    chronological order.  Byte 0 is the most recent event. Each new byte
-    flushes the oldest byte from the field.
-    '''
-    function_code = 0x0c
-    _rtu_frame_size = 4
-
-    def __init__(self, **kwargs):
-        ''' Initializes a new instance
-        '''
-        ModbusRequest.__init__(self, **kwargs)
-
-    def encode(self):
-        ''' Encodes the message
-        '''
-        return b''
-
-    def decode(self, data):
-        ''' Decodes data part of the message.
-
-        :param data: The incoming data
-        '''
-        pass
-
-    def execute(self, context=None):
-        ''' Run a read exeception status request against the store
-
-        :returns: The populated response
-        '''
-        results = {
-            'status'        : True,
-            'message_count' : _MCB.Counter.BusMessage,
-            'event_count'   : _MCB.Counter.Event,
-            'events'        : _MCB.getEvents(),
-        }
-        return GetCommEventLogResponse(**results)
-
-    def __str__(self):
-        ''' Builds a representation of the request
-
-        :returns: The string representation of the request
-        '''
-        return "GetCommEventLogRequest(%d)" % self.function_code
-
-
-class GetCommEventLogResponse(ModbusResponse):
-    '''
-    The normal response contains a two-byte status word field,
-    a two-byte event count field, a two-byte message count field,
-    and a field containing 0-64 bytes of events. A byte count
-    field defines the total length of the data in these four field
-    '''
-    function_code = 0x0c
-    _rtu_byte_count_pos = 2
-
-    def __init__(self, **kwargs):
-        ''' Initializes a new instance
-
-        :param status: The status response to report
-        :param message_count: The current message count
-        :param event_count: The current event count
-        :param events: The collection of events to send
-        '''
-        ModbusResponse.__init__(self, **kwargs)
-        self.status = kwargs.get('status', True)
-        self.message_count = kwargs.get('message_count', 0)
-        self.event_count = kwargs.get('event_count', 0)
-        self.events = kwargs.get('events', [])
-
-    def encode(self):
-        ''' Encodes the response
-
-        :returns: The byte encoded message
-        '''
-        if self.status: ready = ModbusStatus.Ready
-        else: ready = ModbusStatus.Waiting
-        packet  = struct.pack('>B', 6 + len(self.events))
-        packet += struct.pack('>H', ready)
-        packet += struct.pack('>HH', self.event_count, self.message_count)
-        packet += b''.join(struct.pack('>B', e) for e in self.events)
-        return packet
-
-    def decode(self, data):
-        ''' Decodes a the response
-
-        :param data: The packet data to decode
-        '''
-        length = byte2int(data[0])
-        status = struct.unpack('>H', data[1:3])[0]
-        self.status = (status == ModbusStatus.Ready)
-        self.event_count = struct.unpack('>H', data[3:5])[0]
-        self.message_count = struct.unpack('>H', data[5:7])[0]
-
-        self.events = []
-        for e in range(7, length + 1):
-            self.events.append(byte2int(data[e]))
-
-    def __str__(self):
-        ''' Builds a representation of the response
-
-        :returns: The string representation of the response
-        '''
-        arguments = (self.function_code, self.status, self.message_count, self.event_count)
-        return "GetCommEventLogResponse(%d, %d, %d, %d)" % arguments
-
-
-#---------------------------------------------------------------------------#
-# TODO Make these only work on serial
-#---------------------------------------------------------------------------#
-class ReportSlaveIdRequest(ModbusRequest):
-    '''
-    This function code is used to read the description of the type, the
-    current status, and other information specific to a remote device.
-    '''
-    function_code = 0x11
-    _rtu_frame_size = 4
-
-    def __init__(self, **kwargs):
-        ''' Initializes a new instance
-        '''
-        ModbusRequest.__init__(self, **kwargs)
-
-    def encode(self):
-        ''' Encodes the message
-        '''
-        return b''
-
-    def decode(self, data):
-        ''' Decodes data part of the message.
-
-        :param data: The incoming data
-        '''
-        pass
-
-    def execute(self, context=None):
-        ''' Run a read exeception status request against the store
-
-        :returns: The populated response
-        '''
-        information = DeviceInformationFactory.get(_MCB)
-        identifier = "-".join(information.values()).encode()
-        identifier = identifier or b'Pymodbus'
-        return ReportSlaveIdResponse(identifier)
-
-    def __str__(self):
-        ''' Builds a representation of the request
-
-        :returns: The string representation of the request
-        '''
-        return "ResportSlaveIdRequest(%d)" % self.function_code
-
-
-class ReportSlaveIdResponse(ModbusResponse):
-    '''
-    The format of a normal response is shown in the following example.
-    The data contents are specific to each type of device.
-    '''
-    function_code = 0x11
-    _rtu_byte_count_pos = 2
-
-    def __init__(self, identifier=b'\x00', status=True, **kwargs):
-        ''' Initializes a new instance
-
-        :param identifier: The identifier of the slave
-        :param status: The status response to report
-        '''
-        ModbusResponse.__init__(self, **kwargs)
-        self.identifier = identifier
-        self.status = status
-        self.byte_count = None
-
-    def encode(self):
-        ''' Encodes the response
-
-        :returns: The byte encoded message
-        '''
-        if self.status:
-            status = ModbusStatus.SlaveOn
-        else:
-            status = ModbusStatus.SlaveOff
-        length  = len(self.identifier) + 1
-        packet  = int2byte(length)
-        packet += self.identifier  # we assume it is already encoded
-        packet += int2byte(status)
-        return packet
-
-    def decode(self, data):
-        ''' Decodes a the response
-
-        Since the identifier is device dependent, we just return the
-        raw value that a user can decode to whatever it should be.
-
-        :param data: The packet data to decode
-        '''
-        self.byte_count = byte2int(data[0])
-        self.identifier = data[1:self.byte_count + 1]
-        status = byte2int(data[-1])
-        self.status = status == ModbusStatus.SlaveOn
-
-    def __str__(self):
-        ''' Builds a representation of the response
-
-        :returns: The string representation of the response
-        '''
-        arguments = (self.function_code, self.identifier, self.status)
-        return "ResportSlaveIdResponse(%s, %s, %s)" % arguments
-
-#---------------------------------------------------------------------------#
-# TODO Make these only work on serial
-#---------------------------------------------------------------------------#
-# report device identification 43, 14
-
-#---------------------------------------------------------------------------#
-# Exported symbols
-#---------------------------------------------------------------------------#
-__all__ = [
-    "ReadExceptionStatusRequest", "ReadExceptionStatusResponse",
-    "GetCommEventCounterRequest", "GetCommEventCounterResponse",
-    "GetCommEventLogRequest", "GetCommEventLogResponse",
-    "ReportSlaveIdRequest", "ReportSlaveIdResponse",
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/payload.py b/venv/lib/python3.7/site-packages/pymodbus/payload.py
deleted file mode 100644
index f97d434..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/payload.py
+++ /dev/null
@@ -1,484 +0,0 @@
-"""
-Modbus Payload Builders
-------------------------
-
-A collection of utilities for building and decoding
-modbus messages payloads.
-
-
-"""
-from struct import pack, unpack
-from pymodbus.interfaces import IPayloadBuilder
-from pymodbus.constants import Endian
-from pymodbus.utilities import pack_bitstring
-from pymodbus.utilities import unpack_bitstring
-from pymodbus.utilities import make_byte_string
-from pymodbus.exceptions import ParameterException
-from pymodbus.compat import unicode_string
-# --------------------------------------------------------------------------- #
-# Logging
-# --------------------------------------------------------------------------- #
-import logging
-_logger = logging.getLogger(__name__)
-
-
-WC = {
-    "b": 1,
-    "h": 2,
-    "i": 4,
-    "l": 4,
-    "q": 8,
-    "f": 4,
-    "d": 8
-}
-
-
-class BinaryPayloadBuilder(IPayloadBuilder):
-    """
-    A utility that helps build payload messages to be
-    written with the various modbus messages. It really is just
-    a simple wrapper around the struct module, however it saves
-    time looking up the format strings. What follows is a simple
-    example::
-
-        builder = BinaryPayloadBuilder(byteorder=Endian.Little)
-        builder.add_8bit_uint(1)
-        builder.add_16bit_uint(2)
-        payload = builder.build()
-    """
-
-    def __init__(self, payload=None, byteorder=Endian.Little,
-                 wordorder=Endian.Big, repack=False):
-        """ Initialize a new instance of the payload builder
-
-        :param payload: Raw binary payload data to initialize with
-        :param byteorder: The endianess of the bytes in the words
-        :param wordorder: The endianess of the word (when wordcount is >= 2)
-        :param repack: Repack the provided payload based on BO
-        """
-        self._payload = payload or []
-        self._byteorder = byteorder
-        self._wordorder = wordorder
-        self._repack = repack
-
-    def _pack_words(self, fstring, value):
-        """
-        Packs Words based on the word order and byte order
-
-        # ---------------------------------------------- #
-        # pack in to network ordered value               #
-        # unpack in to network ordered  unsigned integer #
-        # Change Word order if little endian word order  #
-        # Pack values back based on correct byte order   #
-        # ---------------------------------------------- #
-
-        :param value: Value to be packed
-        :return:
-        """
-        value = pack("!{}".format(fstring), value)
-        wc = WC.get(fstring.lower())//2
-        up = "!{}H".format(wc)
-        payload = unpack(up, value)
-
-        if self._wordorder == Endian.Little:
-            payload = list(reversed(payload))
-
-        fstring = self._byteorder + "H"
-        payload = [pack(fstring, word) for word in payload]
-        payload = b''.join(payload)
-
-        return payload
-
-    def to_string(self):
-        """ Return the payload buffer as a string
-
-        :returns: The payload buffer as a string
-        """
-        return b''.join(self._payload)
-
-    def __str__(self):
-        """ Return the payload buffer as a string
-
-        :returns: The payload buffer as a string
-        """
-        return self.to_string().decode('utf-8')
-
-    def reset(self):
-        """ Reset the payload buffer
-        """
-        self._payload = []
-
-    def to_registers(self):
-        """ Convert the payload buffer into a register
-        layout that can be used as a context block.
-
-        :returns: The register layout to use as a block
-        """
-        # fstring = self._byteorder+'H'
-        fstring = '!H'
-        payload = self.build()
-        if self._repack:
-            payload = [unpack(self._byteorder+"H", value)[0] for value in payload]
-        else:
-            payload = [unpack(fstring, value)[0] for value in payload]
-        _logger.debug(payload)
-        return payload
-
-    def to_coils(self):
-        """Convert the payload buffer into a coil
-        layout that can be used as a context block.
-
-        :returns: The coil layout to use as a block
-        """
-        payload = self.to_registers()
-        coils = [bool(int(bit)) for reg
-                 in payload for bit in format(reg, '016b')]
-        return coils
-
-    def build(self):
-        """ Return the payload buffer as a list
-
-        This list is two bytes per element and can
-        thus be treated as a list of registers.
-
-        :returns: The payload buffer as a list
-        """
-        string = self.to_string()
-        length = len(string)
-        string = string + (b'\x00' * (length % 2))
-        return [string[i:i+2] for i in range(0, length, 2)]
-
-    def add_bits(self, values):
-        """ Adds a collection of bits to be encoded
-
-        If these are less than a multiple of eight,
-        they will be left padded with 0 bits to make
-        it so.
-
-        :param value: The value to add to the buffer
-        """
-        value = pack_bitstring(values)
-        self._payload.append(value)
-
-    def add_8bit_uint(self, value):
-        """ Adds a 8 bit unsigned int to the buffer
-
-        :param value: The value to add to the buffer
-        """
-        fstring = self._byteorder + 'B'
-        self._payload.append(pack(fstring, value))
-
-    def add_16bit_uint(self, value):
-        """ Adds a 16 bit unsigned int to the buffer
-
-        :param value: The value to add to the buffer
-        """
-        fstring = self._byteorder + 'H'
-        self._payload.append(pack(fstring, value))
-
-    def add_32bit_uint(self, value):
-        """ Adds a 32 bit unsigned int to the buffer
-
-        :param value: The value to add to the buffer
-        """
-        fstring = 'I'
-        # fstring = self._byteorder + 'I'
-        p_string = self._pack_words(fstring, value)
-        self._payload.append(p_string)
-
-    def add_64bit_uint(self, value):
-        """ Adds a 64 bit unsigned int to the buffer
-
-        :param value: The value to add to the buffer
-        """
-        fstring = 'Q'
-        p_string = self._pack_words(fstring, value)
-        self._payload.append(p_string)
-
-    def add_8bit_int(self, value):
-        """ Adds a 8 bit signed int to the buffer
-
-        :param value: The value to add to the buffer
-        """
-        fstring = self._byteorder + 'b'
-        self._payload.append(pack(fstring, value))
-
-    def add_16bit_int(self, value):
-        """ Adds a 16 bit signed int to the buffer
-
-        :param value: The value to add to the buffer
-        """
-        fstring = self._byteorder + 'h'
-        self._payload.append(pack(fstring, value))
-
-    def add_32bit_int(self, value):
-        """ Adds a 32 bit signed int to the buffer
-
-        :param value: The value to add to the buffer
-        """
-        fstring = 'i'
-        p_string = self._pack_words(fstring, value)
-        self._payload.append(p_string)
-
-    def add_64bit_int(self, value):
-        """ Adds a 64 bit signed int to the buffer
-
-        :param value: The value to add to the buffer
-        """
-        fstring = 'q'
-        p_string = self._pack_words(fstring, value)
-        self._payload.append(p_string)
-
-    def add_32bit_float(self, value):
-        """ Adds a 32 bit float to the buffer
-
-        :param value: The value to add to the buffer
-        """
-        fstring = 'f'
-        p_string = self._pack_words(fstring, value)
-        self._payload.append(p_string)
-
-    def add_64bit_float(self, value):
-        """ Adds a 64 bit float(double) to the buffer
-
-        :param value: The value to add to the buffer
-        """
-        fstring = 'd'
-        p_string = self._pack_words(fstring, value)
-        self._payload.append(p_string)
-
-    def add_string(self, value):
-        """ Adds a string to the buffer
-
-        :param value: The value to add to the buffer
-        """
-        value = make_byte_string(value)
-        fstring = self._byteorder + str(len(value)) + 's'
-        self._payload.append(pack(fstring, value))
-
-
-class BinaryPayloadDecoder(object):
-    """
-    A utility that helps decode payload messages from a modbus
-    reponse message.  It really is just a simple wrapper around
-    the struct module, however it saves time looking up the format
-    strings. What follows is a simple example::
-
-        decoder = BinaryPayloadDecoder(payload)
-        first   = decoder.decode_8bit_uint()
-        second  = decoder.decode_16bit_uint()
-    """
-
-    def __init__(self, payload, byteorder=Endian.Little, wordorder=Endian.Big):
-        """ Initialize a new payload decoder
-
-        :param payload: The payload to decode with
-        :param byteorder: The endianess of the payload
-        :param wordorder: The endianess of the word (when wordcount is >= 2)
-        """
-        self._payload = payload
-        self._pointer = 0x00
-        self._byteorder = byteorder
-        self._wordorder = wordorder
-
-    @classmethod
-    def fromRegisters(klass, registers, byteorder=Endian.Little,
-                      wordorder=Endian.Big):
-        """ Initialize a payload decoder with the result of
-        reading a collection of registers from a modbus device.
-
-        The registers are treated as a list of 2 byte values.
-        We have to do this because of how the data has already
-        been decoded by the rest of the library.
-
-        :param registers: The register results to initialize with
-        :param byteorder: The Byte order of each word
-        :param wordorder: The endianess of the word (when wordcount is >= 2)
-        :returns: An initialized PayloadDecoder
-        """
-        _logger.debug(registers)
-        if isinstance(registers, list):  # repack into flat binary
-            payload = b''.join(pack('!H', x) for x in registers)
-            return klass(payload, byteorder, wordorder)
-        raise ParameterException('Invalid collection of registers supplied')
-
-    @classmethod
-    def bit_chunks(cls, coils, size=8):
-        chunks = [coils[i: i + size] for i in range(0, len(coils), size)]
-        return chunks
-
-    @classmethod
-    def fromCoils(klass, coils, byteorder=Endian.Little, wordorder=Endian.Big):
-        """ Initialize a payload decoder with the result of
-        reading a collection of coils from a modbus device.
-
-        The coils are treated as a list of bit(boolean) values.
-
-        :param coils: The coil results to initialize with
-        :param byteorder: The endianess of the payload
-        :returns: An initialized PayloadDecoder
-        """
-        if isinstance(coils, list):
-            payload = b''
-            padding = len(coils) % 8
-            if padding:    # Pad zero's
-                extra = [False] * padding
-                coils = extra + coils
-            chunks = klass.bit_chunks(coils)
-            for chunk in chunks:
-                payload += pack_bitstring(chunk[::-1])
-            return klass(payload, byteorder)
-        raise ParameterException('Invalid collection of coils supplied')
-
-    def _unpack_words(self, fstring, handle):
-        """
-        Un Packs Words based on the word order and byte order
-
-        # ---------------------------------------------- #
-        # Unpack in to network ordered unsigned integer  #
-        # Change Word order if little endian word order  #
-        # Pack values back based on correct byte order   #
-        # ---------------------------------------------- #
-        :param handle: Value to be unpacked
-        :return:
-        """
-        handle = make_byte_string(handle)
-        wc = WC.get(fstring.lower()) // 2
-        up = "!{}H".format(wc)
-        handle = unpack(up, handle)
-        if self._wordorder == Endian.Little:
-            handle = list(reversed(handle))
-
-        # Repack as unsigned Integer
-        pk = self._byteorder + 'H'
-        handle = [pack(pk, p) for p in handle]
-        _logger.debug(handle)
-        handle = b''.join(handle)
-        return handle
-
-    def reset(self):
-        """ Reset the decoder pointer back to the start
-        """
-        self._pointer = 0x00
-
-    def decode_8bit_uint(self):
-        """ Decodes a 8 bit unsigned int from the buffer
-        """
-        self._pointer += 1
-        fstring = self._byteorder + 'B'
-        handle = self._payload[self._pointer - 1:self._pointer]
-        handle = make_byte_string(handle)
-        return unpack(fstring, handle)[0]
-
-    def decode_bits(self):
-        """ Decodes a byte worth of bits from the buffer
-        """
-        self._pointer += 1
-        # fstring = self._endian + 'B'
-        handle = self._payload[self._pointer - 1:self._pointer]
-        handle = make_byte_string(handle)
-        return unpack_bitstring(handle)
-
-    def decode_16bit_uint(self):
-        """ Decodes a 16 bit unsigned int from the buffer
-        """
-        self._pointer += 2
-        fstring = self._byteorder + 'H'
-        handle = self._payload[self._pointer - 2:self._pointer]
-        handle = make_byte_string(handle)
-        return unpack(fstring, handle)[0]
-
-    def decode_32bit_uint(self):
-        """ Decodes a 32 bit unsigned int from the buffer
-        """
-        self._pointer += 4
-        fstring = 'I'
-        # fstring = 'I'
-        handle = self._payload[self._pointer - 4:self._pointer]
-        handle = self._unpack_words(fstring, handle)
-        return unpack("!"+fstring, handle)[0]
-
-    def decode_64bit_uint(self):
-        """ Decodes a 64 bit unsigned int from the buffer
-        """
-        self._pointer += 8
-        fstring = 'Q'
-        handle = self._payload[self._pointer - 8:self._pointer]
-        handle = self._unpack_words(fstring, handle)
-        return unpack("!"+fstring, handle)[0]
-
-    def decode_8bit_int(self):
-        """ Decodes a 8 bit signed int from the buffer
-        """
-        self._pointer += 1
-        fstring = self._byteorder + 'b'
-        handle = self._payload[self._pointer - 1:self._pointer]
-        handle = make_byte_string(handle)
-        return unpack(fstring, handle)[0]
-
-    def decode_16bit_int(self):
-        """ Decodes a 16 bit signed int from the buffer
-        """
-        self._pointer += 2
-        fstring = self._byteorder + 'h'
-        handle = self._payload[self._pointer - 2:self._pointer]
-        handle = make_byte_string(handle)
-        return unpack(fstring, handle)[0]
-
-    def decode_32bit_int(self):
-        """ Decodes a 32 bit signed int from the buffer
-        """
-        self._pointer += 4
-        fstring = 'i'
-        handle = self._payload[self._pointer - 4:self._pointer]
-        handle = self._unpack_words(fstring, handle)
-        return unpack("!"+fstring, handle)[0]
-
-    def decode_64bit_int(self):
-        """ Decodes a 64 bit signed int from the buffer
-        """
-        self._pointer += 8
-        fstring = 'q'
-        handle = self._payload[self._pointer - 8:self._pointer]
-        handle = self._unpack_words(fstring, handle)
-        return unpack("!"+fstring, handle)[0]
-
-    def decode_32bit_float(self):
-        """ Decodes a 32 bit float from the buffer
-        """
-        self._pointer += 4
-        fstring = 'f'
-        handle = self._payload[self._pointer - 4:self._pointer]
-        handle = self._unpack_words(fstring, handle)
-        return unpack("!"+fstring, handle)[0]
-
-    def decode_64bit_float(self):
-        """ Decodes a 64 bit float(double) from the buffer
-        """
-        self._pointer += 8
-        fstring = 'd'
-        handle = self._payload[self._pointer - 8:self._pointer]
-        handle = self._unpack_words(fstring, handle)
-        return unpack("!"+fstring, handle)[0]
-
-    def decode_string(self, size=1):
-        """ Decodes a string from the buffer
-
-        :param size: The size of the string to decode
-        """
-        self._pointer += size
-        s = self._payload[self._pointer - size:self._pointer]
-        return s
-
-    def skip_bytes(self, nbytes):
-        """ Skip n bytes in the buffer
-
-        :param nbytes: The number of bytes to skip
-        """
-        self._pointer += nbytes
-        return None
-
-#---------------------------------------------------------------------------#
-# Exported Identifiers
-#---------------------------------------------------------------------------#
-__all__ = ["BinaryPayloadBuilder", "BinaryPayloadDecoder"]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/pdu.py b/venv/lib/python3.7/site-packages/pymodbus/pdu.py
deleted file mode 100644
index 8f5e3ce..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/pdu.py
+++ /dev/null
@@ -1,247 +0,0 @@
-"""
-Contains base classes for modbus request/response/error packets
-"""
-from pymodbus.interfaces import Singleton
-from pymodbus.exceptions import NotImplementedException
-from pymodbus.constants import Defaults
-from pymodbus.utilities import rtuFrameSize
-from pymodbus.compat import iteritems, int2byte, byte2int
-
-# --------------------------------------------------------------------------- #
-# Logging
-# --------------------------------------------------------------------------- #
-import logging
-_logger = logging.getLogger(__name__)
-
-
-# --------------------------------------------------------------------------- #
-# Base PDU's
-# --------------------------------------------------------------------------- #
-class ModbusPDU(object):
-    """
-    Base class for all Modbus mesages
-
-    .. attribute:: transaction_id
-
-       This value is used to uniquely identify a request
-       response pair.  It can be implemented as a simple counter
-
-    .. attribute:: protocol_id
-
-       This is a constant set at 0 to indicate Modbus.  It is
-       put here for ease of expansion.
-
-    .. attribute:: unit_id
-
-       This is used to route the request to the correct child. In
-       the TCP modbus, it is used for routing (or not used at all. However,
-       for the serial versions, it is used to specify which child to perform
-       the requests against. The value 0x00 represents the broadcast address
-       (also 0xff).
-
-    .. attribute:: check
-
-       This is used for LRC/CRC in the serial modbus protocols
-
-    .. attribute:: skip_encode
-
-       This is used when the message payload has already been encoded.
-       Generally this will occur when the PayloadBuilder is being used
-       to create a complicated message. By setting this to True, the
-       request will pass the currently encoded message through instead
-       of encoding it again.
-    """
-
-    def __init__(self, **kwargs):
-        """ Initializes the base data for a modbus request """
-        self.transaction_id = kwargs.get('transaction', Defaults.TransactionId)
-        self.protocol_id = kwargs.get('protocol', Defaults.ProtocolId)
-        self.unit_id = kwargs.get('unit', Defaults.UnitId)
-        self.skip_encode = kwargs.get('skip_encode', False)
-        self.check = 0x0000
-
-    def encode(self):
-        """ Encodes the message
-
-        :raises: A not implemented exception
-        """
-        raise NotImplementedException()
-
-    def decode(self, data):
-        """ Decodes data part of the message.
-
-        :param data: is a string object
-        :raises: A not implemented exception
-        """
-        raise NotImplementedException()
-
-    @classmethod
-    def calculateRtuFrameSize(cls, buffer):
-        """ Calculates the size of a PDU.
-
-        :param buffer: A buffer containing the data that have been received.
-        :returns: The number of bytes in the PDU.
-        """
-        if hasattr(cls, '_rtu_frame_size'):
-            return cls._rtu_frame_size
-        elif hasattr(cls, '_rtu_byte_count_pos'):
-            return rtuFrameSize(buffer, cls._rtu_byte_count_pos)
-        else: raise NotImplementedException(
-            "Cannot determine RTU frame size for %s" % cls.__name__)
-
-
-class ModbusRequest(ModbusPDU):
-    """ Base class for a modbus request PDU """
-
-    def __init__(self, **kwargs):
-        """ Proxy to the lower level initializer """
-        ModbusPDU.__init__(self, **kwargs)
-
-    def doException(self, exception):
-        """ Builds an error response based on the function
-
-        :param exception: The exception to return
-        :raises: An exception response
-        """
-        exc = ExceptionResponse(self.function_code, exception)
-        _logger.error(exc)
-        return exc
-
-
-class ModbusResponse(ModbusPDU):
-    """ Base class for a modbus response PDU
-
-    .. attribute:: should_respond
-
-       A flag that indicates if this response returns a result back
-       to the client issuing the request
-
-    .. attribute:: _rtu_frame_size
-
-       Indicates the size of the modbus rtu response used for
-       calculating how much to read.
-    """
-
-    should_respond = True
-
-    def __init__(self, **kwargs):
-        """ Proxy to the lower level initializer """
-        ModbusPDU.__init__(self, **kwargs)
-
-    def isError(self):
-        """Checks if the error is a success or failure"""
-        return self.function_code > 0x80
-
-
-# --------------------------------------------------------------------------- #
-# Exception PDU's
-# --------------------------------------------------------------------------- #
-class ModbusExceptions(Singleton):
-    """
-    An enumeration of the valid modbus exceptions
-    """
-    IllegalFunction         = 0x01
-    IllegalAddress          = 0x02
-    IllegalValue            = 0x03
-    SlaveFailure            = 0x04
-    Acknowledge             = 0x05
-    SlaveBusy               = 0x06
-    MemoryParityError       = 0x08
-    GatewayPathUnavailable  = 0x0A
-    GatewayNoResponse       = 0x0B
-
-    @classmethod
-    def decode(cls, code):
-        """ Given an error code, translate it to a
-        string error name.
-
-        :param code: The code number to translate
-        """
-        values = dict((v, k) for k, v in iteritems(cls.__dict__)
-            if not k.startswith('__') and not callable(v))
-        return values.get(code, None)
-
-
-class ExceptionResponse(ModbusResponse):
-    """ Base class for a modbus exception PDU """
-    ExceptionOffset = 0x80
-    _rtu_frame_size = 5
-
-    def __init__(self, function_code, exception_code=None, **kwargs):
-        """ Initializes the modbus exception response
-
-        :param function_code: The function to build an exception response for
-        :param exception_code: The specific modbus exception to return
-        """
-        ModbusResponse.__init__(self, **kwargs)
-        self.original_code = function_code
-        self.function_code = function_code | self.ExceptionOffset
-        self.exception_code = exception_code
-
-    def encode(self):
-        """ Encodes a modbus exception response
-
-        :returns: The encoded exception packet
-        """
-        return int2byte(self.exception_code)
-
-    def decode(self, data):
-        """ Decodes a modbus exception response
-
-        :param data: The packet data to decode
-        """
-        self.exception_code = byte2int(data[0])
-
-    def __str__(self):
-        """ Builds a representation of an exception response
-
-        :returns: The string representation of an exception response
-        """
-        message = ModbusExceptions.decode(self.exception_code)
-        parameters = (self.function_code, self.original_code, message)
-        return "Exception Response(%d, %d, %s)" % parameters
-
-
-class IllegalFunctionRequest(ModbusRequest):
-    """
-    Defines the Modbus slave exception type 'Illegal Function'
-    This exception code is returned if the slave::
-
-        - does not implement the function code **or**
-        - is not in a state that allows it to process the function
-    """
-    ErrorCode = 1
-
-    def __init__(self, function_code, **kwargs):
-        """ Initializes a IllegalFunctionRequest
-
-        :param function_code: The function we are erroring on
-        """
-        ModbusRequest.__init__(self, **kwargs)
-        self.function_code = function_code
-
-    def decode(self, data):
-        """ This is here so this failure will run correctly
-
-        :param data: Not used
-        """
-        pass
-
-    def execute(self, context):
-        """ Builds an illegal function request error response
-
-        :param context: The current context for the message
-        :returns: The error response packet
-        """
-        return ExceptionResponse(self.function_code, self.ErrorCode)
-
-# --------------------------------------------------------------------------- #
-# Exported symbols
-# --------------------------------------------------------------------------- #
-
-
-__all__ = [
-    'ModbusRequest', 'ModbusResponse', 'ModbusExceptions',
-    'ExceptionResponse', 'IllegalFunctionRequest',
-]
-
diff --git a/venv/lib/python3.7/site-packages/pymodbus/register_read_message.py b/venv/lib/python3.7/site-packages/pymodbus/register_read_message.py
deleted file mode 100644
index 0a202bb..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/register_read_message.py
+++ /dev/null
@@ -1,359 +0,0 @@
-'''
-Register Reading Request/Response
----------------------------------
-'''
-import struct
-from pymodbus.pdu import ModbusRequest
-from pymodbus.pdu import ModbusResponse
-from pymodbus.pdu import ModbusExceptions as merror
-from pymodbus.compat import int2byte, byte2int
-
-
-class ReadRegistersRequestBase(ModbusRequest):
-    '''
-    Base class for reading a modbus register
-    '''
-    _rtu_frame_size = 8
-
-    def __init__(self, address, count, **kwargs):
-        ''' Initializes a new instance
-
-        :param address: The address to start the read from
-        :param count: The number of registers to read
-        '''
-        ModbusRequest.__init__(self, **kwargs)
-        self.address = address
-        self.count = count
-
-    def encode(self):
-        ''' Encodes the request packet
-
-        :return: The encoded packet
-        '''
-        return struct.pack('>HH', self.address, self.count)
-
-    def decode(self, data):
-        ''' Decode a register request packet
-
-        :param data: The request to decode
-        '''
-        self.address, self.count = struct.unpack('>HH', data)
-
-    def get_response_pdu_size(self):
-        """
-        Func_code (1 byte) + Byte Count(1 byte) + 2 * Quantity of Coils (n Bytes)
-        :return: 
-        """
-        return 1 + 1 + 2 * self.count
-
-    def __str__(self):
-        ''' Returns a string representation of the instance
-
-        :returns: A string representation of the instance
-        '''
-        return "ReadRegisterRequest (%d,%d)" % (self.address, self.count)
-
-
-class ReadRegistersResponseBase(ModbusResponse):
-    '''
-    Base class for responsing to a modbus register read
-    '''
-
-    _rtu_byte_count_pos = 2
-
-    def __init__(self, values, **kwargs):
-        ''' Initializes a new instance
-
-        :param values: The values to write to
-        '''
-        ModbusResponse.__init__(self, **kwargs)
-        self.registers = values or []
-
-    def encode(self):
-        ''' Encodes the response packet
-
-        :returns: The encoded packet
-        '''
-        result = int2byte(len(self.registers) * 2)
-        for register in self.registers:
-            result += struct.pack('>H', register)
-        return result
-
-    def decode(self, data):
-        ''' Decode a register response packet
-
-        :param data: The request to decode
-        '''
-        byte_count = byte2int(data[0])
-        self.registers = []
-        for i in range(1, byte_count + 1, 2):
-            self.registers.append(struct.unpack('>H', data[i:i + 2])[0])
-
-    def getRegister(self, index):
-        ''' Get the requested register
-
-        :param index: The indexed register to retrieve
-        :returns: The request register
-        '''
-        return self.registers[index]
-
-    def __str__(self):
-        ''' Returns a string representation of the instance
-
-        :returns: A string representation of the instance
-        '''
-        return "ReadRegisterResponse (%d)" % len(self.registers)
-
-
-class ReadHoldingRegistersRequest(ReadRegistersRequestBase):
-    '''
-    This function code is used to read the contents of a contiguous block
-    of holding registers in a remote device. The Request PDU specifies the
-    starting register address and the number of registers. In the PDU
-    Registers are addressed starting at zero. Therefore registers numbered
-    1-16 are addressed as 0-15.
-    '''
-    function_code = 3
-
-    def __init__(self, address=None, count=None, **kwargs):
-        ''' Initializes a new instance of the request
-
-        :param address: The starting address to read from
-        :param count: The number of registers to read from address
-        '''
-        ReadRegistersRequestBase.__init__(self, address, count, **kwargs)
-
-    def execute(self, context):
-        ''' Run a read holding request against a datastore
-
-        :param context: The datastore to request from
-        :returns: An initialized response, exception message otherwise
-        '''
-        if not (1 <= self.count <= 0x7d):
-            return self.doException(merror.IllegalValue)
-        if not context.validate(self.function_code, self.address, self.count):
-            return self.doException(merror.IllegalAddress)
-        values = context.getValues(self.function_code, self.address, self.count)
-        return ReadHoldingRegistersResponse(values)
-
-
-class ReadHoldingRegistersResponse(ReadRegistersResponseBase):
-    '''
-    This function code is used to read the contents of a contiguous block
-    of holding registers in a remote device. The Request PDU specifies the
-    starting register address and the number of registers. In the PDU
-    Registers are addressed starting at zero. Therefore registers numbered
-    1-16 are addressed as 0-15.
-    '''
-    function_code = 3
-
-    def __init__(self, values=None, **kwargs):
-        ''' Initializes a new response instance
-
-        :param values: The resulting register values
-        '''
-        ReadRegistersResponseBase.__init__(self, values, **kwargs)
-
-
-class ReadInputRegistersRequest(ReadRegistersRequestBase):
-    '''
-    This function code is used to read from 1 to approx. 125 contiguous
-    input registers in a remote device. The Request PDU specifies the
-    starting register address and the number of registers. In the PDU
-    Registers are addressed starting at zero. Therefore input registers
-    numbered 1-16 are addressed as 0-15.
-    '''
-    function_code = 4
-
-    def __init__(self, address=None, count=None, **kwargs):
-        ''' Initializes a new instance of the request
-
-        :param address: The starting address to read from
-        :param count: The number of registers to read from address
-        '''
-        ReadRegistersRequestBase.__init__(self, address, count, **kwargs)
-
-    def execute(self, context):
-        ''' Run a read input request against a datastore
-
-        :param context: The datastore to request from
-        :returns: An initialized response, exception message otherwise
-        '''
-        if not (1 <= self.count <= 0x7d):
-            return self.doException(merror.IllegalValue)
-        if not context.validate(self.function_code, self.address, self.count):
-            return self.doException(merror.IllegalAddress)
-        values = context.getValues(self.function_code, self.address, self.count)
-        return ReadInputRegistersResponse(values)
-
-
-class ReadInputRegistersResponse(ReadRegistersResponseBase):
-    '''
-    This function code is used to read from 1 to approx. 125 contiguous
-    input registers in a remote device. The Request PDU specifies the
-    starting register address and the number of registers. In the PDU
-    Registers are addressed starting at zero. Therefore input registers
-    numbered 1-16 are addressed as 0-15.
-    '''
-    function_code = 4
-
-    def __init__(self, values=None, **kwargs):
-        ''' Initializes a new response instance
-
-        :param values: The resulting register values
-        '''
-        ReadRegistersResponseBase.__init__(self, values, **kwargs)
-
-
-class ReadWriteMultipleRegistersRequest(ModbusRequest):
-    '''
-    This function code performs a combination of one read operation and one
-    write operation in a single MODBUS transaction. The write
-    operation is performed before the read.
-
-    Holding registers are addressed starting at zero. Therefore holding
-    registers 1-16 are addressed in the PDU as 0-15.
-
-    The request specifies the starting address and number of holding
-    registers to be read as well as the starting address, number of holding
-    registers, and the data to be written. The byte count specifies the
-    number of bytes to follow in the write data field."
-    '''
-    function_code = 23
-    _rtu_byte_count_pos = 10
-
-    def __init__(self, **kwargs):
-        ''' Initializes a new request message
-
-        :param read_address: The address to start reading from
-        :param read_count: The number of registers to read from address
-        :param write_address: The address to start writing to
-        :param write_registers: The registers to write to the specified address
-        '''
-        ModbusRequest.__init__(self, **kwargs)
-        self.read_address    = kwargs.get('read_address', 0x00)
-        self.read_count      = kwargs.get('read_count', 0)
-        self.write_address   = kwargs.get('write_address', 0x00)
-        self.write_registers = kwargs.get('write_registers', None)
-        if not hasattr(self.write_registers, '__iter__'):
-            self.write_registers = [self.write_registers]
-        self.write_count = len(self.write_registers)
-        self.write_byte_count = self.write_count * 2
-
-    def encode(self):
-        ''' Encodes the request packet
-
-        :returns: The encoded packet
-        '''
-        result = struct.pack('>HHHHB',
-                self.read_address,  self.read_count, \
-                self.write_address, self.write_count, self.write_byte_count)
-        for register in self.write_registers:
-            result += struct.pack('>H', register)
-        return result
-
-    def decode(self, data):
-        ''' Decode the register request packet
-
-        :param data: The request to decode
-        '''
-        self.read_address,  self.read_count,  \
-        self.write_address, self.write_count, \
-        self.write_byte_count = struct.unpack('>HHHHB', data[:9])
-        self.write_registers  = []
-        for i in range(9, self.write_byte_count + 9, 2):
-            register = struct.unpack('>H', data[i:i + 2])[0]
-            self.write_registers.append(register)
-
-    def execute(self, context):
-        ''' Run a write single register request against a datastore
-
-        :param context: The datastore to request from
-        :returns: An initialized response, exception message otherwise
-        '''
-        if not (1 <= self.read_count <= 0x07d):
-            return self.doException(merror.IllegalValue)
-        if not (1 <= self.write_count <= 0x079):
-            return self.doException(merror.IllegalValue)
-        if (self.write_byte_count != self.write_count * 2):
-            return self.doException(merror.IllegalValue)
-        if not context.validate(self.function_code, self.write_address,
-                                self.write_count):
-            return self.doException(merror.IllegalAddress)
-        if not context.validate(self.function_code, self.read_address,
-                                self.read_count):
-            return self.doException(merror.IllegalAddress)
-        context.setValues(self.function_code, self.write_address,
-                          self.write_registers)
-        registers = context.getValues(self.function_code, self.read_address,
-                                      self.read_count)
-        return ReadWriteMultipleRegistersResponse(registers)
-
-    def get_response_pdu_size(self):
-        """
-        Func_code (1 byte) + Byte Count(1 byte) + 2 * Quantity of Coils (n Bytes)
-        :return: 
-        """
-        return 1 + 1 + 2 * self.read_count
-
-    def __str__(self):
-        ''' Returns a string representation of the instance
-
-        :returns: A string representation of the instance
-        '''
-        params = (self.read_address, self.read_count, self.write_address,
-                  self.write_count)
-        return "ReadWriteNRegisterRequest R(%d,%d) W(%d,%d)" % params
-
-
-class ReadWriteMultipleRegistersResponse(ModbusResponse):
-    '''
-    The normal response contains the data from the group of registers that
-    were read. The byte count field specifies the quantity of bytes to
-    follow in the read data field.
-    '''
-    function_code = 23
-    _rtu_byte_count_pos = 2
-
-    def __init__(self, values=None, **kwargs):
-        ''' Initializes a new instance
-
-        :param values: The register values to write
-        '''
-        ModbusResponse.__init__(self, **kwargs)
-        self.registers = values or []
-
-    def encode(self):
-        ''' Encodes the response packet
-
-        :returns: The encoded packet
-        '''
-        result = int2byte(len(self.registers) * 2)
-        for register in self.registers:
-            result += struct.pack('>H', register)
-        return result
-
-    def decode(self, data):
-        ''' Decode the register response packet
-
-        :param data: The response to decode
-        '''
-        bytecount = byte2int(data[0])
-        for i in range(1, bytecount, 2):
-            self.registers.append(struct.unpack('>H', data[i:i + 2])[0])
-
-    def __str__(self):
-        ''' Returns a string representation of the instance
-
-        :returns: A string representation of the instance
-        '''
-        return "ReadWriteNRegisterResponse (%d)" % len(self.registers)
-
-#---------------------------------------------------------------------------#
-# Exported symbols
-#---------------------------------------------------------------------------#
-__all__ = [
-    "ReadHoldingRegistersRequest", "ReadHoldingRegistersResponse",
-    "ReadInputRegistersRequest", "ReadInputRegistersResponse",
-    "ReadWriteMultipleRegistersRequest", "ReadWriteMultipleRegistersResponse",
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/register_write_message.py b/venv/lib/python3.7/site-packages/pymodbus/register_write_message.py
deleted file mode 100644
index 3a128ab..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/register_write_message.py
+++ /dev/null
@@ -1,354 +0,0 @@
-'''
-Register Writing Request/Response Messages
--------------------------------------------
-'''
-import struct
-from pymodbus.pdu import ModbusRequest
-from pymodbus.pdu import ModbusResponse
-from pymodbus.pdu import ModbusExceptions as merror
-
-
-class WriteSingleRegisterRequest(ModbusRequest):
-    '''
-    This function code is used to write a single holding register in a
-    remote device.
-
-    The Request PDU specifies the address of the register to
-    be written. Registers are addressed starting at zero. Therefore register
-    numbered 1 is addressed as 0.
-    '''
-    function_code = 6
-    _rtu_frame_size = 8
-    
-    def __init__(self, address=None, value=None, **kwargs):
-        ''' Initializes a new instance
-
-        :param address: The address to start writing add
-        :param value: The values to write
-        '''
-        ModbusRequest.__init__(self, **kwargs)
-        self.address = address
-        self.value = value
-
-    def encode(self):
-        ''' Encode a write single register packet packet request
-
-        :returns: The encoded packet
-        '''
-        packet = struct.pack('>H', self.address)
-        if self.skip_encode:
-            packet += self.value
-        else:
-            packet += struct.pack('>H', self.value)
-        return packet
-
-    def decode(self, data):
-        ''' Decode a write single register packet packet request
-
-        :param data: The request to decode
-        '''
-        self.address, self.value = struct.unpack('>HH', data)
-    
-    def execute(self, context):
-        ''' Run a write single register request against a datastore
-
-        :param context: The datastore to request from
-        :returns: An initialized response, exception message otherwise
-        '''
-        if not (0 <= self.value <= 0xffff):
-            return self.doException(merror.IllegalValue)
-        if not context.validate(self.function_code, self.address, 1):
-            return self.doException(merror.IllegalAddress)
-
-        context.setValues(self.function_code, self.address, [self.value])
-        values = context.getValues(self.function_code, self.address, 1)
-        return WriteSingleRegisterResponse(self.address, values[0])
-
-    def get_response_pdu_size(self):
-        """
-        Func_code (1 byte) + Register Address(2 byte) + Register Value (2 bytes)
-        :return: 
-        """
-        return 1 + 2 + 2
-    
-    def __str__(self):
-        ''' Returns a string representation of the instance
-
-        :returns: A string representation of the instance
-        '''
-        return "WriteRegisterRequest %d" % self.address
-
-
-class WriteSingleRegisterResponse(ModbusResponse):
-    '''
-    The normal response is an echo of the request, returned after the
-    register contents have been written.
-    '''
-    function_code = 6
-    _rtu_frame_size = 8
-
-    def __init__(self, address=None, value=None, **kwargs):
-        ''' Initializes a new instance
-
-        :param address: The address to start writing add
-        :param value: The values to write
-        '''
-        ModbusResponse.__init__(self, **kwargs)
-        self.address = address
-        self.value = value
-
-    def encode(self):
-        ''' Encode a write single register packet packet request
-
-        :returns: The encoded packet
-        '''
-        return struct.pack('>HH', self.address, self.value)
-
-    def decode(self, data):
-        ''' Decode a write single register packet packet request
-
-        :param data: The request to decode
-        '''
-        self.address, self.value = struct.unpack('>HH', data)
-
-    def __str__(self):
-        ''' Returns a string representation of the instance
-
-        :returns: A string representation of the instance
-        '''
-        params = (self.address, self.value)
-        return "WriteRegisterResponse %d => %d" % params
-
-
-#---------------------------------------------------------------------------#
-# Write Multiple Registers
-#---------------------------------------------------------------------------#
-class WriteMultipleRegistersRequest(ModbusRequest):
-    '''
-    This function code is used to write a block of contiguous registers (1
-    to approx. 120 registers) in a remote device.
-
-    The requested written values are specified in the request data field.
-    Data is packed as two bytes per register.
-    '''
-    function_code = 16
-    _rtu_byte_count_pos = 6
-    _pdu_length = 5  #func + adress1 + adress2 + outputQuant1 + outputQuant2
-
-    def __init__(self, address=None, values=None, **kwargs):
-        ''' Initializes a new instance
-
-        :param address: The address to start writing to
-        :param values: The values to write
-        '''
-        ModbusRequest.__init__(self, **kwargs)
-        self.address = address
-        if values is None:
-            values = []
-        elif not hasattr(values, '__iter__'):
-            values = [values]
-        self.values = values
-        self.count = len(self.values)
-        self.byte_count = self.count * 2
-
-    def encode(self):
-        ''' Encode a write single register packet packet request
-
-        :returns: The encoded packet
-        '''
-        packet = struct.pack('>HHB', self.address, self.count, self.byte_count)
-        if self.skip_encode:
-            return packet + b''.join(self.values)
-        
-        for value in self.values:
-            packet += struct.pack('>H', value)
-
-        return packet
-
-    def decode(self, data):
-        ''' Decode a write single register packet packet request
-
-        :param data: The request to decode
-        '''
-        self.address, self.count, \
-        self.byte_count = struct.unpack('>HHB', data[:5])
-        self.values = []  # reset
-        for idx in range(5, (self.count * 2) + 5, 2):
-            self.values.append(struct.unpack('>H', data[idx:idx + 2])[0])
-
-    def execute(self, context):
-        ''' Run a write single register request against a datastore
-
-        :param context: The datastore to request from
-        :returns: An initialized response, exception message otherwise
-        '''
-        if not (1 <= self.count <= 0x07b):
-            return self.doException(merror.IllegalValue)
-        if (self.byte_count != self.count * 2):
-            return self.doException(merror.IllegalValue)
-        if not context.validate(self.function_code, self.address, self.count):
-            return self.doException(merror.IllegalAddress)
-
-        context.setValues(self.function_code, self.address, self.values)
-        return WriteMultipleRegistersResponse(self.address, self.count)
-
-    def get_response_pdu_size(self):
-        """
-        Func_code (1 byte) + Starting Address (2 byte) + Quantity of Reggisters  (2 Bytes)
-        :return:
-        """
-        return 1 + 2 + 2
-
-    def __str__(self):
-        ''' Returns a string representation of the instance
-
-        :returns: A string representation of the instance
-        '''
-        params = (self.address, self.count)
-        return "WriteMultipleRegisterRequest %d => %d" % params
-
-
-class WriteMultipleRegistersResponse(ModbusResponse):
-    '''
-    "The normal response returns the function code, starting address, and
-    quantity of registers written.
-    '''
-    function_code = 16
-    _rtu_frame_size = 8
-
-    def __init__(self, address=None, count=None, **kwargs):
-        ''' Initializes a new instance
-
-        :param address: The address to start writing to
-        :param count: The number of registers to write to
-        '''
-        ModbusResponse.__init__(self, **kwargs)
-        self.address = address
-        self.count = count
-
-    def encode(self):
-        ''' Encode a write single register packet packet request
-
-        :returns: The encoded packet
-        '''
-        return struct.pack('>HH', self.address, self.count)
-
-    def decode(self, data):
-        ''' Decode a write single register packet packet request
-
-        :param data: The request to decode
-        '''
-        self.address, self.count = struct.unpack('>HH', data)
-
-    def __str__(self):
-        ''' Returns a string representation of the instance
-
-        :returns: A string representation of the instance
-        '''
-        params = (self.address, self.count)
-        return "WriteMultipleRegisterResponse (%d,%d)" % params
-
-class MaskWriteRegisterRequest(ModbusRequest):
-    '''
-    This function code is used to modify the contents of a specified holding
-    register using a combination of an AND mask, an OR mask, and the
-    register's current contents. The function can be used to set or clear
-    individual bits in the register.
-    '''
-    function_code = 0x16
-    _rtu_frame_size = 10
-
-    def __init__(self, address=0x0000, and_mask=0xffff, or_mask=0x0000,
-                 **kwargs):
-        ''' Initializes a new instance
-
-        :param address: The mask pointer address (0x0000 to 0xffff)
-        :param and_mask: The and bitmask to apply to the register address
-        :param or_mask: The or bitmask to apply to the register address
-        '''
-        ModbusRequest.__init__(self, **kwargs)
-        self.address = address
-        self.and_mask = and_mask
-        self.or_mask = or_mask
-
-    def encode(self):
-        ''' Encodes the request packet
-
-        :returns: The byte encoded packet
-        '''
-        return struct.pack('>HHH', self.address, self.and_mask,
-                           self.or_mask)
-
-    def decode(self, data):
-        ''' Decodes the incoming request
-
-        :param data: The data to decode into the address
-        '''
-        self.address, self.and_mask, self.or_mask = struct.unpack('>HHH',
-                                                                  data)
-
-    def execute(self, context):
-        ''' Run a mask write register request against the store
-
-        :param context: The datastore to request from
-        :returns: The populated response
-        '''
-        if not (0x0000 <= self.and_mask <= 0xffff):
-            return self.doException(merror.IllegalValue)
-        if not (0x0000 <= self.or_mask <= 0xffff):
-            return self.doException(merror.IllegalValue)
-        if not context.validate(self.function_code, self.address, 1):
-            return self.doException(merror.IllegalAddress)
-        values = context.getValues(self.function_code, self.address, 1)[0]
-        values = ((values & self.and_mask) | self.or_mask)
-        context.setValues(self.function_code, self.address, [values])
-        return MaskWriteRegisterResponse(self.address, self.and_mask,
-                                         self.or_mask)
-
-
-class MaskWriteRegisterResponse(ModbusResponse):
-    '''
-    The normal response is an echo of the request. The response is returned
-    after the register has been written.
-    '''
-    function_code = 0x16
-    _rtu_frame_size = 10
-
-    def __init__(self, address=0x0000, and_mask=0xffff, or_mask=0x0000,
-                 **kwargs):
-        ''' Initializes a new instance
-
-        :param address: The mask pointer address (0x0000 to 0xffff)
-        :param and_mask: The and bitmask applied to the register address
-        :param or_mask: The or bitmask applied to the register address
-        '''
-        ModbusResponse.__init__(self, **kwargs)
-        self.address = address
-        self.and_mask = and_mask
-        self.or_mask = or_mask
-
-    def encode(self):
-        ''' Encodes the response
-
-        :returns: The byte encoded message
-        '''
-        return struct.pack('>HHH', self.address, self.and_mask,
-                           self.or_mask)
-
-    def decode(self, data):
-        ''' Decodes a the response
-
-        :param data: The packet data to decode
-        '''
-        self.address, self.and_mask, self.or_mask = struct.unpack('>HHH',
-                                                                  data)
-
-
-#---------------------------------------------------------------------------#
-# Exported symbols
-#---------------------------------------------------------------------------#
-__all__ = [
-    "WriteSingleRegisterRequest", "WriteSingleRegisterResponse",
-    "WriteMultipleRegistersRequest", "WriteMultipleRegistersResponse",
-    "MaskWriteRegisterRequest", "MaskWriteRegisterResponse"
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/repl/__init__.py b/venv/lib/python3.7/site-packages/pymodbus/repl/__init__.py
deleted file mode 100644
index ff5581a..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/repl/__init__.py
+++ /dev/null
@@ -1,7 +0,0 @@
-"""
-Pymodbus REPL Module.
-
-Copyright (c) 2018 Riptide IO, Inc. All Rights Reserved.
-
-"""
-from __future__ import absolute_import, unicode_literals
\ No newline at end of file
diff --git a/venv/lib/python3.7/site-packages/pymodbus/repl/client.py b/venv/lib/python3.7/site-packages/pymodbus/repl/client.py
deleted file mode 100644
index 146779a..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/repl/client.py
+++ /dev/null
@@ -1,721 +0,0 @@
-"""
-Modbus Clients to be used with REPL.
-
-Copyright (c) 2018 Riptide IO, Inc. All Rights Reserved.
-
-"""
-from __future__ import absolute_import, unicode_literals
-
-from pymodbus.pdu import ModbusExceptions, ExceptionResponse
-from pymodbus.exceptions import ModbusIOException
-from pymodbus.client.sync import ModbusSerialClient as _ModbusSerialClient
-from pymodbus.client.sync import ModbusTcpClient as _ModbusTcpClient
-from pymodbus.mei_message import ReadDeviceInformationRequest
-from pymodbus.other_message import (ReadExceptionStatusRequest,
-                                    ReportSlaveIdRequest,
-                                    GetCommEventCounterRequest,
-                                    GetCommEventLogRequest)
-from pymodbus.diag_message import (
-                                   ReturnQueryDataRequest,
-                                   RestartCommunicationsOptionRequest,
-                                   ReturnDiagnosticRegisterRequest,
-                                   ChangeAsciiInputDelimiterRequest,
-                                   ForceListenOnlyModeRequest,
-                                   ClearCountersRequest,
-                                   ReturnBusMessageCountRequest,
-                                   ReturnBusCommunicationErrorCountRequest,
-                                   ReturnBusExceptionErrorCountRequest,
-                                   ReturnSlaveMessageCountRequest,
-                                   ReturnSlaveNoResponseCountRequest,
-                                   ReturnSlaveNAKCountRequest,
-                                   ReturnSlaveBusyCountRequest,
-                                   ReturnSlaveBusCharacterOverrunCountRequest,
-                                   ReturnIopOverrunCountRequest,
-                                   ClearOverrunCountRequest,
-                                   GetClearModbusPlusRequest)
-
-
-class ExtendedRequestSupport(object):
-
-    @staticmethod
-    def _process_exception(resp):
-        if isinstance(resp, ExceptionResponse):
-            err = {
-                'original_function_code': "{} ({})".format(
-                    resp.original_code, hex(resp.original_code)),
-                'error_function_code': "{} ({})".format(
-                    resp.function_code, hex(resp.function_code)),
-                'exception code': resp.exception_code,
-                'message': ModbusExceptions.decode(resp.exception_code)
-            }
-        elif isinstance(resp, ModbusIOException):
-            err = {
-                'original_function_code': "{} ({})".format(
-                    resp.fcode, hex(resp.fcode)),
-                'error': resp.message
-            }
-        else:
-            err = {
-                'error': str(resp)
-            }
-        return err
-
-    def read_coils(self, address, count=1, **kwargs):
-        """
-        Reads `count` coils from a given slave starting at `address`.
-
-        :param address: The starting address to read from
-        :param count: The number of coils to read
-        :param unit: The slave unit this request is targeting
-        :returns: List of register values
-        """
-        resp = super(ExtendedRequestSupport, self).read_coils(address,
-                                                              count, **kwargs)
-        if not resp.isError():
-            return {
-                'function_code': resp.function_code,
-                'bits': resp.bits
-            }
-        else:
-            return ExtendedRequestSupport._process_exception(resp)
-
-    def read_discrete_inputs(self, address, count=1, **kwargs):
-        """
-        Reads `count` number of discrete inputs starting at offset `address`.
-
-        :param address: The starting address to read from
-        :param count: The number of coils to read
-        :param unit: The slave unit this request is targeting
-        :return: List of bits
-        """
-        resp = super(ExtendedRequestSupport,
-                     self).read_discrete_inputs(address, count, **kwargs)
-        if not resp.isError():
-            return {
-                'function_code': resp.function_code,
-                'bits': resp.bits
-            }
-        else:
-            return ExtendedRequestSupport._process_exception(resp)
-
-    def write_coil(self, address, value, **kwargs):
-        """
-        Write `value` to coil at `address`.
-
-        :param address: coil offset to write to
-        :param value: bit value to write
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        resp = super(ExtendedRequestSupport, self).write_coil(
-            address, value, **kwargs)
-        if not resp.isError():
-            return {
-                'function_code': resp.function_code,
-                'address': resp.address,
-                'value': resp.value
-            }
-        else:
-            return ExtendedRequestSupport._process_exception(resp)
-
-    def write_coils(self, address, values, **kwargs):
-        """
-        Write `value` to coil at `address`.
-
-        :param address: coil offset to write to
-        :param value: list of bit values to write (comma seperated)
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        resp = super(ExtendedRequestSupport, self).write_coils(
-            address, values, **kwargs)
-        if not resp.isError():
-            return {
-                'function_code': resp.function_code,
-                'address': resp.address,
-                'count': resp.count
-            }
-        else:
-            return ExtendedRequestSupport._process_exception(resp)
-
-    def write_register(self, address, value, **kwargs):
-        """
-        Write `value` to register at `address`.
-
-        :param address: register offset to write to
-        :param value: register value to write
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        resp = super(ExtendedRequestSupport, self).write_register(
-            address, value, **kwargs)
-        if not resp.isError():
-            return {
-                'function_code': resp.function_code,
-                'address': resp.address,
-                'value': resp.value
-            }
-        else:
-            return ExtendedRequestSupport._process_exception(resp)
-
-    def write_registers(self, address, values, **kwargs):
-        """
-        Write list of `values` to registers starting at `address`.
-
-        :param address: register offset to write to
-        :param value: list of register value to write (comma seperated)
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        resp = super(ExtendedRequestSupport, self).write_registers(
-            address, values, **kwargs)
-        if not resp.isError():
-            return {
-                'function_code': resp.function_code,
-                'address': resp.address,
-                'count': resp.count
-            }
-        else:
-            return ExtendedRequestSupport._process_exception(resp)
-
-    def read_holding_registers(self, address, count=1, **kwargs):
-        """
-        Read `count` number of holding registers starting at `address`.
-
-        :param address: starting register offset to read from
-        :param count: Number of registers to read
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        resp = super(ExtendedRequestSupport, self).read_holding_registers(
-            address, count, **kwargs)
-        if not resp.isError():
-            return {
-                'function_code': resp.function_code,
-                'registers': resp.registers
-            }
-        else:
-            return ExtendedRequestSupport._process_exception(resp)
-
-    def read_input_registers(self, address, count=1, **kwargs):
-        """
-        Read `count` number of input registers starting at `address`.
-
-        :param address: starting register offset to read from to
-        :param count: Number of registers to read
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        resp = super(ExtendedRequestSupport, self).read_input_registers(
-            address, count, **kwargs)
-        if not resp.isError():
-            return {
-                'function_code': resp.function_code,
-                'registers': resp.registers
-            }
-        else:
-            return ExtendedRequestSupport._process_exception(resp)
-
-    def readwrite_registers(self, read_address, read_count, write_address,
-                            write_registers, **kwargs):
-        """
-        Read `read_count` number of holding registers starting at \
-        `read_address`  and write `write_registers` \
-        starting at `write_address`.
-
-        :param read_address: register offset to read from
-        :param read_count: Number of registers to read
-        :param write_address: register offset to write to
-        :param write_registers: List of register values to write (comma seperated)
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        resp = super(ExtendedRequestSupport, self).readwrite_registers(
-            read_address=read_address,
-            read_count=read_count,
-            write_address=write_address,
-            write_registers=write_registers,
-            **kwargs
-        )
-        if not resp.isError():
-            return {
-                'function_code': resp.function_code,
-                'registers': resp.registers
-            }
-        else:
-            return ExtendedRequestSupport._process_exception(resp)
-
-    def mask_write_register(self, address=0x0000,
-                            and_mask=0xffff, or_mask=0x0000, **kwargs):
-        """
-        Mask content of holding register at `address`  \
-        with `and_mask` and `or_mask`.
-
-        :param address: Reference address of register
-        :param and_mask: And Mask
-        :param or_mask: OR Mask
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        resp = super(ExtendedRequestSupport, self).read_input_registers(
-            address=address, and_mask=and_mask, or_mask=or_mask, **kwargs)
-        if not resp.isError():
-            return {
-                'function_code': resp.function_code,
-                'address': resp.address,
-                'and mask': resp.and_mask,
-                'or mask': resp.or_mask
-            }
-        else:
-            return ExtendedRequestSupport._process_exception(resp)
-
-    def read_device_information(self, read_code=None,
-                                        object_id=0x00, **kwargs):
-        """
-        Read the identification and additional information of remote slave.
-
-        :param read_code:  Read Device ID code (0x01/0x02/0x03/0x04)
-        :param object_id: Identification of the first object to obtain.
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = ReadDeviceInformationRequest(read_code, object_id, **kwargs)
-        resp = self.execute(request)
-        if not resp.isError():
-            return {
-                'function_code': resp.function_code,
-                'information': resp.information,
-                'object count': resp.number_of_objects,
-                'conformity': resp.conformity,
-                'next object id': resp.next_object_id,
-                'more follows': resp.more_follows,
-                'space left': resp.space_left
-            }
-        else:
-            return ExtendedRequestSupport._process_exception(resp)
-
-    def report_slave_id(self, **kwargs):
-        """
-        Report information about remote slave ID.
-
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = ReportSlaveIdRequest(**kwargs)
-        resp = self.execute(request)
-        if not resp.isError():
-            return {
-                'function_code': resp.function_code,
-                'identifier': resp.identifier.decode('cp1252'),
-                'status': resp.status,
-                'byte count': resp.byte_count
-            }
-        else:
-            return ExtendedRequestSupport._process_exception(resp)
-
-    def read_exception_status(self, **kwargs):
-        """
-         Read the contents of eight Exception Status outputs in a remote \
-         device.
-
-        :param unit: The slave unit this request is targeting
-        
-        :return:
-
-        """
-        request = ReadExceptionStatusRequest(**kwargs)
-        resp = self.execute(request)
-        if not resp.isError():
-            return {
-                'function_code': resp.function_code,
-                'status': resp.status
-            }
-        else:
-            return ExtendedRequestSupport._process_exception(resp)
-
-    def get_com_event_counter(self, **kwargs):
-        """
-        Read  status word and an event count from the remote device's \
-        communication event counter.
-
-        :param unit: The slave unit this request is targeting
-
-        :return:
-
-        """
-        request = GetCommEventCounterRequest(**kwargs)
-        resp = self.execute(request)
-        if not resp.isError():
-            return {
-                'function_code': resp.function_code,
-                'status': resp.status,
-                'count': resp.count
-            }
-        else:
-            return ExtendedRequestSupport._process_exception(resp)
-
-    def get_com_event_log(self, **kwargs):
-        """
-        Read  status word, event count, message count, and a field of event
-        bytes from the remote device.
-
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = GetCommEventLogRequest(**kwargs)
-        resp = self.execute(request)
-        if not resp.isError():
-            return {
-                'function_code': resp.function_code,
-                'status': resp.status,
-                'message count': resp.message_count,
-                'event count': resp.event_count,
-                'events': resp.events,
-            }
-        else:
-            return ExtendedRequestSupport._process_exception(resp)
-
-    def _execute_diagnostic_request(self, request):
-        resp = self.execute(request)
-        if not resp.isError():
-            return {
-                'function code': resp.function_code,
-                'sub function code': resp.sub_function_code,
-                'message': resp.message
-            }
-        else:
-            return ExtendedRequestSupport._process_exception(resp)
-
-    def return_query_data(self, message=0, **kwargs):
-        """
-        Diagnostic sub command , Loop back data sent in response.
-
-        :param message: Message to be looped back
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = ReturnQueryDataRequest(message, **kwargs)
-        return self._execute_diagnostic_request(request)
-
-    def restart_comm_option(self, toggle=False, **kwargs):
-        """
-        Diagnostic sub command, initialize and restart remote devices serial \
-        interface and clear all of its communications event counters .
-
-        :param toggle: Toggle Status [ON(0xff00)/OFF(0x0000]
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = RestartCommunicationsOptionRequest(toggle, **kwargs)
-        return self._execute_diagnostic_request(request)
-
-    def return_diagnostic_register(self, data=0, **kwargs):
-        """
-        Diagnostic sub command, Read 16-bit diagnostic register.
-
-        :param data: Data field (0x0000)
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = ReturnDiagnosticRegisterRequest(data, **kwargs)
-        return self._execute_diagnostic_request(request)
-
-    def change_ascii_input_delimiter(self, data=0, **kwargs):
-        """
-        Diagnostic sub command, Change message delimiter for future requests.
-
-        :param data: New delimiter character
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = ChangeAsciiInputDelimiterRequest(data, **kwargs)
-        return self._execute_diagnostic_request(request)
-
-    def force_listen_only_mode(self, data=0, **kwargs):
-        """
-        Diagnostic sub command, Forces the addressed remote device to \
-        its Listen Only Mode.
-
-        :param data: Data field (0x0000)
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = ForceListenOnlyModeRequest(data, **kwargs)
-        return self._execute_diagnostic_request(request)
-
-    def clear_counters(self, data=0, **kwargs):
-        """
-        Diagnostic sub command, Clear all counters and diag registers.
-
-        :param data: Data field (0x0000)
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = ClearCountersRequest(data, **kwargs)
-        return self._execute_diagnostic_request(request)
-
-    def return_bus_message_count(self, data=0, **kwargs):
-        """
-        Diagnostic sub command, Return count of message detected on bus \
-         by remote slave.
-
-        :param data: Data field (0x0000)
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = ReturnBusMessageCountRequest(data, **kwargs)
-        return self._execute_diagnostic_request(request)
-
-    def return_bus_com_error_count(self, data=0, **kwargs):
-        """
-        Diagnostic sub command, Return count of CRC errors \
-        received by remote slave.
-
-        :param data: Data field (0x0000)
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = ReturnBusCommunicationErrorCountRequest(data, **kwargs)
-        return self._execute_diagnostic_request(request)
-
-    def return_bus_exception_error_count(self, data=0, **kwargs):
-        """
-        Diagnostic sub command, Return count of Modbus exceptions \
-        returned by remote slave.
-
-        :param data: Data field (0x0000)
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = ReturnBusExceptionErrorCountRequest(data, **kwargs)
-        return self._execute_diagnostic_request(request)
-
-    def return_slave_message_count(self, data=0, **kwargs):
-        """
-        Diagnostic sub command, Return count of messages addressed to \
-        remote slave.
-
-        :param data: Data field (0x0000)
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = ReturnSlaveMessageCountRequest(data, **kwargs)
-        return self._execute_diagnostic_request(request)
-
-    def return_slave_no_response_count(self, data=0, **kwargs):
-        """
-        Diagnostic sub command, Return count of No responses  by remote slave.
-
-        :param data: Data field (0x0000)
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = ReturnSlaveNoResponseCountRequest(data, **kwargs)
-        return self._execute_diagnostic_request(request)
-
-    def return_slave_no_ack_count(self, data=0, **kwargs):
-        """
-        Diagnostic sub command, Return count of NO ACK exceptions sent \
-         by remote slave.
-
-        :param data: Data field (0x0000)
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = ReturnSlaveNAKCountRequest(data, **kwargs)
-        return self._execute_diagnostic_request(request)
-
-    def return_slave_busy_count(self, data=0, **kwargs):
-        """
-        Diagnostic sub command, Return count of server busy exceptions sent \
-         by remote slave.
-
-        :param data: Data field (0x0000)
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = ReturnSlaveBusyCountRequest(data, **kwargs)
-        return self._execute_diagnostic_request(request)
-
-    def return_slave_bus_char_overrun_count(self, data=0, **kwargs):
-        """
-        Diagnostic sub command, Return count of messages not handled \
-         by remote slave due to character overrun condition.
-
-        :param data: Data field (0x0000)
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = ReturnSlaveBusCharacterOverrunCountRequest(data, **kwargs)
-        return self._execute_diagnostic_request(request)
-
-    def return_iop_overrun_count(self, data=0, **kwargs):
-        """
-        Diagnostic sub command, Return count of iop overrun errors \
-        by remote slave.
-
-        :param data: Data field (0x0000)
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = ReturnIopOverrunCountRequest(data, **kwargs)
-        return self._execute_diagnostic_request(request)
-
-    def clear_overrun_count(self, data=0, **kwargs):
-        """
-        Diagnostic sub command, Clear over run counter.
-
-        :param data: Data field (0x0000)
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = ClearOverrunCountRequest(data, **kwargs)
-        return self._execute_diagnostic_request(request)
-
-    def get_clear_modbus_plus(self, data=0, **kwargs):
-        """
-        Diagnostic sub command, Get or clear stats of remote \
-         modbus plus device.
-
-        :param data: Data field (0x0000)
-        :param unit: The slave unit this request is targeting
-        :return:
-        """
-        request = GetClearModbusPlusRequest(data, **kwargs)
-        return self._execute_diagnostic_request(request)
-
-
-class ModbusSerialClient(ExtendedRequestSupport, _ModbusSerialClient):
-    def __init__(self, method, **kwargs):
-        super(ModbusSerialClient, self).__init__(method, **kwargs)
-
-    def get_port(self):
-        """
-        Serial Port.
-
-        :return: Current Serial port
-        """
-        return self.port
-
-    def set_port(self, value):
-        """
-        Serial Port setter.
-
-        :param value: New port
-        """
-        self.port = value
-        if self.is_socket_open():
-            self.close()
-
-    def get_stopbits(self):
-        """
-        Number of stop bits.
-
-        :return: Current Stop bits
-        """
-        return self.stopbits
-
-    def set_stopbits(self, value):
-        """
-        Stop bit setter.
-
-        :param value: Possible values (1, 1.5, 2)
-        """
-        self.stopbits = float(value)
-        if self.is_socket_open():
-            self.close()
-
-    def get_bytesize(self):
-        """
-        Number of data bits.
-
-        :return: Current bytesize
-        """
-        return self.bytesize
-
-    def set_bytesize(self, value):
-        """
-        Byte size setter.
-
-        :param value: Possible values (5, 6, 7, 8)
-
-        """
-        self.bytesize = int(value)
-        if self.is_socket_open():
-            self.close()
-
-    def get_parity(self):
-        """
-        Enable Parity Checking.
-
-        :return: Current parity setting
-        """
-        return self.parity
-
-    def set_parity(self, value):
-        """
-        Parity Setter.
-
-        :param value: Possible values ('N', 'E', 'O', 'M', 'S')
-        """
-        self.parity = value
-        if self.is_socket_open():
-            self.close()
-
-    def get_baudrate(self):
-        """
-        Serial Port baudrate.
-
-        :return: Current baudrate
-        """
-        return self.baudrate
-
-    def set_baudrate(self, value):
-        """
-        Baudrate setter.
-
-        :param value: <supported baudrate>
-        """
-        self.baudrate = int(value)
-        if self.is_socket_open():
-            self.close()
-
-    def get_timeout(self):
-        """
-        Serial Port Read timeout.
-
-        :return: Current read imeout.
-        """
-        return self.timeout
-
-    def set_timeout(self, value):
-        """
-        Read timeout setter.
-
-        :param value: Read Timeout in seconds
-        """
-        self.timeout = float(value)
-        if self.is_socket_open():
-            self.close()
-
-    def get_serial_settings(self):
-        """
-        Gets Current Serial port settings.
-
-        :return: Current Serial settings as dict.
-        """
-        return {
-            'baudrate': self.baudrate,
-            'port': self.port,
-            'parity': self.parity,
-            'stopbits': self.stopbits,
-            'bytesize': self.bytesize,
-            'read timeout': self.timeout,
-            't1.5': self.inter_char_timeout,
-            't3.5': self.silent_interval
-        }
-
-
-class ModbusTcpClient(ExtendedRequestSupport, _ModbusTcpClient):
-    def __init__(self, **kwargs):
-        super(ModbusTcpClient, self).__init__(**kwargs)
diff --git a/venv/lib/python3.7/site-packages/pymodbus/repl/completer.py b/venv/lib/python3.7/site-packages/pymodbus/repl/completer.py
deleted file mode 100644
index 391c245..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/repl/completer.py
+++ /dev/null
@@ -1,156 +0,0 @@
-"""
-Command Completion for pymodbus REPL.
-
-Copyright (c) 2018 Riptide IO, Inc. All Rights Reserved.
-
-"""
-from __future__ import absolute_import, unicode_literals
-from prompt_toolkit.completion import Completer, Completion
-from prompt_toolkit.styles import Style
-from prompt_toolkit.filters import Condition
-from prompt_toolkit.application.current import get_app
-from pymodbus.repl.helper import get_commands
-from pymodbus.compat import string_types
-
-
-@Condition
-def has_selected_completion():
-    complete_state = get_app().current_buffer.complete_state
-    return (complete_state is not None and
-            complete_state.current_completion is not None)
-
-
-style = Style.from_dict({
-    'completion-menu.completion': 'bg:#008888 #ffffff',
-    'completion-menu.completion.current': 'bg:#00aaaa #000000',
-    'scrollbar.background': 'bg:#88aaaa',
-    'scrollbar.button': 'bg:#222222',
-})
-
-
-class CmdCompleter(Completer):
-    """
-    Completer for Pymodbus REPL.
-    """
-
-    def __init__(self, client, commands=None, ignore_case=True):
-        """
-
-        :param client: Modbus Client
-        :param commands: Commands to be added for Completion (list)
-        :param ignore_case: Ignore Case while looking up for commands
-        """
-        self._commands = commands or get_commands(client)
-        self._commands['help'] = ""
-        self._command_names = self._commands.keys()
-        self.ignore_case = ignore_case
-
-    @property
-    def commands(self):
-        return self._commands
-
-    @property
-    def command_names(self):
-        return self._commands.keys()
-
-    def completing_command(self, words, word_before_cursor):
-        """
-        Determine if we are dealing with supported command.
-
-        :param words: Input text broken in to word tokens.
-        :param word_before_cursor: The current word before the cursor, \
-            which might be one or more blank spaces.
-        :return:
-        """
-        if len(words) == 1 and word_before_cursor != '':
-            return True
-        else:
-            return False
-
-    def completing_arg(self, words, word_before_cursor):
-        """
-        Determine if we are currently completing an argument.
-
-        :param words: The input text broken into word tokens.
-        :param word_before_cursor: The current word before the cursor, \
-            which might be one or more blank spaces.
-        :return: Specifies whether we are currently completing an arg.
-        """
-        if len(words) > 1 and word_before_cursor != '':
-            return True
-        else:
-            return False
-
-    def arg_completions(self, words, word_before_cursor):
-        """
-        Generates arguments completions based on the input.
-
-        :param words: The input text broken into word tokens.
-        :param word_before_cursor: The current word  before the cursor, \
-            which might be one or more blank spaces.
-        :return: A list of completions.
-        """
-        cmd = words[0].strip()
-        cmd = self._commands.get(cmd, None)
-        if cmd:
-            return cmd
-
-    def _get_completions(self, word, word_before_cursor):
-        if self.ignore_case:
-            word_before_cursor = word_before_cursor.lower()
-        return self.word_matches(word, word_before_cursor)
-
-    def word_matches(self, word, word_before_cursor):
-        """
-        Match the word and word before cursor
-
-        :param words: The input text broken into word tokens.
-        :param word_before_cursor: The current word before the cursor, \
-            which might be one or more blank spaces.
-        :return: True if matched.
-
-        """
-        if self.ignore_case:
-            word = word.lower()
-        return word.startswith(word_before_cursor)
-
-    def get_completions(self, document, complete_event):
-        """
-        Get completions for the current scope.
-
-        :param document: An instance of `prompt_toolkit.Document`.
-        :param complete_event: (Unused).
-        :return: Yields an instance of `prompt_toolkit.completion.Completion`.
-        """
-        word_before_cursor = document.get_word_before_cursor(WORD=True)
-        text = document.text_before_cursor.lstrip()
-        words = document.text.strip().split()
-        meta = None
-        commands = []
-        if len(words) == 0:
-            # yield commands
-            pass
-        if self.completing_command(words, word_before_cursor):
-            commands = self._command_names
-            c_meta = {
-                k: v.help_text
-                if not isinstance(v, string_types)
-                else v for k, v in self._commands.items()
-            }
-            meta = lambda x: (x, c_meta.get(x, ''))
-        else:
-            if not list(filter(lambda cmd: any(x == cmd for x in words),
-                               self._command_names)):
-                # yield commands
-                pass
-
-            if ' ' in text:
-                command = self.arg_completions(words, word_before_cursor)
-                commands = list(command.get_completion())
-                commands = list(filter(lambda cmd: not(any(cmd in x for x in words)), commands))
-                meta = command.get_meta
-        for a in commands:
-            if self._get_completions(a, word_before_cursor):
-                cmd, display_meta = meta(a) if meta else ('', '')
-                yield Completion(a, -len(word_before_cursor),
-                                 display_meta=display_meta)
diff --git a/venv/lib/python3.7/site-packages/pymodbus/repl/helper.py b/venv/lib/python3.7/site-packages/pymodbus/repl/helper.py
deleted file mode 100644
index 7f255a7..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/repl/helper.py
+++ /dev/null
@@ -1,326 +0,0 @@
-"""
-Helper Module for REPL actions.
-
-Copyright (c) 2018 Riptide IO, Inc. All Rights Reserved.
-
-"""
-from __future__ import absolute_import, unicode_literals
-import json
-import pygments
-import inspect
-from collections import OrderedDict
-from pygments.lexers.data import JsonLexer
-from prompt_toolkit.formatted_text import PygmentsTokens, HTML
-from prompt_toolkit import print_formatted_text
-
-from pymodbus.payload import BinaryPayloadDecoder, Endian
-from pymodbus.compat import PYTHON_VERSION, IS_PYTHON2, string_types, izip
-
-predicate = inspect.ismethod
-if IS_PYTHON2 or PYTHON_VERSION < (3, 3):
-    argspec = inspect.getargspec
-else:
-    predicate = inspect.isfunction
-    argspec = inspect.signature
-
-
-FORMATTERS = {
-    'int8': 'decode_8bit_int',
-    'int16': 'decode_16bit_int',
-    'int32': 'decode_32bit_int',
-    'int64': 'decode_64bit_int',
-    'uint8': 'decode_8bit_uint',
-    'uint16': 'decode_16bit_uint',
-    'uint32': 'decode_32bit_uint',
-    'uint64': 'decode_64bit_int',
-    'float32': 'decode_32bit_float',
-    'float64': 'decode_64bit_float',
-}
-
-
-DEFAULT_KWARGS = {
-    'unit': 'Slave address'
-}
-
-OTHER_COMMANDS = {
-    "result.raw": "Show RAW Result",
-    "result.decode": "Decode register response to known formats",
-}
-EXCLUDE = ['execute', 'recv', 'send', 'trace', 'set_debug']
-CLIENT_METHODS = [
-    'connect', 'close', 'idle_time', 'is_socket_open', 'get_port', 'set_port',
-    'get_stopbits', 'set_stopbits', 'get_bytesize', 'set_bytesize',
-    'get_parity', 'set_parity', 'get_baudrate', 'set_baudrate', 'get_timeout',
-    'set_timeout', 'get_serial_settings'
-
-]
-CLIENT_ATTRIBUTES = []
-
-
-class Command(object):
-    """
-    Class representing Commands to be consumed by Completer.
-    """
-    def __init__(self, name, signature, doc, unit=False):
-        """
-
-        :param name: Name of the command
-        :param signature: inspect object
-        :param doc: Doc string for the command
-        :param unit: Use unit as additional argument in the command .
-        """
-        self.name = name
-        self.doc = doc.split("\n") if doc else " ".join(name.split("_"))
-        self.help_text = self._create_help()
-        self.param_help = self._create_arg_help()
-        if signature:
-            if IS_PYTHON2:
-                self._params = signature
-            else:
-                self._params = signature.parameters
-            self.args = self.create_completion()
-        else:
-            self._params = ''
-
-        if self.name.startswith("client.") and unit:
-            self.args.update(**DEFAULT_KWARGS)
-
-    def _create_help(self):
-        doc = filter(lambda d: d, self.doc)
-        cmd_help = list(filter(
-            lambda x: not x.startswith(":param") and not x.startswith(
-                ":return"), doc))
-        return " ".join(cmd_help).strip()
-
-    def _create_arg_help(self):
-        param_dict = {}
-        params = list(filter(lambda d: d.strip().startswith(":param"),
-                             self.doc))
-        for param in params:
-            param, help = param.split(":param")[1].strip().split(":")
-            param_dict[param] = help
-        return param_dict
-
-    def create_completion(self):
-        """
-        Create command completion meta data.
-
-        :return:
-        """
-        words = {}
-
-        def _create(entry, default):
-            if entry not in ['self', 'kwargs']:
-                if isinstance(default, (int, string_types)):
-                    entry += "={}".format(default)
-                return entry
-
-        if IS_PYTHON2:
-            if not self._params.defaults:
-                defaults = [None]*len(self._params.args)
-            else:
-                defaults = list(self._params.defaults)
-                missing = len(self._params.args) - len(defaults)
-                if missing > 1:
-                    defaults.extend([None]*missing)
-            defaults.insert(0, None)
-            for arg, default in izip(self._params.args, defaults):
-                entry = _create(arg, default)
-                if entry:
-                    entry, meta = self.get_meta(entry)
-                    words[entry] = help
-        else:
-            for arg in self._params.values():
-                entry = _create(arg.name, arg.default)
-                if entry:
-                    entry, meta = self.get_meta(entry)
-                    words[entry] = meta
-
-        return words
-
-    def get_completion(self):
-        """
-        Gets a list of completions.
-
-        :return:
-        """
-        return self.args.keys()
-
-    def get_meta(self, cmd):
-        """
-        Get Meta info of a given command.
-
-        :param cmd: Name of command.
-        :return: Dict containing meta info.
-        """
-        cmd = cmd.strip()
-        cmd = cmd.split("=")[0].strip()
-        return cmd, self.param_help.get(cmd, '')
-
-    def __str__(self):
-        if self.doc:
-            return "Command {0:>50}{:<20}".format(self.name, self.doc)
-        return "Command {}".format(self.name)
-
-
-def _get_requests(members):
-    commands = list(filter(lambda x: (x[0] not in EXCLUDE
-                                      and x[0] not in CLIENT_METHODS
-                                      and callable(x[1])),
-                           members))
-    commands = {
-        "client.{}".format(c[0]):
-            Command("client.{}".format(c[0]),
-                    argspec(c[1]), inspect.getdoc(c[1]), unit=True)
-        for c in commands if not c[0].startswith("_")
-    }
-    return commands
-
-
-def _get_client_methods(members):
-    commands = list(filter(lambda x: (x[0] not in EXCLUDE
-                                      and x[0] in CLIENT_METHODS),
-                           members))
-    commands = {
-        "client.{}".format(c[0]):
-            Command("client.{}".format(c[0]),
-                    argspec(c[1]), inspect.getdoc(c[1]), unit=False)
-        for c in commands if not c[0].startswith("_")
-    }
-    return commands
-
-
-def _get_client_properties(members):
-    global CLIENT_ATTRIBUTES
-    commands = list(filter(lambda x: not callable(x[1]), members))
-    commands = {
-        "client.{}".format(c[0]):
-            Command("client.{}".format(c[0]), None, "Read Only!", unit=False)
-        for c in commands if (not c[0].startswith("_")
-                              and isinstance(c[1], (string_types, int, float)))
-    }
-    CLIENT_ATTRIBUTES.extend(list(commands.keys()))
-    return commands
-
-
-def get_commands(client):
-    """
-    Helper method to retrieve all required methods and attributes of a client \
-    object and convert it to commands.
-
-    :param client: Modbus Client object.
-    :return:
-    """
-    commands = dict()
-    members = inspect.getmembers(client)
-    requests = _get_requests(members)
-    client_methods = _get_client_methods(members)
-    client_attr = _get_client_properties(members)
-
-    result_commands = inspect.getmembers(Result, predicate=predicate)
-    result_commands = {
-        "result.{}".format(c[0]):
-            Command("result.{}".format(c[0]), argspec(c[1]),
-                    inspect.getdoc(c[1]))
-        for c in result_commands if (not c[0].startswith("_")
-                                     and c[0] != "print_result")
-    }
-    commands.update(requests)
-    commands.update(client_methods)
-    commands.update(client_attr)
-    commands.update(result_commands)
-    return commands
-
-
-class Result(object):
-    """
-    Represent result command.
-    """
-    function_code = None
-    data = None
-
-    def __init__(self, result):
-        """
-        :param result: Response of a modbus command.
-        """
-        if isinstance(result, dict):  # Modbus response
-            self.function_code = result.pop('function_code', None)
-            self.data = dict(result)
-        else:
-            self.data = result
-
-    def decode(self, formatters, byte_order='big', word_order='big'):
-        """
-        Decode the register response to known formatters.
-
-        :param formatters: int8/16/32/64, uint8/16/32/64, float32/64
-        :param byte_order: little/big
-        :param word_order: little/big
-        :return: Decoded Value
-        """
-        # Read Holding Registers (3)
-        # Read Input Registers (4)
-        # Read Write Registers (23)
-        if not isinstance(formatters, (list, tuple)):
-            formatters = [formatters]
-
-        if self.function_code not in [3, 4, 23]:
-            print_formatted_text(
-                HTML("<red>Decoder works only for registers!!</red>"))
-            return
-        byte_order = (Endian.Little if byte_order.strip().lower() == "little"
-                      else Endian.Big)
-        word_order = (Endian.Little if word_order.strip().lower() == "little"
-                      else Endian.Big)
-        decoder = BinaryPayloadDecoder.fromRegisters(self.data.get('registers'),
-                                                     byteorder=byte_order,
-                                                     wordorder=word_order)
-        for formatter in formatters:
-            formatter = FORMATTERS.get(formatter)
-            if not formatter:
-                print_formatted_text(
-                    HTML("<red>Invalid Formatter - {}"
-                         "!!</red>".format(formatter)))
-                return
-            decoded = getattr(decoder, formatter)()
-            self.print_result(decoded)
-
-    def raw(self):
-        """
-        Return raw result dict.
-
-        :return:
-        """
-        self.print_result()
-
-    def _process_dict(self, d):
-        new_dict = OrderedDict()
-        for k, v in d.items():
-            if isinstance(v, bytes):
-                v = v.decode('utf-8')
-            elif isinstance(v, dict):
-                v = self._process_dict(v)
-            elif isinstance(v, (list, tuple)):
-                v = [v1.decode('utf-8') if isinstance(v1, bytes) else v1
-                     for v1 in v ]
-            new_dict[k] = v
-        return new_dict
-
-    def print_result(self, data=None):
-        """
-        Prettu print result object.
-
-        :param data: Data to be printed.
-        :return:
-        """
-        data = data or self.data
-        if isinstance(data, dict):
-            data = self._process_dict(data)
-        elif isinstance(data, (list, tuple)):
-            data = [v.decode('utf-8') if isinstance(v, bytes) else v
-                    for v in data]
-        elif isinstance(data, bytes):
-            data = data.decode('utf-8')
-        tokens = list(pygments.lex(json.dumps(data, indent=4),
-                                   lexer=JsonLexer()))
-        print_formatted_text(PygmentsTokens(tokens))
diff --git a/venv/lib/python3.7/site-packages/pymodbus/repl/main.py b/venv/lib/python3.7/site-packages/pymodbus/repl/main.py
deleted file mode 100644
index cd13f29..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/repl/main.py
+++ /dev/null
@@ -1,355 +0,0 @@
-"""
-Pymodbus REPL Entry point.
-
-Copyright (c) 2018 Riptide IO, Inc. All Rights Reserved.
-
-"""
-from __future__ import absolute_import, unicode_literals
-try:
-    import click
-except ImportError:
-    print("click not installed!! Install with 'pip install click'")
-    exit(1)
-try:
-    from prompt_toolkit import PromptSession, print_formatted_text
-except ImportError:
-    print("prompt toolkit is not installed!! "
-          "Install with 'pip install prompt_toolkit --upgrade'")
-    exit(1)
-
-from prompt_toolkit.lexers import PygmentsLexer
-from prompt_toolkit.styles import Style
-from prompt_toolkit.key_binding import KeyBindings
-
-from pygments.lexers.python import PythonLexer
-from prompt_toolkit.formatted_text import HTML
-from prompt_toolkit.history import FileHistory
-from prompt_toolkit.auto_suggest import AutoSuggestFromHistory
-from pymodbus.version import version
-from pymodbus.repl.completer import CmdCompleter, has_selected_completion
-from pymodbus.repl.helper import Result, CLIENT_ATTRIBUTES
-
-click.disable_unicode_literals_warning = True
-
-TITLE = """
-----------------------------------------------------------------------------
-__________          _____             .___  __________              .__   
-\______   \___.__. /     \   ____   __| _/  \______   \ ____ ______ |  |  
- |     ___<   |  |/  \ /  \ /  _ \ / __ |    |       _// __ \\\____ \|  |  
- |    |    \___  /    Y    (  <_> ) /_/ |    |    |   \  ___/|  |_> >  |__
- |____|    / ____\____|__  /\____/\____ | /\ |____|_  /\___  >   __/|____/
-           \/            \/            \/ \/        \/     \/|__|
-                                        v{} - {}         
-----------------------------------------------------------------------------
-""".format("1.1.0", version)
-log = None
-
-
-style = Style.from_dict({
-    'completion-menu.completion': 'bg:#008888 #ffffff',
-    'completion-menu.completion.current': 'bg:#00aaaa #000000',
-    'scrollbar.background': 'bg:#88aaaa',
-    'scrollbar.button': 'bg:#222222',
-})
-
-
-def bottom_toolbar():
-    """
-    Console toolbar.
-    :return:
-    """
-    return HTML('Press <b><style bg="ansired">CTRL+D or exit </style></b>'
-                ' to exit! Type "help" for list of available commands')
-
-
-class CaseInsenstiveChoice(click.Choice):
-    """
-    Case Insensitive choice for click commands and options
-    """
-    def convert(self, value, param, ctx):
-        """
-        Convert args to uppercase for evaluation.
-
-        """
-        if value is None:
-            return None
-        return super(CaseInsenstiveChoice, self).convert(
-            value.strip().upper(), param, ctx)
-
-
-class NumericChoice(click.Choice):
-    """
-    Numeric choice for click arguments and options.
-    """
-    def __init__(self, choices, typ):
-        self.typ = typ
-        super(NumericChoice, self).__init__(choices)
-
-    def convert(self, value, param, ctx):
-        # Exact match
-        if value in self.choices:
-            return self.typ(value)
-
-        if ctx is not None and ctx.token_normalize_func is not None:
-            value = ctx.token_normalize_func(value)
-            for choice in self.casted_choices:
-                if ctx.token_normalize_func(choice) == value:
-                    return choice
-
-        self.fail('invalid choice: %s. (choose from %s)' %
-                  (value, ', '.join(self.choices)), param, ctx)
-
-
-def cli(client):
-    kb = KeyBindings()
-
-    @kb.add('c-space')
-    def _(event):
-        """
-        Initialize autocompletion, or select the next completion.
-        """
-        buff = event.app.current_buffer
-        if buff.complete_state:
-            buff.complete_next()
-        else:
-            buff.start_completion(select_first=False)
-
-    @kb.add('enter', filter=has_selected_completion)
-    def _(event):
-        """
-        Makes the enter key work as the tab key only when showing the menu.
-        """
-
-        event.current_buffer.complete_state = None
-        b = event.cli.current_buffer
-        b.complete_state = None
-
-    def _process_args(args, string=True):
-        kwargs = {}
-        execute = True
-        skip_index = None
-        for i, arg in enumerate(args):
-            if i == skip_index:
-                continue
-            arg = arg.strip()
-            if "=" in arg:
-                a, val = arg.split("=")
-                if not string:
-                    if "," in val:
-                        val = val.split(",")
-                        val = [int(v) for v in val]
-                    else:
-                        val = int(val)
-                kwargs[a] = val
-            else:
-                a, val = arg, args[i + 1]
-                try:
-                    if not string:
-                        if "," in val:
-                            val = val.split(",")
-                            val = [int(v) for v in val]
-                        else:
-                            val = int(val)
-                    kwargs[a] = val
-                    skip_index = i + 1
-                except TypeError:
-                    click.secho("Error parsing arguments!",
-                                fg='yellow')
-                    execute = False
-                    break
-                except ValueError:
-                    click.secho("Error parsing argument",
-                                fg='yellow')
-                    execute = False
-                    break
-        return kwargs, execute
-
-    session = PromptSession(lexer=PygmentsLexer(PythonLexer),
-                            completer=CmdCompleter(client), style=style,
-                            complete_while_typing=True,
-                            bottom_toolbar=bottom_toolbar,
-                            key_bindings=kb,
-                            history=FileHistory('.pymodhis'),
-                            auto_suggest=AutoSuggestFromHistory())
-    click.secho("{}".format(TITLE), fg='green')
-    result = None
-    while True:
-        try:
-
-            text = session.prompt('> ', complete_while_typing=True)
-            if text.strip().lower() == 'help':
-                print_formatted_text(HTML("<u>Available commands:</u>"))
-                for cmd, obj in sorted(session.completer.commands.items()):
-                    if cmd != 'help':
-                        print_formatted_text(
-                            HTML("<skyblue>{:45s}</skyblue>"
-                                 "<seagreen>{:100s}"
-                                 "</seagreen>".format(cmd, obj.help_text)))
-
-                continue
-            elif text.strip().lower() == 'exit':
-                raise EOFError()
-            elif text.strip().lower().startswith("client."):
-                try:
-                    text = text.strip().split()
-                    cmd = text[0].split(".")[1]
-                    args = text[1:]
-                    kwargs, execute = _process_args(args, string=False)
-                    if execute:
-                        if text[0] in CLIENT_ATTRIBUTES:
-                            result = Result(getattr(client, cmd))
-                        else:
-                            result = Result(getattr(client, cmd)(**kwargs))
-                        result.print_result()
-                except Exception as e:
-                    click.secho(repr(e), fg='red')
-            elif text.strip().lower().startswith("result."):
-                if result:
-                    words = text.lower().split()
-                    if words[0] == 'result.raw':
-                        result.raw()
-                    if words[0] == 'result.decode':
-                        args = words[1:]
-                        kwargs, execute = _process_args(args)
-                        if execute:
-                            result.decode(**kwargs)
-        except KeyboardInterrupt:
-            continue  # Control-C pressed. Try again.
-        except EOFError:
-            break  # Control-D pressed.
-        except Exception as e:  # Handle all other exceptions
-            click.secho(str(e), fg='red')
-
-    click.secho('GoodBye!', fg='blue')
-
-
-@click.group('pymodbus-repl')
-@click.version_option(version, message=TITLE)
-@click.option("--verbose", is_flag=True, default=False, help="Verbose logs")
-@click.pass_context
-def main(ctx, verbose):
-    if verbose:
-        global log
-        import logging
-        format = ('%(asctime)-15s %(threadName)-15s '
-                  '%(levelname)-8s %(module)-15s:%(lineno)-8s %(message)s')
-        log = logging.getLogger('pymodbus')
-        logging.basicConfig(format=format)
-        log.setLevel(logging.DEBUG)
-
-
-@main.command("tcp")
-@click.pass_context
-@click.option(
-    "--host",
-    help="Modbus TCP IP "
-)
-@click.option(
-    "--port",
-    default=502,
-    type=int,
-    help="Modbus TCP port",
-)
-def tcp(ctx, host, port):
-    from pymodbus.repl.client import ModbusTcpClient
-    client = ModbusTcpClient(host=host, port=port)
-    cli(client)
-
-
-@main.command("serial")
-@click.pass_context
-@click.option(
-    "--method",
-    default='rtu',
-    type=str,
-    help="Modbus Serial Mode (rtu/ascii)",
-)
-@click.option(
-    "--port",
-    default=None,
-    type=str,
-    help="Modbus RTU port",
-)
-@click.option(
-        "--baudrate",
-        help="Modbus RTU serial baudrate to use. Defaults to 9600",
-        default=9600,
-        type=int
-    )
-@click.option(
-    "--bytesize",
-    help="Modbus RTU serial Number of data bits. "
-         "Possible values: FIVEBITS, SIXBITS, SEVENBITS, "
-         "EIGHTBITS. Defaults to 8",
-    type=NumericChoice(["5", "6", "7", "8"], int),
-    default="8"
-)
-@click.option(
-    "--parity",
-    help="Modbus RTU serial parity. "
-         " Enable parity checking. Possible values: "
-         "PARITY_NONE, PARITY_EVEN, PARITY_ODD PARITY_MARK, "
-         "PARITY_SPACE. Default to 'N'",
-    default='N',
-    type=CaseInsenstiveChoice(['N', 'E', 'O', 'M', 'S'])
-)
-@click.option(
-    "--stopbits",
-    help="Modbus RTU serial stop bits. "
-         "Number of stop bits. Possible values: STOPBITS_ONE, "
-         "STOPBITS_ONE_POINT_FIVE, STOPBITS_TWO. Default to '1'",
-    default="1",
-    type=NumericChoice(["1", "1.5", "2"], float),
-)
-@click.option(
-    "--xonxoff",
-    help="Modbus RTU serial xonxoff.  Enable software flow control."
-         "Defaults to 0",
-    default=0,
-    type=int
-)
-@click.option(
-    "--rtscts",
-    help="Modbus RTU serial rtscts. Enable hardware (RTS/CTS) flow "
-         "control. Defaults to 0",
-    default=0,
-    type=int
-)
-@click.option(
-    "--dsrdtr",
-    help="Modbus RTU serial dsrdtr. Enable hardware (DSR/DTR) flow "
-         "control. Defaults to 0",
-    default=0,
-    type=int
-)
-@click.option(
-    "--timeout",
-    help="Modbus RTU serial read timeout. Defaults to 0.025 sec",
-    default=0.25,
-    type=float
-)
-@click.option(
-    "--write-timeout",
-    help="Modbus RTU serial write timeout. Defaults to 2 sec",
-    default=2,
-    type=float
-)
-def serial(ctx, method, port, baudrate, bytesize, parity, stopbits, xonxoff,
-           rtscts, dsrdtr, timeout, write_timeout):
-    from pymodbus.repl.client import ModbusSerialClient
-    client = ModbusSerialClient(method=method,
-                                port=port,
-                                baudrate=baudrate,
-                                bytesize=bytesize,
-                                parity=parity,
-                                stopbits=stopbits,
-                                xonxoff=xonxoff,
-                                rtscts=rtscts,
-                                dsrdtr=dsrdtr,
-                                timeout=timeout,
-                                write_timeout=write_timeout)
-    cli(client)
-
-
-if __name__ == "__main__":
-    main()
diff --git a/venv/lib/python3.7/site-packages/pymodbus/server/__init__.py b/venv/lib/python3.7/site-packages/pymodbus/server/__init__.py
deleted file mode 100644
index 35350f6..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/server/__init__.py
+++ /dev/null
@@ -1,2 +0,0 @@
-'''
-'''
diff --git a/venv/lib/python3.7/site-packages/pymodbus/server/asynchronous.py b/venv/lib/python3.7/site-packages/pymodbus/server/asynchronous.py
deleted file mode 100644
index 6ac991a..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/server/asynchronous.py
+++ /dev/null
@@ -1,363 +0,0 @@
-"""
-Implementation of a Twisted Modbus Server
-------------------------------------------
-
-"""
-from binascii import b2a_hex
-from twisted.internet import protocol
-from twisted.internet.protocol import ServerFactory
-from twisted.internet import reactor
-
-from pymodbus.constants import Defaults
-from pymodbus.utilities import hexlify_packets
-from pymodbus.factory import ServerDecoder
-from pymodbus.datastore import ModbusServerContext
-from pymodbus.device import ModbusControlBlock
-from pymodbus.device import ModbusAccessControl
-from pymodbus.device import ModbusDeviceIdentification
-from pymodbus.exceptions import NoSuchSlaveException
-from pymodbus.transaction import (ModbusSocketFramer,
-                                  ModbusRtuFramer,
-                                  ModbusAsciiFramer,
-                                  ModbusBinaryFramer)
-from pymodbus.pdu import ModbusExceptions as merror
-from pymodbus.internal.ptwisted import InstallManagementConsole
-from pymodbus.compat import IS_PYTHON3
-
-# --------------------------------------------------------------------------- #
-# Logging
-# --------------------------------------------------------------------------- #
-import logging
-_logger = logging.getLogger(__name__)
-
-
-# --------------------------------------------------------------------------- #
-# Modbus TCP Server
-# --------------------------------------------------------------------------- #
-class ModbusTcpProtocol(protocol.Protocol):
-    """ Implements a modbus server in twisted """
-
-    def connectionMade(self):
-        """ Callback for when a client connects
-
-        ..note:: since the protocol factory cannot be accessed from the
-                 protocol __init__, the client connection made is essentially
-                 our __init__ method.
-        """
-        _logger.debug("Client Connected [%s]" % self.transport.getHost())
-        self.framer = self.factory.framer(decoder=self.factory.decoder,
-                                          client=None)
-
-    def connectionLost(self, reason):
-        """ Callback for when a client disconnects
-
-        :param reason: The client's reason for disconnecting
-        """
-        _logger.debug("Client Disconnected: %s" % reason)
-
-    def dataReceived(self, data):
-        """ Callback when we receive any data
-
-        :param data: The data sent by the client
-        """
-        if _logger.isEnabledFor(logging.DEBUG):
-            _logger.debug('Data Received: ' + hexlify_packets(data))
-        if not self.factory.control.ListenOnly:
-            units = self.factory.store.slaves()
-            single = self.factory.store.single
-            self.framer.processIncomingPacket(data, self._execute,
-                                              single=single,
-                                              unit=units)
-
-    def _execute(self, request):
-        """ Executes the request and returns the result
-
-        :param request: The decoded request message
-        """
-        try:
-            context = self.factory.store[request.unit_id]
-            response = request.execute(context)
-        except NoSuchSlaveException as ex:
-            _logger.debug("requested slave does not exist: %s" % request.unit_id )
-            if self.factory.ignore_missing_slaves:
-                return # the client will simply timeout waiting for a response
-            response = request.doException(merror.GatewayNoResponse)
-        except Exception as ex:
-            _logger.debug("Datastore unable to fulfill request: %s" % ex)
-            response = request.doException(merror.SlaveFailure)
-
-        response.transaction_id = request.transaction_id
-        response.unit_id = request.unit_id
-        self._send(response)
-
-    def _send(self, message):
-        """ Send a request (string) to the network
-
-        :param message: The unencoded modbus response
-        """
-        if message.should_respond:
-            self.factory.control.Counter.BusMessage += 1
-            pdu = self.framer.buildPacket(message)
-            if _logger.isEnabledFor(logging.DEBUG):
-                _logger.debug('send: %s' % b2a_hex(pdu))
-            return self.transport.write(pdu)
-
-
-class ModbusServerFactory(ServerFactory):
-    """
-    Builder class for a modbus server
-
-    This also holds the server datastore so that it is
-    persisted between connections
-    """
-
-    protocol = ModbusTcpProtocol
-
-    def __init__(self, store, framer=None, identity=None, **kwargs):
-        """ Overloaded initializer for the modbus factory
-
-        If the identify structure is not passed in, the ModbusControlBlock
-        uses its own empty structure.
-
-        :param store: The ModbusServerContext datastore
-        :param framer: The framer strategy to use
-        :param identity: An optional identify structure
-        :param ignore_missing_slaves: True to not send errors on a request to a missing slave
-        """
-        self.decoder = ServerDecoder()
-        self.framer = framer or ModbusSocketFramer
-        self.store = store or ModbusServerContext()
-        self.control = ModbusControlBlock()
-        self.access = ModbusAccessControl()
-        self.ignore_missing_slaves = kwargs.get('ignore_missing_slaves', Defaults.IgnoreMissingSlaves)
-
-        if isinstance(identity, ModbusDeviceIdentification):
-            self.control.Identity.update(identity)
-
-
-# --------------------------------------------------------------------------- #
-# Modbus UDP Server
-# --------------------------------------------------------------------------- #
-class ModbusUdpProtocol(protocol.DatagramProtocol):
-    """ Implements a modbus udp server in twisted """
-
-    def __init__(self, store, framer=None, identity=None, **kwargs):
-        """ Overloaded initializer for the modbus factory
-
-        If the identify structure is not passed in, the ModbusControlBlock
-        uses its own empty structure.
-
-        :param store: The ModbusServerContext datastore
-        :param framer: The framer strategy to use
-        :param identity: An optional identify structure
-        :param ignore_missing_slaves: True to not send errors on a request to
-        a missing slave
-        """
-        framer = framer or ModbusSocketFramer
-        self.decoder = ServerDecoder()
-        self.framer = framer(self.decoder)
-        self.store = store or ModbusServerContext()
-        self.control = ModbusControlBlock()
-        self.access = ModbusAccessControl()
-        self.ignore_missing_slaves = kwargs.get('ignore_missing_slaves',
-                                                Defaults.IgnoreMissingSlaves)
-
-        if isinstance(identity, ModbusDeviceIdentification):
-            self.control.Identity.update(identity)
-
-    def datagramReceived(self, data, addr):
-        """ Callback when we receive any data
-
-        :param data: The data sent by the client
-        """
-        _logger.debug("Client Connected [%s]" % addr)
-        if _logger.isEnabledFor(logging.DEBUG):
-            _logger.debug("Datagram Received: "+ hexlify_packets(data))
-        if not self.control.ListenOnly:
-            continuation = lambda request: self._execute(request, addr)
-            self.framer.processIncomingPacket(data, continuation)
-
-    def _execute(self, request, addr):
-        """ Executes the request and returns the result
-
-        :param request: The decoded request message
-        """
-        try:
-            context = self.store[request.unit_id]
-            response = request.execute(context)
-        except NoSuchSlaveException as ex:
-            _logger.debug("requested slave does not exist: "
-                          "%s" % request.unit_id )
-            if self.ignore_missing_slaves:
-                return # the client will simply timeout waiting for a response
-            response = request.doException(merror.GatewayNoResponse)
-        except Exception as ex:
-            _logger.debug("Datastore unable to fulfill request: %s" % ex)
-            response = request.doException(merror.SlaveFailure)
-        #self.framer.populateResult(response)
-        response.transaction_id = request.transaction_id
-        response.unit_id = request.unit_id
-        self._send(response, addr)
-
-    def _send(self, message, addr):
-        """ Send a request (string) to the network
-
-        :param message: The unencoded modbus response
-        :param addr: The (host, port) to send the message to
-        """
-        self.control.Counter.BusMessage += 1
-        pdu = self.framer.buildPacket(message)
-        if _logger.isEnabledFor(logging.DEBUG):
-            _logger.debug('send: %s' % b2a_hex(pdu))
-        return self.transport.write(pdu, addr)
-
-
-# --------------------------------------------------------------------------- #
-# Starting Factories
-# --------------------------------------------------------------------------- #
-def _is_main_thread():
-    import threading
-
-    if IS_PYTHON3:
-        if threading.current_thread() != threading.main_thread():
-            _logger.debug("Running in spawned thread")
-            return False
-    else:
-        if not isinstance(threading.current_thread(), threading._MainThread):
-            _logger.debug("Running in spawned thread")
-            return False
-    _logger.debug("Running in Main thread")
-    return True
-
-
-def StartTcpServer(context, identity=None, address=None,
-                   console=False, defer_reactor_run=False, custom_functions=[],
-                   **kwargs):
-    """
-    Helper method to start the Modbus Async TCP server
-
-    :param context: The server data context
-    :param identify: The server identity to use (default empty)
-    :param address: An optional (interface, port) to bind to.
-    :param console: A flag indicating if you want the debug console
-    :param ignore_missing_slaves: True to not send errors on a request \
-    to a missing slave
-    :param defer_reactor_run: True/False defer running reactor.run() as part \
-    of starting server, to be explictly started by the user
-    :param custom_functions: An optional list of custom function classes
-        supported by server instance.
-    """
-    from twisted.internet import reactor
-
-    address = address or ("", Defaults.Port)
-    framer = kwargs.pop("framer", ModbusSocketFramer)
-    factory = ModbusServerFactory(context, framer, identity, **kwargs)
-    for f in custom_functions:
-        factory.decoder.register(f)
-    if console:
-        InstallManagementConsole({'factory': factory})
-
-    _logger.info("Starting Modbus TCP Server on %s:%s" % address)
-    reactor.listenTCP(address[1], factory, interface=address[0])
-    if not defer_reactor_run:
-        reactor.run(installSignalHandlers=_is_main_thread())
-
-
-def StartUdpServer(context, identity=None, address=None,
-                   defer_reactor_run=False, custom_functions=[], **kwargs):
-    """
-    Helper method to start the Modbus Async Udp server
-
-    :param context: The server data context
-    :param identify: The server identity to use (default empty)
-    :param address: An optional (interface, port) to bind to.
-    :param ignore_missing_slaves: True to not send errors on a request \
-    to a missing slave
-    :param defer_reactor_run: True/False defer running reactor.run() as part \
-    of starting server, to be explictly started by the user
-    :param custom_functions: An optional list of custom function classes
-        supported by server instance.
-    """
-    from twisted.internet import reactor
-
-    address = address or ("", Defaults.Port)
-    framer = kwargs.pop("framer", ModbusSocketFramer)
-    server = ModbusUdpProtocol(context, framer, identity, **kwargs)
-    for f in custom_functions:
-        server.decoder.register(f)
-
-    _logger.info("Starting Modbus UDP Server on %s:%s" % address)
-    reactor.listenUDP(address[1], server, interface=address[0])
-    if not defer_reactor_run:
-        reactor.run(installSignalHandlers=_is_main_thread())
-
-
-def StartSerialServer(context, identity=None, framer=ModbusAsciiFramer,
-                      defer_reactor_run=False, custom_functions=[], **kwargs):
-    """
-    Helper method to start the Modbus Async Serial server
-
-    :param context: The server data context
-    :param identify: The server identity to use (default empty)
-    :param framer: The framer to use (default ModbusAsciiFramer)
-    :param port: The serial port to attach to
-    :param baudrate: The baud rate to use for the serial device
-    :param console: A flag indicating if you want the debug console
-    :param ignore_missing_slaves: True to not send errors on a request to a
-           missing slave
-    :param defer_reactor_run: True/False defer running reactor.run() as part
-           of starting server, to be explictly started by the user
-    :param custom_functions: An optional list of custom function classes
-        supported by server instance.
-
-    """
-    from twisted.internet import reactor
-    from twisted.internet.serialport import SerialPort
-
-    port = kwargs.get('port', '/dev/ttyS0')
-    baudrate = kwargs.get('baudrate', Defaults.Baudrate)
-    console = kwargs.get('console', False)
-    bytesize = kwargs.get("bytesize", Defaults.Bytesize)
-    stopbits = kwargs.get("stopbits", Defaults.Stopbits)
-    parity = kwargs.get("parity", Defaults.Parity)
-    timeout = kwargs.get("timeout", 0)
-    xonxoff = kwargs.get("xonxoff", 0)
-    rtscts = kwargs.get("rtscts", 0)
-
-    _logger.info("Starting Modbus Serial Server on %s" % port)
-    factory = ModbusServerFactory(context, framer, identity, **kwargs)
-    for f in custom_functions:
-        factory.decoder.register(f)
-    if console:
-        InstallManagementConsole({'factory': factory})
-    if console:
-        InstallManagementConsole({'factory': factory})
-
-    protocol = factory.buildProtocol(None)
-    SerialPort.getHost = lambda self: port  # hack for logging
-    SerialPort(protocol, port, reactor, baudrate=baudrate, parity=parity,
-               stopbits=stopbits, timeout=timeout, xonxoff=xonxoff,
-               rtscts=rtscts, bytesize=bytesize)
-    if not defer_reactor_run:
-        reactor.run(installSignalHandlers=_is_main_thread())
-
-
-def StopServer():
-    """
-    Helper method to stop Async Server
-    """
-    from twisted.internet import reactor
-    if _is_main_thread():
-        reactor.stop()
-        _logger.debug("Stopping server from main thread")
-    else:
-        reactor.callFromThread(reactor.stop)
-        _logger.debug("Stopping Server from another thread")
-
-
-# --------------------------------------------------------------------------- #
-# Exported symbols
-# --------------------------------------------------------------------------- #
-__all__ = [
-    "StartTcpServer", "StartUdpServer", "StartSerialServer", "StopServer"
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/server/sync.py b/venv/lib/python3.7/site-packages/pymodbus/server/sync.py
deleted file mode 100644
index 9492265..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/server/sync.py
+++ /dev/null
@@ -1,617 +0,0 @@
-"""
-Implementation of a Threaded Modbus Server
-------------------------------------------
-
-"""
-from binascii import b2a_hex
-import serial
-import socket
-import traceback
-
-from pymodbus.constants import Defaults
-from pymodbus.utilities import hexlify_packets
-from pymodbus.factory import ServerDecoder
-from pymodbus.datastore import ModbusServerContext
-from pymodbus.device import ModbusControlBlock
-from pymodbus.device import ModbusDeviceIdentification
-from pymodbus.transaction import *
-from pymodbus.exceptions import NotImplementedException, NoSuchSlaveException
-from pymodbus.pdu import ModbusExceptions as merror
-from pymodbus.compat import socketserver, byte2int
-
-# --------------------------------------------------------------------------- #
-# Logging
-# --------------------------------------------------------------------------- #
-import logging
-_logger = logging.getLogger(__name__)
-
-
-# --------------------------------------------------------------------------- #
-# Protocol Handlers
-# --------------------------------------------------------------------------- #
-
-class ModbusBaseRequestHandler(socketserver.BaseRequestHandler):
-    """ Implements the modbus server protocol
-
-    This uses the socketserver.BaseRequestHandler to implement
-    the client handler.
-    """
-    running = False
-    framer = None
-    
-    def setup(self):
-        """ Callback for when a client connects
-        """
-        _logger.debug("Client Connected [%s:%s]" % self.client_address)
-        self.running = True
-        self.framer = self.server.framer(self.server.decoder, client=None)
-        self.server.threads.append(self)
-
-    def finish(self):
-        """ Callback for when a client disconnects
-        """
-        _logger.debug("Client Disconnected [%s:%s]" % self.client_address)
-        self.server.threads.remove(self)
-
-    def execute(self, request):
-        """ The callback to call with the resulting message
-
-        :param request: The decoded request message
-        """
-        broadcast = False
-        try:
-            if self.server.broadcast_enable and request.unit_id == 0:
-                broadcast = True
-                # if broadcasting then execute on all slave contexts, note response will be ignored
-                for unit_id in self.server.context.slaves():
-                    response = request.execute(self.server.context[unit_id])
-            else:
-                context = self.server.context[request.unit_id]
-                response = request.execute(context)
-        except NoSuchSlaveException as ex:
-            _logger.debug("requested slave does "
-                          "not exist: %s" % request.unit_id )
-            if self.server.ignore_missing_slaves:
-                return  # the client will simply timeout waiting for a response
-            response = request.doException(merror.GatewayNoResponse)
-        except Exception as ex:
-            _logger.debug("Datastore unable to fulfill request: "
-                          "%s; %s", ex, traceback.format_exc())
-            response = request.doException(merror.SlaveFailure)
-        # no response when broadcasting
-        if not broadcast:
-            response.transaction_id = request.transaction_id
-            response.unit_id = request.unit_id
-            self.send(response)
-
-    # ----------------------------------------------------------------------- #
-    # Base class implementations
-    # ----------------------------------------------------------------------- #
-    def handle(self):
-        """ Callback when we receive any data
-        """
-        raise NotImplementedException("Method not implemented"
-                                      " by derived class")
-
-    def send(self, message):
-        """ Send a request (string) to the network
-
-        :param message: The unencoded modbus response
-        """
-        raise NotImplementedException("Method not implemented "
-                                      "by derived class")
-
-
-class ModbusSingleRequestHandler(ModbusBaseRequestHandler):
-    """ Implements the modbus server protocol
-
-    This uses the socketserver.BaseRequestHandler to implement
-    the client handler for a single client(serial clients)
-    """
-    def handle(self):
-        """ Callback when we receive any data
-        """
-        while self.running:
-            try:
-                data = self.request.recv(1024)
-                if data:
-                    units = self.server.context.slaves()
-                    if not isinstance(units, (list, tuple)):
-                        units = [units]
-                    # if broadcast is enabled make sure to process requests to address 0
-                    if self.server.broadcast_enable:
-                        if 0 not in units:
-                            units.append(0)
-                    single = self.server.context.single
-                    self.framer.processIncomingPacket(data, self.execute,
-                                                      units, single=single)
-            except Exception as msg:
-                # Since we only have a single socket, we cannot exit
-                # Clear frame buffer
-                self.framer.resetFrame()
-                _logger.debug("Error: Socket error occurred %s" % msg)
-
-    def send(self, message):
-        """ Send a request (string) to the network
-
-        :param message: The unencoded modbus response
-        """
-        if message.should_respond:
-            # self.server.control.Counter.BusMessage += 1
-            pdu = self.framer.buildPacket(message)
-            if _logger.isEnabledFor(logging.DEBUG):
-                _logger.debug('send: [%s]- %s' % (message, b2a_hex(pdu)))
-            return self.request.send(pdu)
-
-
-class CustomSingleRequestHandler(ModbusSingleRequestHandler):
-
-    def __init__(self, request, client_address, server):
-        self.request = request
-        self.client_address = client_address
-        self.server = server
-        self.running = True
-        self.setup()
-
-
-class ModbusConnectedRequestHandler(ModbusBaseRequestHandler):
-    """ Implements the modbus server protocol
-
-    This uses the socketserver.BaseRequestHandler to implement
-    the client handler for a connected protocol (TCP).
-    """
-
-    def handle(self):
-        """Callback when we receive any data, until self.running becomes False.
-        Blocks indefinitely awaiting data.  If shutdown is required, then the
-        global socket.settimeout(<seconds>) may be used, to allow timely
-        checking of self.running.  However, since this also affects socket
-        connects, if there are outgoing socket connections used in the same
-        program, then these will be prevented, if the specfied timeout is too
-        short.  Hence, this is unreliable.
-
-        To respond to Modbus...Server.server_close() (which clears each
-        handler's self.running), derive from this class to provide an
-        alternative handler that awakens from time to time when no input is
-        available and checks self.running.
-        Use Modbus...Server( handler=... ) keyword to supply the alternative
-        request handler class.
-
-        """
-        reset_frame = False
-        while self.running:
-            try:
-                units = self.server.context.slaves()
-                data = self.request.recv(1024)
-                if not data:
-                    self.running = False
-                else:
-                    if not isinstance(units, (list, tuple)):
-                        units = [units]
-                    # if broadcast is enabled make sure to
-                    # process requests to address 0
-                    if self.server.broadcast_enable:
-                        if 0 not in units:
-                            units.append(0)
-
-                if _logger.isEnabledFor(logging.DEBUG):
-                    _logger.debug('Handling data: ' + hexlify_packets(data))
-                single = self.server.context.single
-                self.framer.processIncomingPacket(data, self.execute, units,
-                                                  single=single)
-            except socket.timeout as msg:
-                if _logger.isEnabledFor(logging.DEBUG):
-                    _logger.debug("Socket timeout occurred %s", msg)
-                reset_frame = True
-            except socket.error as msg:
-                _logger.error("Socket error occurred %s" % msg)
-                self.running = False
-            except:
-                _logger.error("Socket exception occurred "
-                              "%s" % traceback.format_exc() )
-                self.running = False
-                reset_frame = True
-            finally:
-                if reset_frame:
-                    self.framer.resetFrame()
-                    reset_frame = False
-
-    def send(self, message):
-        """ Send a request (string) to the network
-
-        :param message: The unencoded modbus response
-        """
-        if message.should_respond:
-            # self.server.control.Counter.BusMessage += 1
-            pdu = self.framer.buildPacket(message)
-            if _logger.isEnabledFor(logging.DEBUG):
-                _logger.debug('send: [%s]- %s' % (message, b2a_hex(pdu)))
-            return self.request.send(pdu)
-
-
-class ModbusDisconnectedRequestHandler(ModbusBaseRequestHandler):
-    """ Implements the modbus server protocol
-
-    This uses the socketserver.BaseRequestHandler to implement
-    the client handler for a disconnected protocol (UDP). The
-    only difference is that we have to specify who to send the
-    resulting packet data to.
-    """
-    socket = None
-
-    def handle(self):
-        """ Callback when we receive any data
-        """
-        reset_frame = False
-        while self.running:
-            try:
-                data, self.socket = self.request
-                if not data:
-                    self.running = False
-                    data = b''
-                if _logger.isEnabledFor(logging.DEBUG):
-                    _logger.debug('Handling data: ' + hexlify_packets(data))
-                # if not self.server.control.ListenOnly:
-                units = self.server.context.slaves()
-                single = self.server.context.single
-                self.framer.processIncomingPacket(data, self.execute,
-                                                  units, single=single)
-            except socket.timeout: pass
-            except socket.error as msg:
-                _logger.error("Socket error occurred %s" % msg)
-                self.running = False
-                reset_frame = True
-            except Exception as msg:
-                _logger.error(msg)
-                self.running = False
-                reset_frame = True
-            finally:
-                # Reset data after processing
-                self.request = (None, self.socket)
-                if reset_frame:
-                    self.framer.resetFrame()
-                    reset_frame = False
-
-    def send(self, message):
-        """ Send a request (string) to the network
-
-        :param message: The unencoded modbus response
-        """
-        if message.should_respond:
-            #self.server.control.Counter.BusMessage += 1
-            pdu = self.framer.buildPacket(message)
-            if _logger.isEnabledFor(logging.DEBUG):
-                _logger.debug('send: [%s]- %s' % (message, b2a_hex(pdu)))
-            return self.socket.sendto(pdu, self.client_address)
-
-
-# --------------------------------------------------------------------------- #
-# Server Implementations
-# --------------------------------------------------------------------------- #
-class ModbusTcpServer(socketserver.ThreadingTCPServer):
-    """
-    A modbus threaded tcp socket server
-
-    We inherit and overload the socket server so that we
-    can control the client threads as well as have a single
-    server context instance.
-    """
-
-    def __init__(self, context, framer=None, identity=None,
-                 address=None, handler=None, allow_reuse_address=False,
-                 **kwargs):
-        """ Overloaded initializer for the socket server
-
-        If the identify structure is not passed in, the ModbusControlBlock
-        uses its own empty structure.
-
-        :param context: The ModbusServerContext datastore
-        :param framer: The framer strategy to use
-        :param identity: An optional identify structure
-        :param address: An optional (interface, port) to bind to.
-        :param handler: A handler for each client session; default is
-                        ModbusConnectedRequestHandler
-        :param allow_reuse_address: Whether the server will allow the
-                        reuse of an address.
-        :param ignore_missing_slaves: True to not send errors on a request 
-                        to a missing slave
-        :param broadcast_enable: True to treat unit_id 0 as broadcast address,
-                        False to treat 0 as any other unit_id
-        """
-        self.threads = []
-        self.allow_reuse_address = allow_reuse_address
-        self.decoder = ServerDecoder()
-        self.framer = framer or ModbusSocketFramer
-        self.context = context or ModbusServerContext()
-        self.control = ModbusControlBlock()
-        self.address = address or ("", Defaults.Port)
-        self.handler = handler or ModbusConnectedRequestHandler
-        self.ignore_missing_slaves = kwargs.get('ignore_missing_slaves',
-                                                Defaults.IgnoreMissingSlaves)
-        self.broadcast_enable = kwargs.get('broadcast_enable', 
-                                           Defaults.broadcast_enable)
-
-        if isinstance(identity, ModbusDeviceIdentification):
-            self.control.Identity.update(identity)
-
-        socketserver.ThreadingTCPServer.__init__(self, self.address,
-                                                 self.handler)
-
-    def process_request(self, request, client):
-        """ Callback for connecting a new client thread
-
-        :param request: The request to handle
-        :param client: The address of the client
-        """
-        _logger.debug("Started thread to serve client at " + str(client))
-        socketserver.ThreadingTCPServer.process_request(self, request, client)
-
-    def shutdown(self):
-        """ Stops the serve_forever loop.
-
-        Overridden to signal handlers to stop.
-        """
-        for thread in self.threads:
-            thread.running = False
-        socketserver.ThreadingTCPServer.shutdown(self)
-
-    def server_close(self):
-        """ Callback for stopping the running server
-        """
-        _logger.debug("Modbus server stopped")
-        self.socket.close()
-        for thread in self.threads:
-            thread.running = False
-
-
-class ModbusUdpServer(socketserver.ThreadingUDPServer):
-    """
-    A modbus threaded udp socket server
-
-    We inherit and overload the socket server so that we
-    can control the client threads as well as have a single
-    server context instance.
-    """
-
-    def __init__(self, context, framer=None, identity=None, address=None,
-                 handler=None, **kwargs):
-        """ Overloaded initializer for the socket server
-
-        If the identify structure is not passed in, the ModbusControlBlock
-        uses its own empty structure.
-
-        :param context: The ModbusServerContext datastore
-        :param framer: The framer strategy to use
-        :param identity: An optional identify structure
-        :param address: An optional (interface, port) to bind to.
-        :param handler: A handler for each client session; default is
-                            ModbusDisonnectedRequestHandler
-        :param ignore_missing_slaves: True to not send errors on a request
-                            to a missing slave
-        :param broadcast_enable: True to treat unit_id 0 as broadcast address,
-                            False to treat 0 as any other unit_id
-        """
-        self.threads = []
-        self.decoder = ServerDecoder()
-        self.framer = framer  or ModbusSocketFramer
-        self.context = context or ModbusServerContext()
-        self.control = ModbusControlBlock()
-        self.address = address or ("", Defaults.Port)
-        self.handler = handler or ModbusDisconnectedRequestHandler
-        self.ignore_missing_slaves = kwargs.get('ignore_missing_slaves',
-                                                Defaults.IgnoreMissingSlaves)
-        self.broadcast_enable = kwargs.get('broadcast_enable', 
-                                           Defaults.broadcast_enable)
-
-        if isinstance(identity, ModbusDeviceIdentification):
-            self.control.Identity.update(identity)
-
-        socketserver.ThreadingUDPServer.__init__(self,
-            self.address, self.handler)
-        # self._BaseServer__shutdown_request = True
-
-    def process_request(self, request, client):
-        """ Callback for connecting a new client thread
-
-        :param request: The request to handle
-        :param client: The address of the client
-        """
-        packet, socket = request # TODO I might have to rewrite
-        _logger.debug("Started thread to serve client at " + str(client))
-        socketserver.ThreadingUDPServer.process_request(self, request, client)
-
-    def server_close(self):
-        """ Callback for stopping the running server
-        """
-        _logger.debug("Modbus server stopped")
-        self.socket.close()
-        for thread in self.threads:
-            thread.running = False
-
-
-class ModbusSerialServer(object):
-    """
-    A modbus threaded serial socket server
-
-    We inherit and overload the socket server so that we
-    can control the client threads as well as have a single
-    server context instance.
-    """
-
-    handler = None
-
-    def __init__(self, context, framer=None, identity=None, **kwargs):
-        """ Overloaded initializer for the socket server
-
-        If the identify structure is not passed in, the ModbusControlBlock
-        uses its own empty structure.
-
-        :param context: The ModbusServerContext datastore
-        :param framer: The framer strategy to use
-        :param identity: An optional identify structure
-        :param port: The serial port to attach to
-        :param stopbits: The number of stop bits to use
-        :param bytesize: The bytesize of the serial messages
-        :param parity: Which kind of parity to use
-        :param baudrate: The baud rate to use for the serial device
-        :param timeout: The timeout to use for the serial device
-        :param ignore_missing_slaves: True to not send errors on a request
-                            to a missing slave
-        :param broadcast_enable: True to treat unit_id 0 as broadcast address,
-                            False to treat 0 as any other unit_id
-        """
-        self.threads = []
-        self.decoder = ServerDecoder()
-        self.framer = framer or ModbusAsciiFramer
-        self.context = context or ModbusServerContext()
-        self.control = ModbusControlBlock()
-
-        if isinstance(identity, ModbusDeviceIdentification):
-            self.control.Identity.update(identity)
-
-        self.device = kwargs.get('port', 0)
-        self.stopbits = kwargs.get('stopbits', Defaults.Stopbits)
-        self.bytesize = kwargs.get('bytesize', Defaults.Bytesize)
-        self.parity = kwargs.get('parity',   Defaults.Parity)
-        self.baudrate = kwargs.get('baudrate', Defaults.Baudrate)
-        self.timeout = kwargs.get('timeout',  Defaults.Timeout)
-        self.ignore_missing_slaves = kwargs.get('ignore_missing_slaves',
-                                                Defaults.IgnoreMissingSlaves)
-        self.broadcast_enable = kwargs.get('broadcast_enable',
-                                           Defaults.broadcast_enable)
-        self.socket = None
-        if self._connect():
-            self.is_running = True
-            self._build_handler()
-
-    def _connect(self):
-        """ Connect to the serial server
-
-        :returns: True if connection succeeded, False otherwise
-        """
-        if self.socket: return True
-        try:
-            self.socket = serial.Serial(port=self.device,
-                                        timeout=self.timeout,
-                                        bytesize=self.bytesize,
-                                        stopbits=self.stopbits,
-                                        baudrate=self.baudrate,
-                                        parity=self.parity)
-        except serial.SerialException as msg:
-            _logger.error(msg)
-        return self.socket is not None
-
-    def _build_handler(self):
-        """ A helper method to create and monkeypatch
-            a serial handler.
-
-        :returns: A patched handler
-        """
-
-        request = self.socket
-        request.send = request.write
-        request.recv = request.read
-        self.handler = CustomSingleRequestHandler(request,
-                                                  (self.device, self.device),
-                                                  self)
-
-    def serve_forever(self):
-        """ Callback for connecting a new client thread
-        """
-        if self._connect():
-            _logger.debug("Started thread to serve client")
-            if not self.handler:
-                self._build_handler()
-            while self.is_running:
-                self.handler.handle()
-        else:
-            _logger.error("Error opening serial port , "
-                          "Unable to start server!!")
-
-    def server_close(self):
-        """ Callback for stopping the running server
-        """
-        _logger.debug("Modbus server stopped")
-        self.is_running = False
-        self.handler.finish()
-        self.handler.running = False
-        self.handler = None
-        self.socket.close()
-
-
-# --------------------------------------------------------------------------- #
-# Creation Factories
-# --------------------------------------------------------------------------- #
-def StartTcpServer(context=None, identity=None, address=None,
-                   custom_functions=[], **kwargs):
-    """ A factory to start and run a tcp modbus server
-
-    :param context: The ModbusServerContext datastore
-    :param identity: An optional identify structure
-    :param address: An optional (interface, port) to bind to.
-    :param custom_functions: An optional list of custom function classes
-        supported by server instance.
-    :param ignore_missing_slaves: True to not send errors on a request to a
-                                      missing slave
-    """
-    framer = kwargs.pop("framer", ModbusSocketFramer)
-    server = ModbusTcpServer(context, framer, identity, address, **kwargs)
-
-    for f in custom_functions:
-        server.decoder.register(f)
-    server.serve_forever()
-
-
-def StartUdpServer(context=None, identity=None, address=None,
-                   custom_functions=[], **kwargs):
-    """ A factory to start and run a udp modbus server
-
-    :param context: The ModbusServerContext datastore
-    :param identity: An optional identify structure
-    :param address: An optional (interface, port) to bind to.
-    :param custom_functions: An optional list of custom function classes
-        supported by server instance.
-    :param framer: The framer to operate with (default ModbusSocketFramer)
-    :param ignore_missing_slaves: True to not send errors on a request
-                                    to a missing slave
-    """
-    framer = kwargs.pop('framer', ModbusSocketFramer)
-    server = ModbusUdpServer(context, framer, identity, address, **kwargs)
-    for f in custom_functions:
-        server.decoder.register(f)
-    server.serve_forever()
-
-
-def StartSerialServer(context=None, identity=None,  custom_functions=[],
-                      **kwargs):
-    """ A factory to start and run a serial modbus server
-
-    :param context: The ModbusServerContext datastore
-    :param identity: An optional identify structure
-    :param custom_functions: An optional list of custom function classes
-        supported by server instance.
-    :param framer: The framer to operate with (default ModbusAsciiFramer)
-    :param port: The serial port to attach to
-    :param stopbits: The number of stop bits to use
-    :param bytesize: The bytesize of the serial messages
-    :param parity: Which kind of parity to use
-    :param baudrate: The baud rate to use for the serial device
-    :param timeout: The timeout to use for the serial device
-    :param ignore_missing_slaves: True to not send errors on a request to a
-                                  missing slave
-    """
-    framer = kwargs.pop('framer', ModbusAsciiFramer)
-    server = ModbusSerialServer(context, framer, identity, **kwargs)
-    for f in custom_functions:
-        server.decoder.register(f)
-    server.serve_forever()
-
-# --------------------------------------------------------------------------- #
-# Exported symbols
-# --------------------------------------------------------------------------- #
-
-
-__all__ = [
-    "StartTcpServer", "StartUdpServer", "StartSerialServer"
-]
-
diff --git a/venv/lib/python3.7/site-packages/pymodbus/transaction.py b/venv/lib/python3.7/site-packages/pymodbus/transaction.py
deleted file mode 100644
index 579fcd8..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/transaction.py
+++ /dev/null
@@ -1,464 +0,0 @@
-"""
-Collection of transaction based abstractions
-
-"""
-
-import struct
-import socket
-from threading import RLock
-from functools import partial
-
-from pymodbus.exceptions import ModbusIOException, NotImplementedException
-from pymodbus.exceptions import InvalidMessageReceivedException
-from pymodbus.constants import Defaults
-from pymodbus.framer.ascii_framer import ModbusAsciiFramer
-from pymodbus.framer.rtu_framer import ModbusRtuFramer
-from pymodbus.framer.socket_framer import ModbusSocketFramer
-from pymodbus.framer.binary_framer import ModbusBinaryFramer
-from pymodbus.utilities import hexlify_packets, ModbusTransactionState
-from pymodbus.compat import iterkeys, byte2int
-
-
-# Python 2 compatibility.
-try:
-    TimeoutError
-except NameError:
-    TimeoutError = socket.timeout
-
-
-# --------------------------------------------------------------------------- #
-# Logging
-# --------------------------------------------------------------------------- #
-import logging
-_logger = logging.getLogger(__name__)
-
-
-# --------------------------------------------------------------------------- #
-# The Global Transaction Manager
-# --------------------------------------------------------------------------- #
-class ModbusTransactionManager(object):
-    """ Impelements a transaction for a manager
-
-    The transaction protocol can be represented by the following pseudo code::
-
-        count = 0
-        do
-          result = send(message)
-          if (timeout or result == bad)
-             count++
-          else break
-        while (count < 3)
-
-    This module helps to abstract this away from the framer and protocol.
-    """
-
-    def __init__(self, client, **kwargs):
-        """ Initializes an instance of the ModbusTransactionManager
-
-        :param client: The client socket wrapper
-        :param retry_on_empty: Should the client retry on empty
-        :param retries: The number of retries to allow
-        """
-        self.tid = Defaults.TransactionId
-        self.client = client
-        self.retry_on_empty = kwargs.get('retry_on_empty', Defaults.RetryOnEmpty)
-        self.retries = kwargs.get('retries', Defaults.Retries) or 1
-        self._transaction_lock = RLock()
-        self._no_response_devices = []
-        if client:
-            self._set_adu_size()
-
-    def _set_adu_size(self):
-        # base ADU size of modbus frame in bytes
-        if isinstance(self.client.framer, ModbusSocketFramer):
-            self.base_adu_size = 7  # tid(2), pid(2), length(2), uid(1)
-        elif isinstance(self.client.framer, ModbusRtuFramer):
-            self.base_adu_size = 3  # address(1), CRC(2)
-        elif isinstance(self.client.framer, ModbusAsciiFramer):
-            self.base_adu_size = 7  # start(1)+ Address(2), LRC(2) + end(2)
-        elif isinstance(self.client.framer, ModbusBinaryFramer):
-            self.base_adu_size = 5  # start(1) + Address(1), CRC(2) + end(1)
-        else:
-            self.base_adu_size = -1
-
-    def _calculate_response_length(self, expected_pdu_size):
-        if self.base_adu_size == -1:
-            return None
-        else:
-            return self.base_adu_size + expected_pdu_size
-
-    def _calculate_exception_length(self):
-        """ Returns the length of the Modbus Exception Response according to
-        the type of Framer.
-        """
-        if isinstance(self.client.framer, ModbusSocketFramer):
-            return self.base_adu_size + 2  # Fcode(1), ExcecptionCode(1)
-        elif isinstance(self.client.framer, ModbusAsciiFramer):
-            return self.base_adu_size + 4  # Fcode(2), ExcecptionCode(2)
-        elif isinstance(self.client.framer, (ModbusRtuFramer, 
-                                             ModbusBinaryFramer)):
-            return self.base_adu_size + 2  # Fcode(1), ExcecptionCode(1)
-
-        return None
-
-    def execute(self, request):
-        """ Starts the producer to send the next request to
-        consumer.write(Frame(request))
-        """
-        with self._transaction_lock:
-            try:
-                _logger.debug("Current transaction state - {}".format(
-                    ModbusTransactionState.to_string(self.client.state))
-                )
-                retries = self.retries
-                request.transaction_id = self.getNextTID()
-                _logger.debug("Running transaction "
-                              "{}".format(request.transaction_id))
-                _buffer = hexlify_packets(self.client.framer._buffer)
-                if _buffer:
-                    _logger.debug("Clearing current Frame "
-                                  ": - {}".format(_buffer))
-                    self.client.framer.resetFrame()
-                broadcast = (self.client.broadcast_enable
-                             and request.unit_id == 0)
-                if broadcast:
-                    self._transact(request, None, broadcast=True)
-                    response = b'Broadcast write sent - no response expected'
-                else:
-                    expected_response_length = None
-                    if not isinstance(self.client.framer, ModbusSocketFramer):
-                        if hasattr(request, "get_response_pdu_size"):
-                            response_pdu_size = request.get_response_pdu_size()
-                            if isinstance(self.client.framer, ModbusAsciiFramer):
-                                response_pdu_size = response_pdu_size * 2
-                            if response_pdu_size:
-                                expected_response_length = self._calculate_response_length(response_pdu_size)
-                    if request.unit_id in self._no_response_devices:
-                        full = True
-                    else:
-                        full = False
-                    c_str = str(self.client)
-                    if "modbusudpclient" in c_str.lower().strip():
-                        full = True
-                        if not expected_response_length:
-                            expected_response_length = Defaults.ReadSize
-                    response, last_exception = self._transact(
-                        request,
-                        expected_response_length,
-                        full=full,
-                        broadcast=broadcast
-                    )
-                    if not response and (
-                            request.unit_id not in self._no_response_devices):
-                        self._no_response_devices.append(request.unit_id)
-                    elif request.unit_id in self._no_response_devices and response:
-                        self._no_response_devices.remove(request.unit_id)
-                    if not response and self.retry_on_empty and retries:
-                        while retries > 0:
-                            if hasattr(self.client, "state"):
-                                _logger.debug("RESETTING Transaction state to "
-                                              "'IDLE' for retry")
-                                self.client.state = ModbusTransactionState.IDLE
-                            _logger.debug("Retry on empty - {}".format(retries))
-                            response, last_exception = self._transact(
-                                request,
-                                expected_response_length
-                            )
-                            if not response:
-                                retries -= 1
-                                continue
-                            # Remove entry
-                            self._no_response_devices.remove(request.unit_id)
-                            break
-                    addTransaction = partial(self.addTransaction,
-                                             tid=request.transaction_id)
-                    self.client.framer.processIncomingPacket(response,
-                                                             addTransaction,
-                                                             request.unit_id)
-                    response = self.getTransaction(request.transaction_id)
-                    if not response:
-                        if len(self.transactions):
-                            response = self.getTransaction(tid=0)
-                        else:
-                            last_exception = last_exception or (
-                                "No Response received from the remote unit"
-                                "/Unable to decode response")
-                            response = ModbusIOException(last_exception,
-                                                         request.function_code)
-                    if hasattr(self.client, "state"):
-                        _logger.debug("Changing transaction state from "
-                                      "'PROCESSING REPLY' to "
-                                      "'TRANSACTION_COMPLETE'")
-                        self.client.state = (
-                            ModbusTransactionState.TRANSACTION_COMPLETE)
-                return response
-            except ModbusIOException as ex:
-                # Handle decode errors in processIncomingPacket method
-                _logger.exception(ex)
-                self.client.state = ModbusTransactionState.TRANSACTION_COMPLETE
-                return ex
-
-    def _transact(self, packet, response_length, full=False, broadcast=False):
-        """
-        Does a Write and Read transaction
-        :param packet: packet to be sent
-        :param response_length:  Expected response length
-        :param full: the target device was notorious for its no response. Dont
-            waste time this time by partial querying
-        :return: response
-        """
-        last_exception = None
-        try:
-            self.client.connect()
-            packet = self.client.framer.buildPacket(packet)
-            if _logger.isEnabledFor(logging.DEBUG):
-                _logger.debug("SEND: " + hexlify_packets(packet))
-            size = self._send(packet)
-            if broadcast:
-                if size:
-                    _logger.debug("Changing transaction state from 'SENDING' "
-                                  "to 'TRANSACTION_COMPLETE'")
-                    self.client.state = ModbusTransactionState.TRANSACTION_COMPLETE
-                return b'', None
-            if size:
-                _logger.debug("Changing transaction state from 'SENDING' "
-                              "to 'WAITING FOR REPLY'")
-                self.client.state = ModbusTransactionState.WAITING_FOR_REPLY
-            result = self._recv(response_length, full)
-            if _logger.isEnabledFor(logging.DEBUG):
-                    _logger.debug("RECV: " + hexlify_packets(result))
-
-        except (socket.error, ModbusIOException,
-                InvalidMessageReceivedException) as msg:
-            self.client.close()
-            _logger.debug("Transaction failed. (%s) " % msg)
-            last_exception = msg
-            result = b''
-        return result, last_exception
-
-    def _send(self, packet):
-        return self.client.framer.sendPacket(packet)
-
-    def _recv(self, expected_response_length, full):
-        total = None
-        if not full:
-            exception_length = self._calculate_exception_length()
-            if isinstance(self.client.framer, ModbusSocketFramer):
-                min_size = 8
-            elif isinstance(self.client.framer, ModbusRtuFramer):
-                min_size = 2
-            elif isinstance(self.client.framer, ModbusAsciiFramer):
-                min_size = 5
-            elif isinstance(self.client.framer, ModbusBinaryFramer):
-                min_size = 3
-            else:
-                min_size = expected_response_length
-
-            read_min = self.client.framer.recvPacket(min_size)
-            if len(read_min) != min_size:
-                raise InvalidMessageReceivedException(
-                    "Incomplete message received, expected at least %d bytes "
-                    "(%d received)" % (min_size, len(read_min))
-                )
-            if read_min:
-                if isinstance(self.client.framer, ModbusSocketFramer):
-                    func_code = byte2int(read_min[-1])
-                elif isinstance(self.client.framer, ModbusRtuFramer):
-                    func_code = byte2int(read_min[-1])
-                elif isinstance(self.client.framer, ModbusAsciiFramer):
-                    func_code = int(read_min[3:5], 16)
-                elif isinstance(self.client.framer, ModbusBinaryFramer):
-                    func_code = byte2int(read_min[-1])
-                else:
-                    func_code = -1
-
-                if func_code < 0x80:    # Not an error
-                    if isinstance(self.client.framer, ModbusSocketFramer):
-                        # Ommit UID, which is included in header size
-                        h_size = self.client.framer._hsize
-                        length = struct.unpack(">H", read_min[4:6])[0] - 1
-                        expected_response_length = h_size + length
-                    if expected_response_length is not None:
-                        expected_response_length -= min_size
-                        total = expected_response_length + min_size
-                else:
-                    expected_response_length = exception_length - min_size
-                    total = expected_response_length + min_size
-            else:
-                total = expected_response_length
-        else:
-            read_min = b''
-            total = expected_response_length
-        result = self.client.framer.recvPacket(expected_response_length)
-        result = read_min + result
-        actual = len(result)
-        if total is not None and actual != total:
-            _logger.debug("Incomplete message received, "
-                          "Expected {} bytes Recieved "
-                          "{} bytes !!!!".format(total, actual))
-        if self.client.state != ModbusTransactionState.PROCESSING_REPLY:
-            _logger.debug("Changing transaction state from "
-                          "'WAITING FOR REPLY' to 'PROCESSING REPLY'")
-            self.client.state = ModbusTransactionState.PROCESSING_REPLY
-        return result
-
-    def addTransaction(self, request, tid=None):
-        """ Adds a transaction to the handler
-
-        This holds the requets in case it needs to be resent.
-        After being sent, the request is removed.
-
-        :param request: The request to hold on to
-        :param tid: The overloaded transaction id to use
-        """
-        raise NotImplementedException("addTransaction")
-
-    def getTransaction(self, tid):
-        """ Returns a transaction matching the referenced tid
-
-        If the transaction does not exist, None is returned
-
-        :param tid: The transaction to retrieve
-        """
-        raise NotImplementedException("getTransaction")
-
-    def delTransaction(self, tid):
-        """ Removes a transaction matching the referenced tid
-
-        :param tid: The transaction to remove
-        """
-        raise NotImplementedException("delTransaction")
-
-    def getNextTID(self):
-        """ Retrieve the next unique transaction identifier
-
-        This handles incrementing the identifier after
-        retrieval
-
-        :returns: The next unique transaction identifier
-        """
-        self.tid = (self.tid + 1) & 0xffff
-        return self.tid
-
-    def reset(self):
-        """ Resets the transaction identifier """
-        self.tid = Defaults.TransactionId
-        self.transactions = type(self.transactions)()
-
-
-class DictTransactionManager(ModbusTransactionManager):
-    """ Impelements a transaction for a manager where the
-    results are keyed based on the supplied transaction id.
-    """
-
-    def __init__(self, client, **kwargs):
-        """ Initializes an instance of the ModbusTransactionManager
-
-        :param client: The client socket wrapper
-        """
-        self.transactions = {}
-        super(DictTransactionManager, self).__init__(client, **kwargs)
-
-    def __iter__(self):
-        """ Iterater over the current managed transactions
-
-        :returns: An iterator of the managed transactions
-        """
-        return iterkeys(self.transactions)
-
-    def addTransaction(self, request, tid=None):
-        """ Adds a transaction to the handler
-
-        This holds the requets in case it needs to be resent.
-        After being sent, the request is removed.
-
-        :param request: The request to hold on to
-        :param tid: The overloaded transaction id to use
-        """
-        tid = tid if tid != None else request.transaction_id
-        _logger.debug("Adding transaction %d" % tid)
-        self.transactions[tid] = request
-
-    def getTransaction(self, tid):
-        """ Returns a transaction matching the referenced tid
-
-        If the transaction does not exist, None is returned
-
-        :param tid: The transaction to retrieve
-
-        """
-        _logger.debug("Getting transaction %d" % tid)
-
-        return self.transactions.pop(tid, None)
-
-    def delTransaction(self, tid):
-        """ Removes a transaction matching the referenced tid
-
-        :param tid: The transaction to remove
-        """
-        _logger.debug("deleting transaction %d" % tid)
-
-        self.transactions.pop(tid, None)
-
-
-class FifoTransactionManager(ModbusTransactionManager):
-    """ Impelements a transaction for a manager where the
-    results are returned in a FIFO manner.
-    """
-
-    def __init__(self, client, **kwargs):
-        """ Initializes an instance of the ModbusTransactionManager
-
-        :param client: The client socket wrapper
-        """
-        super(FifoTransactionManager, self).__init__(client, **kwargs)
-        self.transactions = []
-
-    def __iter__(self):
-        """ Iterater over the current managed transactions
-
-        :returns: An iterator of the managed transactions
-        """
-        return iter(self.transactions)
-
-    def addTransaction(self, request, tid=None):
-        """ Adds a transaction to the handler
-
-        This holds the requets in case it needs to be resent.
-        After being sent, the request is removed.
-
-        :param request: The request to hold on to
-        :param tid: The overloaded transaction id to use
-        """
-        tid = tid if tid is not None else request.transaction_id
-        _logger.debug("Adding transaction %d" % tid)
-
-        self.transactions.append(request)
-
-    def getTransaction(self, tid):
-        """ Returns a transaction matching the referenced tid
-
-        If the transaction does not exist, None is returned
-
-        :param tid: The transaction to retrieve
-        """
-        return self.transactions.pop(0) if self.transactions else None
-
-    def delTransaction(self, tid):
-        """ Removes a transaction matching the referenced tid
-
-        :param tid: The transaction to remove
-        """
-        _logger.debug("Deleting transaction %d" % tid)
-        if self.transactions: self.transactions.pop(0)
-
-# --------------------------------------------------------------------------- #
-# Exported symbols
-# --------------------------------------------------------------------------- #
-
-__all__ = [
-    "FifoTransactionManager",
-    "DictTransactionManager",
-    "ModbusSocketFramer", "ModbusRtuFramer",
-    "ModbusAsciiFramer", "ModbusBinaryFramer",
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/utilities.py b/venv/lib/python3.7/site-packages/pymodbus/utilities.py
deleted file mode 100644
index 6d38ca3..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/utilities.py
+++ /dev/null
@@ -1,252 +0,0 @@
-"""
-Modbus Utilities
------------------
-
-A collection of utilities for packing data, unpacking
-data computing checksums, and decode checksums.
-"""
-from pymodbus.compat import int2byte, byte2int, IS_PYTHON3
-from six import string_types
-
-
-class ModbusTransactionState(object):
-    """
-    Modbus Client States
-    """
-    IDLE = 0
-    SENDING = 1
-    WAITING_FOR_REPLY = 2
-    WAITING_TURNAROUND_DELAY = 3
-    PROCESSING_REPLY = 4
-    PROCESSING_ERROR = 5
-    TRANSACTION_COMPLETE = 6
-
-    @classmethod
-    def to_string(cls, state):
-        states = {
-            ModbusTransactionState.IDLE: "IDLE",
-            ModbusTransactionState.SENDING: "SENDING",
-            ModbusTransactionState.WAITING_FOR_REPLY: "WAITING_FOR_REPLY",
-            ModbusTransactionState.WAITING_TURNAROUND_DELAY: "WAITING_TURNAROUND_DELAY",
-            ModbusTransactionState.PROCESSING_REPLY: "PROCESSING_REPLY",
-            ModbusTransactionState.PROCESSING_ERROR: "PROCESSING_ERROR",
-            ModbusTransactionState.TRANSACTION_COMPLETE: "TRANSACTION_COMPLETE"
-        }
-        return states.get(state, None)
-
-
-# --------------------------------------------------------------------------- #
-# Helpers
-# --------------------------------------------------------------------------- #
-
-def default(value):
-    """
-    Given a python object, return the default value
-    of that object.
-
-    :param value: The value to get the default of
-    :returns: The default value
-    """
-    return type(value)()
-
-
-def dict_property(store, index):
-    """ Helper to create class properties from a dictionary.
-    Basically this allows you to remove a lot of possible
-    boilerplate code.
-
-    :param store: The store store to pull from
-    :param index: The index into the store to close over
-    :returns: An initialized property set
-    """
-    if hasattr(store, '__call__'):
-        getter = lambda self: store(self)[index]
-        setter = lambda self, value: store(self).__setitem__(index, value)
-    elif isinstance(store, str):
-        getter = lambda self: self.__getattribute__(store)[index]
-        setter = lambda self, value: self.__getattribute__(store).__setitem__(
-            index, value)
-    else:
-        getter = lambda self: store[index]
-        setter = lambda self, value: store.__setitem__(index, value)
-
-    return property(getter, setter)
-
-
-# --------------------------------------------------------------------------- #
-# Bit packing functions
-# --------------------------------------------------------------------------- #
-def pack_bitstring(bits):
-    """ Creates a string out of an array of bits
-
-    :param bits: A bit array
-
-    example::
-
-        bits   = [False, True, False, True]
-        result = pack_bitstring(bits)
-    """
-    ret = b''
-    i = packed = 0
-    for bit in bits:
-        if bit:
-            packed += 128
-        i += 1
-        if i == 8:
-            ret += int2byte(packed)
-            i = packed = 0
-        else:
-            packed >>= 1
-    if 0 < i < 8:
-        packed >>= (7 - i)
-        ret += int2byte(packed)
-    return ret
-
-
-def unpack_bitstring(string):
-    """ Creates bit array out of a string
-
-    :param string: The modbus data packet to decode
-
-    example::
-
-        bytes  = 'bytes to decode'
-        result = unpack_bitstring(bytes)
-    """
-    byte_count = len(string)
-    bits = []
-    for byte in range(byte_count):
-        if IS_PYTHON3:
-            value = byte2int(int(string[byte]))
-        else:
-            value = byte2int(string[byte])
-        for _ in range(8):
-            bits.append((value & 1) == 1)
-            value >>= 1
-    return bits
-
-
-def make_byte_string(s):
-    """
-    Returns byte string from a given string, python3 specific fix
-    :param s:
-    :return:
-    """
-    if IS_PYTHON3 and isinstance(s, string_types):
-        s = s.encode()
-    return s
-# --------------------------------------------------------------------------- #
-# Error Detection Functions
-# --------------------------------------------------------------------------- #
-def __generate_crc16_table():
-    """ Generates a crc16 lookup table
-
-    .. note:: This will only be generated once
-    """
-    result = []
-    for byte in range(256):
-        crc = 0x0000
-        for _ in range(8):
-            if (byte ^ crc) & 0x0001:
-                crc = (crc >> 1) ^ 0xa001
-            else: crc >>= 1
-            byte >>= 1
-        result.append(crc)
-    return result
-
-__crc16_table = __generate_crc16_table()
-
-
-def computeCRC(data):
-    """ Computes a crc16 on the passed in string. For modbus,
-    this is only used on the binary serial protocols (in this
-    case RTU).
-
-    The difference between modbus's crc16 and a normal crc16
-    is that modbus starts the crc value out at 0xffff.
-
-    :param data: The data to create a crc16 of
-    :returns: The calculated CRC
-    """
-    crc = 0xffff
-    for a in data:
-        idx = __crc16_table[(crc ^ byte2int(a)) & 0xff]
-        crc = ((crc >> 8) & 0xff) ^ idx
-    swapped = ((crc << 8) & 0xff00) | ((crc >> 8) & 0x00ff)
-    return swapped
-
-
-def checkCRC(data, check):
-    """ Checks if the data matches the passed in CRC
-
-    :param data: The data to create a crc16 of
-    :param check: The CRC to validate
-    :returns: True if matched, False otherwise
-    """
-    return computeCRC(data) == check
-
-
-def computeLRC(data):
-    """ Used to compute the longitudinal redundancy check
-    against a string. This is only used on the serial ASCII
-    modbus protocol. A full description of this implementation
-    can be found in appendex B of the serial line modbus description.
-
-    :param data: The data to apply a lrc to
-    :returns: The calculated LRC
-
-    """
-    lrc = sum(byte2int(a) for a in data) & 0xff
-    lrc = (lrc ^ 0xff) + 1
-    return lrc & 0xff
-
-
-def checkLRC(data, check):
-    """ Checks if the passed in data matches the LRC
-
-    :param data: The data to calculate
-    :param check: The LRC to validate
-    :returns: True if matched, False otherwise
-    """
-    return computeLRC(data) == check
-
-
-def rtuFrameSize(data, byte_count_pos):
-    """ Calculates the size of the frame based on the byte count.
-
-    :param data: The buffer containing the frame.
-    :param byte_count_pos: The index of the byte count in the buffer.
-    :returns: The size of the frame.
-
-    The structure of frames with a byte count field is always the
-    same:
-
-    - first, there are some header fields
-    - then the byte count field
-    - then as many data bytes as indicated by the byte count,
-    - finally the CRC (two bytes).
-
-    To calculate the frame size, it is therefore sufficient to extract
-    the contents of the byte count field, add the position of this
-    field, and finally increment the sum by three (one byte for the
-    byte count field, two for the CRC).
-    """
-    return byte2int(data[byte_count_pos]) + byte_count_pos + 3
-
-
-def hexlify_packets(packet):
-    """
-    Returns hex representation of bytestring recieved
-    :param packet:
-    :return:
-    """
-    if not packet:
-        return ''
-    return " ".join([hex(byte2int(x)) for x in packet])
-# --------------------------------------------------------------------------- #
-# Exported symbols
-# --------------------------------------------------------------------------- #
-__all__ = [
-    'pack_bitstring', 'unpack_bitstring', 'default',
-    'computeCRC', 'checkCRC', 'computeLRC', 'checkLRC', 'rtuFrameSize'
-]
diff --git a/venv/lib/python3.7/site-packages/pymodbus/version.py b/venv/lib/python3.7/site-packages/pymodbus/version.py
deleted file mode 100644
index 51da887..0000000
--- a/venv/lib/python3.7/site-packages/pymodbus/version.py
+++ /dev/null
@@ -1,53 +0,0 @@
-"""
-Handle the version information here; you should only have to
-change the version tuple.
-
-Since we are using twisted's version class, we can also query
-the svn version as well using the local .entries file.
-"""
-
-
-class Version(object):
-
-    def __init__(self, package, major, minor, micro, pre=None):
-        """
-
-        :param package: Name of the package that this is a version of.
-        :param major: The major version number.
-        :param minor: The minor version number.
-        :param micro: The micro version number.
-        :param pre: The pre release tag
-        """
-        self.package = package
-        self.major = major
-        self.minor = minor
-        self.micro = micro
-        self.pre = pre
-
-    def short(self):
-        """ Return a string in canonical short version format
-        <major>.<minor>.<micro>.<pre>
-        """
-        if self.pre:
-            return '%d.%d.%d.%s' % (self.major, self.minor, self.micro, self.pre)
-        else:
-            return '%d.%d.%d' % (self.major, self.minor, self.micro)
-
-    def __str__(self):
-        """ Returns a string representation of the object
-
-        :returns: A string representation of this object
-        """
-        return '[%s, version %s]' % (self.package, self.short())
-
-
-version = Version('pymodbus', 2, 2, 0)
-
-
-version.__name__ = 'pymodbus'  # fix epydoc error
-
-# --------------------------------------------------------------------------- #
-# Exported symbols
-# --------------------------------------------------------------------------- #
-
-__all__ = ["version"]
